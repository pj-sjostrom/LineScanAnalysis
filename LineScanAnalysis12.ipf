#pragma rtGlobals=1		// Use modern global access method.#pragma DefaultTab={3,20,4}// MultiAnalysisProc// ReAnalyzeDataSetProc//************************************************************************************//  Fluorescence analysis of linescan data//						Kazuo Kitamura//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Modifications by Jesper Sjostrom, starting on 2004-04-23//	*	Image size can be changed//	*	Moved the drawing of the image to a separate procedure. This procedure {ProduceImage} assumes that the image//		is located in the 2D wave CurrentImage//	*	Added cursors so that the LS, BG, and F0 boundaries can be selected ("grabbed") more easily.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2004-05-07://	*	Re-structured panel to two regions: "Load & Display" and "Analysis"//	*	Re-structured the code to have more self-contained subroutines//	*	Added an Analyze Multi button, to analyze and average multiple waves of the same condition////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2004-10-18://	*	Green and red channels can be flipped by changing the value of the global variable flipCh//		-	flipCh == 0 means Red is 1 and Green is 0//		-	flipCh == 1 means Red is 0 and Green is 1////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2004-11-02://	*	Added extensive additional analysis features://		-	a data table showing the results of repeated analysis//		-	current data that is extracted includes two fixed positions and one positive maximum//	*	LineScanAnalysis now reads the ms-per-line and the fill fraction from the ScanImage TIFF header and sets the //		pop-up menu accordingly. (This feature requires Igor 5.03 or above.)//	*	Added a "Reanalyze dataset" feature that records the suffix numbers, the number of files, and the increments of each//		condition, so that a quick reanalysis of all conditions can be done, e.g. to check whether dG/R and dG/G give different results.//	*	Made a "Compile traces" feature that compiles all averaged traces from all conditions into one overall graph.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2004-11-04://	*	Added extensive features for simplified management of extracted data://		-	A parameter table, to keep track of animal age, position of dendritic recordings, position of 2plsm linescan etc.//		-	A few buttons for automatically entering data into the parameter table, e.g. adding the date and the position of the//			linescan as extracted from the ScanImage TIFF header.//		-	A button for automatic naming of the filename for the extracted data (for the purposes of exporting the data).//		-	A button for exporting the extracted data: This feature exports all the data in the "data table" as well as the data in//			in the "parameter table", plus some invisible data that would enable the reconstruction of the averaged traces.//	*	Also added buttons for the simplified selection of regions in the linescan image window.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2004-11-09://	*	The ReAnalyze feature can now start at any image suffix the user chooses, to simplify repeated analysis of data of//		the same general structure. (Strictly speaking no longer "reanalysis", just "analysis"...)//	*	Added a chache to speed up the Match ePhys function. This will have a huge impact especially when searching over//		the network.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2004-11-30://	*	Fixed Auto Regions button to use a smoothed average of four linescans to estimate standard deviation.//	*	Global variables are now read from old variable before being initiated -- enables the user to restart panel without losing old settings.//	*	Compile Traces button can now smooth data. Also, SEM can be removed.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2004-12-15//	*	Analyze Multi and Match ePhys now run considerably faster//	*	Global waves are now only recreated if they do not already exist, to prevent old data to be overwritten when restarting the panel.//	*	Added measure integral feature to the analysis component//	*	Added SuffixStartWave,nFilesWave,  and IncrementWave to the LS_DataTable, thus enabling editing for the purposes of reanalysis//	*	Match ePhys can now search in another directory than that to which the imaging data belongs////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2005-02-01//	*	Added a Skip LineScans feature to skip the inclusion in the average of the occasional bad linescan in a series of good linescans////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2005-09-28//	*	Added automatic extraction of dendritic diameter based on the settings of LS_left, LS_right, and the data provided in the//		ScanImage Comments. These are now entered automatically into the ParamTable when the user clicks {Auto fill-in data}.//		(The dendritic diameter is thus essentially a result of the Auto regions function, which extracts the line scan ROI based//		on a gaussian fit, using 1 SD as the borders.)////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2005-09-30//	*	Can now use shift key with the Load Image button to reload the data.//	*	Fixed a bug associated with the loading of the ScanImage header.//	*	Improved the Auto regions button. If there are several peaks in the linescan due to several dendrites, the user can now hold down the//		shift key while pressing this button, and the search procedure will focus on the ROI specified by LS_Left and LS_Right ± 200%. This//		enables automatic fitting in complex situations with more than one dendrite in focus.//	*	Added Toggle HD function that toggles the ScanImage data path between Aluminium HD and the portable HD Jesper_HD80.//	*	Improved the dendritic diameter measurements, by measuring one diameter from the green channel and one diameter from the red//		channel, and storing both the parameters data table.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2006-03-08//	*	When loading non-linescan TIFF files, Tag data folders build up. Added a function ClearTags() to take care of this.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2006-11-08//	*	Asks user if restart is needed////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2006-11-09//	*	Added zoom-in button to analysis windows, which zooms in on region specified by F0_Upper and F0_Upper+500 ms or the end of the//		trace, whichever happens first.//	*	Added similar zoom-in button to image graph too. Both of these are need to simplify the managing of data acquired with a delayed//		shutter opening.//	*	Fixed a small calculation error in Kazuo's code: F0_Height, F0_Width, and BG_Width all need a '+1' at the end, to account for the last//		pixel in a range from e.g. F0_Upper to F0_Lower. The impact on previously analyzed data is minimal, but the error shifted the baseline of//		analyzed traces slightly down, which made it look not so pretty.//	*	Fixed bug in Auto regions proc to make it work better with data that has shot noise in it.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2006-11-21//	*	Improved on the reanalyze settings: Both the suffix start and the overall number of waves can now be set with the click of a button.//	*	Added a pre-smooth function, that smooths the linescans before they are averaged. Use with care.//	*	Added a realign baseline feature, which realigns the baselines of traces in the Compile Traces graph.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2007-08-21//	*	Added feature to calculate R/G for Takayuki////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2009-11-04//	*	Made LineScanAnalysis aware of frames in linescans////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2009-11-20//	*	Added frame scan analysis capacity. This is a significant re-write, adding ROI handling.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2009-11-25//	*	Fixed several bad bugs in the frame scan analysis.//	*	Added feature for quickly plotting bars from data table//	*	Added the possibility to opt out from background subtraction. Use with caution.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2010-02-12//	*	Fixed minor bugs//	*	Added the means for remembering the ROI when Reanalyzing the data (verified on framescans, did not verify on linescans yet)//	*	Added feature for monitoring the basal calcium levels over time////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2010-04-23//	*	Fixed ImageSave TIFF tag bug in Windows XP and Igor V6.2 beta//	*	Fixed floating panel bug in Windows XP and Igor V6.2 beta////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2010-10-11//	*	Added an 'A' or 'AutoY' button that uses the interval set by the Intgrl strt and end values to auto-zoom the y axis range.//	*	Archiving using ZIP destroys the file creation date, so I added an option "ZIP-ed data" to try to extract date and time information from//		a combination of the ScanImage TIFF header and the MultiPatch wave note date & time stamp. This option currently assumes that all//		relevant electrophysiology files start with "Cell_" -- this should probably be changed in a future version.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2010-11-10//	*	Added a blank artifact feature, to remove the light artifacts resulting from the 405-nm violet laser when doing uncaging.//	*	Fixed a couple of bugs, organized in-graph buttons better...////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2010-12-10//	*	Added a block average feature, which gives a much more realistic average depending on the timecourse of the signal//	*	Added a means of monitoring the integral of the calcium signal over time (i.e. with each iteration) to look for a downward or upward//		trend.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2011-01-04//	*	Finished adding a feature that scans across the entire ROI in a framescan, pixel by pixel, to find local supralinearities resulting from e.g.//		NMDA recptors. Be aware that running this feature is very slow.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2011-01-25//	*	Updated how the panel automatically reads the ms/line information from the ScanImage TIFF header. Now also compatible with v3.7, //		which stores the msperline info in ms instead of in s, like it did before.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2012-05-04//	*	LSMoveFile buttons "<" and ">" now returns to first entry if you press option key while clicking either of them.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2014-10-13//	*	Started adding per-spike calcium analysis for Ariane////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2014-12-11//	*	Tidied up per-spike calcium analysis for Ariane//	*	Made panel////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2016-04-02//	*	Added functionality for skipping the third channel (the Dodt contrast) when present. NB! I did not thoroughly try this new feature//		in linescan mode, only in framescan mode!////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2016-04-08//	*	Fixed bug associated with skipping third channel in linescan mode.//	*	Added t-test button for 3rd Ca signal versus the number zero, to see if boutons actually signal.//	*	Arithmetic sum trace is added if and only if smoothing is on and three conditions are analyzed////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2016-05-18//	*	Added more in-depth analysis to look for bleaching, see BleachGraphs etc////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2016-08-17//	*	Adapted code to Igor v7, e.g. ImageFileInfo is now obsolete.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2016-08-24//	*	Fixed positively nasty bug in the Linescan2 call that calculates dG/R by subtracting the BG background. This//		bug seemingly was only a problem when blanking out the laser stim artifact and only in some particular//		combinations of green and red fluorescence, and it gave rise to an apparent supralinearity in _some_ control//		experiments of Christina Chou's. Probably the weirdest bug I have ever seen.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2019-01-15//	*	Fixed Igor8-related bug that causes action procedures to be called over and over when recreating a panel//		containing the action element in question. Switched from legacy manner of calling action procedures to //		struct approach. This was in ModImSizeProc.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2020-04-09//	*	Adapted to loading stacks from new ScanImage. ScanImage tiff header is structured completely differently//		in fancy paid-for ScanImage////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2020-04-19//	*	Simple "Analyze" can now simultaneously explore several Regions of Interest. Each ROI can be stored away using//		the "Dup" button in the LineScanGraph. Each ROI is displayed in the ROIViewer and each calcium sweep is stored//		in the ROISweepsGraph. This was primarily created for analyzing Airi's astrocyte movies.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2021-02-04//	*	Added manual/auto LUT functionality for Green & Red image viewer windows when in frame scan mode////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2021-03-13//	*	Proper ROI management was added to "Analyze" button window. This is for Airi's astrocyte movies.//		ROIs can be saved, deleted, retrieved (get), stored back in another memory slot (put), a table with all//		can be viewed, all can be deleted, and all can be reanalyzed.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2021-03-20//	*	Now loads any number of channels in framescan, modern load method.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2021-04-26//	*	SI sometimes stores SI.hChannels.channelSave as "[1;2;3;4]", other times as "[1 2 3 4]". Accounted for this.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2021-04-27//	*	Created a calcium blip detector function for Airi's astrocyte movies.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2021-11-02//	*	Adapting code to Igor Pro 9, e.g., the SetVariable proc can no longer pass parameters in legacy format.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2022-01-14//	*	Fixed a bug in the "Redo" button, whereby stored ROIs were not always retrieved correctly.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2022-01-28//	*	Added feature in "Detect" button for Airi's astrocyte calcium blips so that blip times and durations are easily//		exported to Excel.//	*	Also added blip raster plot.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2022-04-07//	*	Added move ROI feature for Airi's astrocyte calcium blip analysis.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	J.Sj., 2023-01-09//	*	"Redo" etc now calculates ROI size. Note that the size is given in pixel terms, so does not know about µm//		scale.//	*	As a consequence, I had to add LS_StoreStatsForROI to LS_ReanalyzeROIs_Proc, which slows down execution of //		"Redo" a bit, but also ensures nasty bugs do not happen.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////************************************************************************************// Start Linescan//************************************************************************************Menu "Macros"	"Start LineScan",InitLineScan(0)	"Redraw LineScan Panel",MakeLineScanPanel()	"Init calcium per spike panel",ArianeInit()	SubMenu "LineScan functions"		"Make auto regions graph",MakeAutoRegionsGraph()		"Print path",Print PathName		"Toggle HD",ToggleHD()		"Measure dendritic diameters",MeasDendDiam()		"Clear TIFF Tag folder",ClearTags()		"Fix font in panel",LS_FixFontInPanel()	End	SubMenu "Set LS description" // LS description: "basal","soma","axon","apical","apical oblique"		"Basal",SetLSDescription("basal")		"Soma",SetLSDescription("soma")		"Axon",SetLSDescription("axon")		"Apical",SetLSDescription("apical")		"Apical oblique",SetLSDescription("apical oblique")	End	SubMenu "Scan area pixel-by-pixel"		"Re-analyze entire ROI",LS_ScanArea()		"Produce results images for Pos1",LS_ProduceResultsImages(2)		"Produce results images for Pos2",LS_ProduceResultsImages(3)		"Produce results images for Integral",LS_ProduceResultsImages(4)		"Rescue lost data table",RescueLostDataTable()		"Not running Scan Area",LS_RunningScanArea=0		"Kill pixel",LS_KillPixel(-1,-1)	End	SubMenu "Look for bleaching"		"Make bleach graphs",MakeBleachGraphs()		"Bleach graphs to front",BleachGraphsToFront()		"Bleach graphs to back",BleachGraphsToBack()		"Kill bleach graphs",KillBleachGraphs()	End	"Review stored ImReg data",LS_ReviewImRegSlots()	"Signal reduction",SignalReduction()//	"Reinit MsPerLinePopUpStr",Make_MsPerLinePopUpStr()	"F0 region --> Baseline",SetBaselineRegion1()	"Baseline --> F0 region",SetBaselineRegion2()	"-"EndFunction qi()	jt()	doWindow/K Table0	doWindow/K JT_EditTable	InitLineScan(1)	NVAR	CompileGraphShowSEM	NVAR	CompileGrSmBlock	NVAR	CompileGraphSmooth	NVAR	CompileGraphSmVal	NVAR	BlankInAverage		CompileGraphShowSEM=1	CompileGrSmBlock=1	CompileGraphSmooth=1	CompileGraphSmVal = 18	BlankInAverage=1		NVAR	baseWin	baseWin = 80		ccc()		// Change path		MakeCompiledGraphProc("")EndFunction LS_KillPixel(xx,yy)	Variable 	xx,yy	String	ImageTrace = StringFromList(1,WaveList("*",";","WIN:"))	if (xx==-1)		xx = pcsr(A)		yy = qcsr(A)	endif	Print "Deleting pixel (",xx,",",yy,") from ",ImageTrace	WAVE	w = $(ImageTrace)		print "It was:",w[xx][yy]	w[xx][yy] = 0EndFunction SetBaselineRegion1()	NVAR		F0_Upper = F0_Upper	NVAR		F0_Lower = F0_Lower		NVAR		baseStart	NVAR		baseWin		NVAR		dt		baseStart = F0_Upper*dt	Variable	baseEnd = F0_Lower*dt	baseWin = baseEnd-baseStart		print F0_Upper,F0_Lower,baseStart,baseWin,dtEndFunction SetBaselineRegion2()	NVAR		F0_Upper = F0_Upper	NVAR		F0_Lower = F0_Lower		NVAR		baseStart	NVAR		baseWin		NVAR		dt	F0_Upper = Floor(baseStart/dt)		F0_Lower = Floor((baseStart+baseWin)/dt)			print F0_Upper,F0_Lower,baseStart,baseWin,dtEndFunction SignalReduction()	WAVE	MaxPeakWave	WAVE	Pos1Wave	WAVE	Pos2Wave	WAVE	IntegralWave		Print "MaxPeakWave:",MaxPeakWave[1]/MaxPeakWave[0]*100,"%",MaxPeakWave[1],MaxPeakWave[0]	Print "Pos1Wave:",Pos1Wave[1]/Pos1Wave[0]*100,"%",Pos1Wave[1],Pos1Wave[0]	Print "Pos2Wave:",Pos2Wave[1]/Pos2Wave[0]*100,"%",Pos2Wave[1],Pos2Wave[0]	Print "IntegralWave:",IntegralWave[1]/IntegralWave[0]*100,"%",IntegralWave[1],IntegralWave[0]End//////////////////////////////////////////////////////////////////////////////////////////////////////// Per-spike calcium analysis for ArianeFunction CaPerSpike(slotNo)//,absFlag)	Variable	slotNo//	Variable	absFlag		WAVE/T	SuffixWave	if ((slotNo<0) %| (slotNo>numpnts(SuffixWave)-1))		print "slotNo out of range!"		Abort "slotNo out of range!"	endif	print "=== Analyzing \"meanWave"+SuffixWave[slotNo]+"\" ==="		String		SuffixStr = SuffixWave[slotNo]	Variable	freq = str2num(SuffixStr[1,strLen(SuffixStr)-1])		WAVE		w = $("meanWave"+SuffixWave[slotNo])	Variable	nSpikes = floor((rightX(w)-0.2)*freq-1)	if (nSpikes>100)		nSpikes = 100	endif		print "\tFrequency:",freq	print "\tNumber of spikes:",nSpikes	getCaPerSpike(slotNo,200,freq,nSpikes,-15,5,10,10)//,absFlag)EndFunction Ariane_runProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	NVAR		Ariane_slotNo	NVAR		Ariane_xStart	NVAR		Ariane_freq	NVAR		Ariane_nSpikes	NVAR		Ariane_b1start	NVAR		Ariane_b2start	NVAR		Ariane_b1win	NVAR		Ariane_b2win//	NVAR		Ariane_absFlag	//	ControlInfo/W=CaPerSpikePanel absFlagCheck//	Ariane_absFlag = V_value		switch( ba.eventCode )		case 2: // mouse up			getCaPerSpike(Ariane_slotNo,Ariane_xStart,Ariane_freq,Ariane_nSpikes,Ariane_b1start,Ariane_b2start,Ariane_b1win,Ariane_b2win)//,Ariane_absFlag)			break	endswitch	return 0EndFunction Ariane_graphsProc(ctrlName) : ButtonControl	String ctrlName		Variable	grButtonNo = str2num(ctrlName[1])		ArianeDefineGraphList()	SVAR		Ariane_grList		switch(grButtonNo)		case 1:			JT_ArrangeGraphs3(Ariane_grList)			break		case 2:			JT_ArrangeGraphs6(Ariane_grList)			break		case 3:			JT_ArrangeGraphs5(Ariane_grList)			break		case 4:			JT_ArrangeGraphs2(Ariane_grList,4,4)			break	endswitchEndFunction Ariane_redrawProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			print "Redrawing panel..."			ArianePanel()			break	endswitch	return 0EndFunction ArianeDefineGraphList()	String/G		Ariane_grList = ""	Ariane_grList += ";"	Ariane_grList += "ArianeShowWaveGr;"	Ariane_grList += "CaPerSpikeGraph1;"	Ariane_grList += "cumulCaGraph1;"	Ariane_grList += "cumulCaGraph2;"	Ariane_grList += "CaPerSpikeGraph2;"	Ariane_grList += "First_vs_last_bit_graph;"	Ariane_grList += "CaTable;"	Ariane_grList += "ArianeCaVsWidth1;"	Ariane_grList += "ArianeCaVsWidth2;"	Ariane_grList += "ArianeCaVsWidth3;"	Ariane_grList += "ArianeCaVsWidth4;"	EndFunction ArianeInit()	Variable/G		Ariane_slotNo = 0	Variable/G		Ariane_xStart = 200	Variable/G		Ariane_freq = 50	Variable/G		Ariane_nSpikes = 100	Variable/G		Ariane_b1start = -15	Variable/G		Ariane_b2start = 3	Variable/G		Ariane_b1win = 12	Variable/G		Ariane_b2win = 5	Variable/G		Ariane_fitStart = 0	Variable/G		Ariane_fitEnd = 9//	Variable/G		Ariane_absFlag = 0	ArianeDefineGraphList()		ArianePanel()EndFunction ArianePanel()//	NVAR		Ariane_absFlag	Variable		ScSc = PanelResolution("")/ScreenResolution	Variable		Xpos = 2	Variable		Ypos = 64	Variable		Width = 320	Variable		Height = 26*2		// If panel already exists, keep it in the same place, please	DoWindow CaPerSpikePanel	if (V_flag)		GetWindow CaPerSpikePanel, wsize		xPos = V_left/ScSc		yPos = V_top/ScSc	endif	Variable		xMargin = 14	Variable		bGap = 5	Variable		x = 4	Variable		y = 12		Variable		xSkip = 32	Variable		ySkip = 21		Variable		bHeight = 20		Variable		fontSize=12	Variable		cFade = 0.1	DoWindow/K CaPerSpikePanel	NewPanel/K=2/W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+4*ScSc,yPos*ScSc+Height*ScSc) as "Calcium per spike"	DoWindow/C CaPerSpikePanel	ModifyPanel frameStyle=2, frameInset=4	ModifyPanel/W=CaPerSpikePanel fixedSize=1	xSkip = floor((Width-xMargin*2)/2)	x = xMargin	SetVariable slotNoSetVar,pos={x,y+3},size={xSkip-bGap,bHeight},title="slot #",value=Ariane_slotNo,limits={0,Inf,1},fsize=fontSize,font="Arial"	x += xSkip	SetVariable nSpikesSetVar,pos={x,y+3},size={xSkip-bGap,bHeight},title="# of spikes",value=Ariane_nSpikes,limits={0,Inf,1},fsize=fontSize,font="Arial"	x += xSkip	y += ySkip	x = xMargin	SetVariable xStartSetVar,pos={x,y+3},size={xSkip-bGap,bHeight},title="train start (ms)",value=Ariane_xStart,limits={0,Inf,10},fsize=fontSize,font="Arial"	x += xSkip	SetVariable freqSetVar,pos={x,y+3},size={xSkip-bGap,bHeight},title="frequency (Hz)",value=Ariane_freq,limits={0,Inf,10},fsize=fontSize,font="Arial"	x += xSkip	y += ySkip	x = xMargin	SetVariable b1StartSetVar,pos={x,y+3},size={xSkip-bGap,bHeight},title="b1 start (ms)",value=Ariane_b1start,limits={-Inf,Inf,5},fsize=fontSize,font="Arial",fColor= (65535,65535*cFade,65535*cFade)	x += xSkip	SetVariable b1winSetVar,pos={x,y+3},size={xSkip-bGap,bHeight},title="b1 window (ms)",value=Ariane_b1win,limits={1,Inf,5},fsize=fontSize,font="Arial",fColor= (65535,65535*cFade,65535*cFade)	x += xSkip	y += ySkip	x = xMargin	SetVariable b2StartSetVar,pos={x,y+3},size={xSkip-bGap,bHeight},title="b2 start (ms)",value=Ariane_b2start,limits={-Inf,Inf,5},fsize=fontSize,font="Arial",fColor= (65535*cFade,65535*cFade,65535)	x += xSkip	SetVariable b2winSetVar,pos={x,y+3},size={xSkip-bGap,bHeight},title="b2 window (ms)",value=Ariane_b2win,limits={1,Inf,5},fsize=fontSize,font="Arial",fColor= (65535*cFade,65535*cFade,65535)	x += xSkip	y += ySkip	x = xMargin	SetVariable fitStartSetVar,pos={x,y+3},size={xSkip-bGap,bHeight},title="fit start",value=Ariane_fitStart,limits={0,Inf,1},fsize=fontSize,font="Arial"	x += xSkip	SetVariable fitEndSetVar,pos={x,y+3},size={xSkip-bGap,bHeight},title="fit end",value=Ariane_fitEnd,limits={0,Inf,1},fsize=fontSize,font="Arial"	x += xSkip	y += ySkip	xSkip = floor((Width-xMargin*2)/2)	x = xMargin	Button runButton,pos={x,y},size={xSkip-bGap,bHeight},proc=Ariane_runProc,title="Run",fsize=fontSize,font="Arial"		x += xSkip	Button redrawButton,pos={x,y},size={xSkip-bGap,bHeight},proc=Ariane_redrawProc,title="Redraw panel",fsize=fontSize,font="Arial"		x += xSkip	y += ySkip	xSkip = floor((Width-xMargin*2)/2)	x = xMargin	Button g1button,pos={x,y},size={xSkip-bGap,bHeight},proc=Ariane_graphsProc,title="Graphs to front",fsize=fontSize,font="Arial"		x += xSkip	Button g2button,pos={x,y},size={xSkip-bGap,bHeight},proc=Ariane_graphsProc,title="Graphs to back",fsize=fontSize,font="Arial"		x += xSkip	y += ySkip	xSkip = floor((Width-xMargin*2)/2)	x = xMargin	Button g3button,pos={x,y},size={xSkip-bGap,bHeight},proc=Ariane_graphsProc,title="Kill graphs",fsize=fontSize,font="Arial"		x += xSkip	Button g4button,pos={x,y},size={xSkip-bGap,bHeight},proc=Ariane_graphsProc,title="Redraw graphs",fsize=fontSize,font="Arial"		x += xSkip	y += ySkip	y += 8	MoveWindow/W=CaPerSpikePanel xPos*ScSc,yPos*ScSc,xPos*ScSc+(Width-8)*ScSc,yPos*ScSc+y*ScSc		// Adjust panel size based on number of controls added to it...EndFunction getCaPerSpike(slotNo,xStart,freq,nSpikes,b1start,b2start,b1win,b2win)//,absFlag)	Variable	slotNo	Variable	xStart		// ms	Variable	freq		// Hz	Variable	nSpikes	Variable	b1start		// ms	Variable	b2start		// ms	Variable	b1win		// ms	Variable	b2win		// ms//	Variable	absFlag		// Boolean: Absolute value or difference?		WAVE/T	SuffixWave		if ((slotNo<0) %| (slotNo>numpnts(SuffixWave)-1))		print "slotNo out of range!"		Abort "slotNo out of range!"	endif		WAVE		w = $("meanWave"+SuffixWave[slotNo])		Variable	b1mean,b2mean	Make/O/N=(nSpikes) CaPerSpikeWave,summedCaPerSpikeWave	SetScale/P x 1,1,"", CaPerSpikeWave,summedCaPerSpikeWave	Make/O/N=(nSpikes) CaLevelWave,diffCaLevelWave	SetScale/P x 1,1,"", CaLevelWave,diffCaLevelWave		doWindow/K ArianeShowWaveGr	Display $("meanWave"+SuffixWave[slotNo]) as "The wave in slot #"+num2str(slotNo)	doWindow/C ArianeShowWaveGr	SetDrawLayer UserBack	ModifyGraph RGB=(0,0,0)	SetAxis/A=2 left		Variable	cFade = 0.5	Variable	i	i = 0	do		b1mean = Mean(w,xStart*1e-3+i*1/freq+b1start*1e-3,xStart*1e-3+i*1/freq+(b1start+b1win)*1e-3)		b2mean = Mean(w,xStart*1e-3+i*1/freq+b2start*1e-3,xStart*1e-3+i*1/freq+(b2start+b2win)*1e-3)		CaPerSpikeWave[i] = b2mean-b1mean		CaLevelWave[i] = b2mean		// Baseline		SetDrawEnv xcoord= bottom,linefgc= (65535,65535*cFade,65535*cFade)		SetDrawEnv fillbgc= (65535,65535*cFade,65535*cFade),fillfgc= (65535,65535*cFade,65535*cFade)		DrawRect xStart*1e-3+i*1/freq+b1start*1e-3,0,xStart*1e-3+i*1/freq+(b1start+b1win)*1e-3,1		// Response		SetDrawEnv xcoord= bottom,linefgc= (65535*cFade,65535*cFade,65535)		SetDrawEnv fillbgc= (65535*cFade,65535*cFade,65535),fillfgc= (65535*cFade,65535*cFade,65535)		DrawRect xStart*1e-3+i*1/freq+b2start*1e-3,0,xStart*1e-3+i*1/freq+(b2start+b2win)*1e-3,1		i += 1	while(i<nSpikes)	Integrate CaPerSpikeWave /D=summedCaPerSpikeWave	Differentiate CaLevelWave /D=diffCaLevelWave		doWindow/K CaTable	doWindow/K cumulCaGraph	doWindow/K CaPerSpikeGraph1	Display CaPerSpikeWave as "Calcium per spike"	doWindow/C CaPerSpikeGraph1	ModifyGraph mode=3,marker=8,opaque=1,rgb=(1,16019,65535)	Label left,"dG/R"	Label bottom,"spike number"	SetAxis/A/E=1 bottom	Duplicate/O CaPerSpikeWave,fitCaPerSpikeGraph1	CurveFit/Q/M=2/W=0 exp_XOffset, CaPerSpikeWave/D=fitCaPerSpikeGraph1	AppendToGraph fitCaPerSpikeGraph1	WAVE	W_coef	WAVE	W_fitConstants	SetDrawLayer UserBack	SetDrawEnv ycoord= left,dash= 11	DrawLine 0,0,1,0	SetDrawLayer UserFront	print "--- Calcium/spike ---"	print "For curvefit y = K0+K1*exp(-(x-x0)/K2), the fitted parameters are:"	print "\tK0="+num2str(W_Coef[0])	print "\tK1="+num2str(W_Coef[1])	print "\tK2="+num2str(W_Coef[2])	print "\twhere x0="+num2str(W_fitConstants[0])+" is a constant."		doWindow/K CaPerSpikeGraph2	Display diffCaLevelWave as "Differentiated Ca level"	doWindow/C CaPerSpikeGraph2	ModifyGraph mode=3,marker=8,opaque=1,rgb=(1,16019,65535)	Label left,"dG/R"	Label bottom,"spike number"	SetAxis/A/E=1 bottom	Duplicate/O diffCaLevelWave,fitCaPerSpikeGraph2	CurveFit/Q/M=2/W=0 exp_XOffset, diffCaLevelWave/D=fitCaPerSpikeGraph2	AppendToGraph fitCaPerSpikeGraph2	WAVE	W_coef	WAVE	W_fitConstants	SetDrawLayer UserBack	SetDrawEnv ycoord= left,dash= 11	DrawLine 0,0,1,0	SetDrawLayer UserFront	print "--- Differentiated calcium level ---"	print "For curvefit y = K0+K1*exp(-(x-x0)/K2), the fitted parameters are:"	print "\tK0="+num2str(W_Coef[0])	print "\tK1="+num2str(W_Coef[1])	print "\tK2="+num2str(W_Coef[2])	print "\twhere x0="+num2str(W_fitConstants[0])+" is a constant."		doWindow/K cumulCaGraph1	Display summedCaPerSpikeWave as "Summed Ca/spike"	doWindow/C cumulCaGraph1	ModifyGraph mode=3,marker=8,opaque=1,rgb=(1,16019,65535)	Label left,"dG/R"	Label bottom,"spike number"	SetAxis/A/E=1 bottom	CurveFit/Q/M=2/W=0 exp_XOffset, summedCaPerSpikeWave/D	WAVE	W_coef	WAVE	W_fitConstants	SetDrawLayer UserBack	SetDrawEnv ycoord= left,dash= 11	DrawLine 0,0,1,0	SetDrawLayer UserFront	print "--- Summed calcium/spike ---"	print "For curvefit y = K0+K1*exp(-(x-x0)/K2), the fitted parameters are:"	print "\tK0="+num2str(W_Coef[0])	print "\tK1="+num2str(W_Coef[1])	print "\tK2="+num2str(W_Coef[2])	print "\twhere x0="+num2str(W_fitConstants[0])+" is a constant."		doWindow/K cumulCaGraph2	Display CaLevelWave as "Calcium level"	doWindow/C cumulCaGraph2	ModifyGraph mode=3,marker=8,opaque=1,rgb=(1,16019,65535)	Label left,"dG/R"	Label bottom,"spike number"	SetAxis/A/E=1 bottom	CurveFit/Q/M=2/W=0 exp_XOffset, CaLevelWave/D	WAVE	W_coef	WAVE	W_fitConstants	SetDrawLayer UserBack	SetDrawEnv ycoord= left,dash= 11	DrawLine 0,0,1,0	SetDrawLayer UserFront	print "--- Calcium level ---"	print "For curvefit y = K0+K1*exp(-(x-x0)/K2), the fitted parameters are:"	print "\tK0="+num2str(W_Coef[0])	print "\tK1="+num2str(W_Coef[1])	print "\tK2="+num2str(W_Coef[2])	print "\twhere x0="+num2str(W_fitConstants[0])+" is a constant."		Variable nPerBit = 12	Duplicate/O/R=[0,nPerBit-1] CaPerSpikeWave,firstBit	Duplicate/O/R=[numpnts(CaPerSpikeWave)-nPerBit,numpnts(CaPerSpikeWave)-1] CaPerSpikeWave,lastBit	Variable pVal = JT_BarGraphFromDataWithName("firstBit","lastBit","First vs last bit")	DoWindow/T First_vs_last_bit_graph,"First "+num2str(nPerBit)+" vs last "+num2str(nPerBit)	QuickStars(JT_p2sigStr(pVal))	WAVE/T	wT = 'First vs last bit_xLabel'	wT[0] = "first "+num2str(nPerBit)	wT[1] = "last "+num2str(nPerBit)		doWindow/K CaTable	Edit CaPerSpikeWave,summedCaPerSpikeWave,CaLevelWave,diffCaLevelWave as "Calcium table"	ModifyTable width = 100	ModifyTable width(Point) = 40	doWindow/C CaTable		doWindow/K ArianeCaVsWidth1	doWindow/K ArianeCaVsWidth2	doWindow/K ArianeCaVsWidth3	doWindow/K ArianeCaVsWidth4	if (Exists("widthWave"))		Duplicate/O/R=[0,9] widthwave,widthwaveSUB		// Calcium per spike		qp("CaPerSpikeWave","widthwave")		label bottom,"width (\\U)"		doWindow/C ArianeCaVsWidth1		doWindow/T ArianeCaVsWidth1,"Calcium vs width"		Duplicate/O/R=[0,9] CaPerSpikeWave,CaPerSpikeWaveSUB		qp("CaPerSpikeWaveSUB","widthwaveSUB")		label bottom,"width (\\U)"		doWindow/C ArianeCaVsWidth2		doWindow/T ArianeCaVsWidth2,"Calcium vs width, zoomed"		// Differentiated calcium level		qp("diffCaLevelWave","widthwave")		label bottom,"width (\\U)"		doWindow/C ArianeCaVsWidth3		doWindow/T ArianeCaVsWidth3,"Diff Ca level vs width"		Duplicate/O/R=[0,9] diffCaLevelWave,diffCaLevelWaveSUB		qp("diffCaLevelWaveSUB","widthwaveSUB")		label bottom,"width (\\U)"		doWindow/C ArianeCaVsWidth4		doWindow/T ArianeCaVsWidth4,"Diff Ca level vs width, zoomed"	else		Display as "Calcium vs width"		Legend/F=0/A=LT "These graphs are\rempty until you run\rJT_getSpikes(theLevel,theWave)\rto get the wave called\r\"widthwave\""		doWindow/C ArianeCaVsWidth1		Display as "Calcium vs width, zoomed"		doWindow/C ArianeCaVsWidth2		Display as "Diff Ca level vs width"		doWindow/C ArianeCaVsWidth3		Display as "Diff Ca level vs width, zoomed"		doWindow/C ArianeCaVsWidth4	endif		SVAR	Ariane_grList	JT_ArrangeGraphs2(Ariane_grList,4,4)	End//////////////////////////////////////////////////////////////////////////////////////////////////////// Set automatically the linescan description entryFunction SetLSDescription(descrStr)	String		descrStr		WAVE/T	ParameterDescrWave	WAVE/T	ParameterTextWave		ParameterTextWave[15] = descrStr	ParameterDescrWave[15] = "LS description"	End//////////////////////////////////////////////////////////////////////////////////////////////////////// Measure automatically the dendritic diameters based on RED and on GREEN fluorescence channelsFunction CheckZoom()	SVAR		RAT_Str = RAT_Str		Variable	zoomFactor  = str2num(StringByKey("state.acq.zoomFactor",RAT_Str,"=","\r"))	Variable	zoomOnes = str2num(StringByKey("state.acq.zoomones",RAT_Str,"=","\r"))	Variable	zoomTens = str2num(StringByKey("state.acq.zoomtens",RAT_Str,"=","\r"))	Variable	zoomHundreds = str2num(StringByKey("state.acq.zoomhundreds",RAT_Str,"=","\r"))	Variable	zoomFactor2 = zoomOnes+zoomTens*10+zoomHundreds*100			// Account for ScanImage v3 bug where zoomFactor is not correctly set		print zoomFactor,zoomFactor2	if (zoomFactor!=zoomFactor2)		Beep		print "Not the same!!!"	else		print "Same"	endifEndFunction MeasDendDiam()	NVAR		DiamRed	NVAR		DiamGreen		NVAR		LeftBound	NVAR		RightBound	WAVE/T	ParameterDescrWave = ParameterDescrWave	WAVE		ParameterNumWave = ParameterNumWave	WAVE/T	ParameterTextWave = ParameterTextWave	SVAR		RAT_Str = RAT_Str	if (StringMatch(RAT_Str,"<Empty>"))		Print "ScanImage Notes header not found. Is no image loaded yet? Make sure you are using Igor PRO v5.03 or higher."		Abort "ScanImage Notes header not found. Is no image loaded yet? Make sure you are using Igor PRO v5.03 or higher."	endif	Variable	ImXScale = 187.316		// Reference point: Calculated size of a scan line at scanAmplitude = 1.5 and zoomFactor = 1	Variable	scanAmplitudeX = str2num(StringByKey("state.acq.scanAmplitudeX",RAT_Str,"=","\r"))	Variable	zoomFactor // = str2num(StringByKey("state.acq.zoomFactor",RAT_Str,"=","\r"))	Variable	zoomOnes = str2num(StringByKey("state.acq.zoomones",RAT_Str,"=","\r"))	Variable	zoomTens = str2num(StringByKey("state.acq.zoomtens",RAT_Str,"=","\r"))	Variable	zoomHundreds = str2num(StringByKey("state.acq.zoomhundreds",RAT_Str,"=","\r"))	zoomFactor = zoomOnes+zoomTens*10+zoomHundreds*100			// Account for ScanImage v3 bug where zoomFactor is not correctly set	print "ZoomFactor:",zoomFactor	Variable	pixelsPerLine = str2num(StringByKey("state.acq.pixelsPerLine",RAT_Str,"=","\r"))	Dowindow ImageViewer	if (V_flag==0)		Print "Cannot find image viewer window... Need to reload image?"		Abort "Cannot find image viewer window... Need to reload image?"	endif	// Do the green channel first	ViewChanSet("",-1,"Green")		// This also sets the CurrentImage to the current channel	FitTheGaussian()					// Find the best fit Gaussian	DiamGreen = Round(abs(RightBound-LeftBound)/pixelsPerLine*abs(scanAmplitudeX/1.5*ImXScale/zoomFactor)*100)/100	// Calculate dendritic diameter//	DoWindow/K AutoRegionsGraph	DoMakeAutoRegionsGraph(1)		// Do the red channel	ViewChanSet("",-1,"Red")			// This also sets the CurrentImage to the current channel	FitTheGaussian()					// Find the best fit Gaussian	DiamRed = Round(abs(RightBound-LeftBound)/pixelsPerLine*abs(scanAmplitudeX/1.5*ImXScale/zoomFactor)*100)/100	// Calculate dendritic diameter//	DoWindow/K AutoRegionsGraph	DoMakeAutoRegionsGraph(2)		// Output results	Print "--- Diameters ---"	Print "From green channel:\t",DiamGreen,"µm"	Print "From red channel:   \t",DiamRed,"µm"		// Refresh panel, so that image and pop-up menus correspond	MakeLineScanPanel()	ProduceImage()	DoWindow/F AutoRegionsGraph_green	DoWindow/F AutoRegionsGraph_red	End//////////////////////////////////////////////////////////////////////////////////////////////////////// Fit a gaussian to the current channelFunction FitTheGaussian()	// Communicate resulting values with these two variables	NVAR		LeftBound	NVAR		RightBound		// User-positioned lines, use these to restrict search when shift key is pressed	NVAR		LS_Left	NVAR		LS_Right	NVAR		ImageWidth = ImageWidth	NVAR		ImageHeight = ImageHeight	WAVE		CurrentImage = CurrentImage	Variable	nSDs = 1							// Number of standard deviations from center	// Check if shift key is pressed		Variable	Keys = GetKeyState(0)	Variable	Focus = 0	Variable	PercentExtend = 100	Variable	LeftFocus = LS_Left-abs(LS_Right-LS_Left)*PercentExtend/100	Variable	RightFocus = LS_Right+abs(LS_Right-LS_Left)*PercentExtend/100	if (Keys & 2^2)		Print "\tYou pressed the Shift key -- Focussing auto-regions search around LS_Left and LS_Right."		Focus = 1	else		Focus = 0	endif	Make/O/N=(ImageWidth) OneLine	Duplicate/O CurrentImage,testImage	MatrixFilter median testImage	ImageStats/Q/G={LS_Left,LS_Right,0,ImageHeight-1} testImage	print "\tFound max at (",V_maxColLoc,",",V_maxRowLoc,")"	OneLine = CurrentImage[p][V_maxRowLoc][1]	if (V_maxRowLoc-1>-1)		OneLine += CurrentImage[p][V_maxRowLoc-1][1]	endif	if (V_maxRowLoc-2>-1)		OneLine += CurrentImage[p][V_maxRowLoc-2][1]	endif	if (V_maxRowLoc-3>-1)		OneLine += CurrentImage[p][V_maxRowLoc-3][1]	endif	if (V_maxRowLoc-4>-1)		OneLine += CurrentImage[p][V_maxRowLoc-4][1]	endif	if (V_maxRowLoc-5>-1)		OneLine += CurrentImage[p][V_maxRowLoc-5][1]	endif	Smooth/B 3,OneLine	print "\tFitting Gaussian at this row"	if (Focus)		CurveFit/N/Q gauss  OneLine(LeftFocus,RightFocus) /D	else		CurveFit/N/Q gauss  OneLine /D	endif	WAVE		W_coef = W_coef	print "\tExtracting values from fit -- using ",nSDs," standard devations from center of fit"	print "\t\tµ: ",W_coef[2]	print "\t\tSD:",W_coef[3]	LeftBound = Round(W_coef[2]-W_coef[3]*nSDs)	RightBound = Round(W_coef[2]+W_coef[3]*nSDs)		if (LeftBound>RightBound)		Variable	tempBound = LeftBound		LeftBound = RightBound		RightBound = tempBound	endif	// If AutoRegionsGraph is exists, then update it	DoWindow AutoRegionsGraph	if (V_flag)		MakeAutoRegionsGraph()	endif	End//////////////////////////////////////////////////////////////////////////////////////////////////////// Dummy functions that I should remove once I am done with themFunction AllSupra2()	SupraSum2()	SupraLinTrace()	DoWindow wSupraLinTraceGr	if (!(V_flag))		Display wSupraLinTrace		DoWindow/C wSupraLinTraceGr	endifEndFunction SupraSum()	WAVE	Pos2Wave	print Pos2Wave[2]/(Pos2Wave[1]+Pos2Wave[0])*100EndFunction SupraSum2()	WAVE	Pos2Wave	print Pos2Wave[0]/(Pos2Wave[1]+Pos2Wave[2])*100EndFunction diff()	WAVE	Pos1Wave	WAVE	Pos2Wave	WAVE	IntegralWave	print "Pos 1:",Pos1Wave[1]/Pos1Wave[0]*100,"%"	print "Pos 2:",Pos2Wave[1]/Pos2Wave[0]*100,"%"	print "Integral:",IntegralWave[1]/IntegralWave[0]*100,"%"EndFunction SupraLinTrace()	WAVE meanWave_Both,meanWave_APs,meanWave_Depol		Duplicate/O meanWave_Both,wBoth	Duplicate/O meanWave_APs,wAPs	Duplicate/O meanWave_Depol,wDepol		Variable	SmoothFactor = 20		Smooth/B SmoothFactor,wBoth,wAPs,wDepol		Duplicate/O meanWave_Depol,wSupraLinTrace		wSupraLinTrace = wBoth/(wAPs+wDepol)*100//	wSupraLinTrace = meanWave_Both/(meanWave_APs+meanWave_Depol)*100	//	Smooth/B SmoothFactor,wSupraLinTraceEndWindow SupraGr() : Graph	PauseUpdate; Silent 1		// building window...	Display /W=(524,189,1085,640) meanWave_Both,meanWave_APs	ModifyGraph lSize=2	ModifyGraph rgb(meanWave_Both)=(0,0,0)//	SetAxis bottom 0.160033598514623,0.338042504675684	SetAxis bottom 0.060,0.3	ShowInfoEndMacroFunction FixTable()	WAVE/T	SuffixWave,LegendWave,RecallWaveListWave	WAVE		MaxPeakWave,Pos1Wave,Pos2Wave,SuffixStartWave,nFilesWave,IncrementWave,IntegralWave		InsertPoints 3,1, SuffixWave,LegendWave,MaxPeakWave,Pos1Wave,Pos2Wave	InsertPoints 3,1, SuffixStartWave,nFilesWave,IncrementWave,IntegralWave	InsertPoints 3,1, RecallWaveListWave		SuffixWave[3]=SuffixWave[0]	LegendWave[3]=LegendWave[0]	RecallWaveListWave[3]=RecallWaveListWave[0]	MaxPeakWave[3]=MaxPeakWave[0]	Pos1Wave[3]=Pos1Wave[0]	Pos2Wave[3]=Pos2Wave[0]	SuffixStartWave[3]=SuffixStartWave[0]	nFilesWave[3]=nFilesWave[0]	IncrementWave[3]=IncrementWave[0]	IntegralWave[3]=IntegralWave[0]	DeletePoints 0,1, SuffixWave,LegendWave,MaxPeakWave,Pos1Wave,Pos2Wave	DeletePoints 0,1, SuffixStartWave,nFilesWave,IncrementWave,IntegralWave	DeletePoints 0,1, RecallWaveListWaveEndFunction RestoreTable()	WAVE/T	SuffixWave,LegendWave,RecallWaveListWave	WAVE		MaxPeakWave,Pos1Wave,Pos2Wave,SuffixStartWave,nFilesWave,IncrementWave,IntegralWave		InsertPoints 0,1, SuffixWave,LegendWave,MaxPeakWave,Pos1Wave,Pos2Wave	InsertPoints 0,1, SuffixStartWave,nFilesWave,IncrementWave,IntegralWave	InsertPoints 0,1, RecallWaveListWave		SuffixWave[0]=SuffixWave[3]	LegendWave[0]=LegendWave[3]	RecallWaveListWave[0]=RecallWaveListWave[3]	MaxPeakWave[0]=MaxPeakWave[3]	Pos1Wave[0]=Pos1Wave[3]	Pos2Wave[0]=Pos2Wave[3]	SuffixStartWave[0]=SuffixStartWave[3]	nFilesWave[0]=nFilesWave[3]	IncrementWave[0]=IncrementWave[3]	IntegralWave[0]=IntegralWave[3]	DeletePoints 3,1, SuffixWave,LegendWave,MaxPeakWave,Pos1Wave,Pos2Wave	DeletePoints 3,1, SuffixStartWave,nFilesWave,IncrementWave,IntegralWave	DeletePoints 3,1, RecallWaveListWaveEnd//////////////////////////////////////////////////////////////////////////////////////////////////////// Toggle the path between Aluminium HD and the portable HD Jesper_HD80Function ToggleHD()	SVAR		PathName	String		dummy = PathName	Variable	lastChar = strlen(PathName)-1		if (StringMatch("Aluminium HD:Users:jesper:",PathName[0,25]))		PathName = "Jesper_HD80:"+dummy[26,lastChar]	else		if (StringMatch("Jesper_HD80:",PathName[0,11]))			PathName = "Aluminium HD:Users:jesper:"+PathName[12,strlen(PathName)-1]		endif	endif		Print "--- Changing HD ---"	Print "Path was:",dummy	Print "Path is:",PathName		SetShowPathName()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Change path to Christina Chou's raw dataFunction ccc()	SVAR		PathName	String		dummy = PathName	Variable	lastChar = strlen(PathName)-1	String		findStr = "Macintosh HD:Users:christinafish:Documents:SJOSTROM LAB:Experiments:"	String		replaceStr = "My Book:Users:Christina:"		if (StrSearch(PathName,findStr,0)==0)		PathName = replaceStr+dummy[strLen(findStr),lastChar]		Print "--- Changing path ---"		Print "Path was:",dummy		Print "Path is:",PathName		SetShowPathName()	else		Print "--- Not changing path ---"	endifEnd//////////////////////////////////////////////////////////////////////////////////////////////////////// Set up variables etcFunction InitLineScan(doForce)	Variable	doForce		Variable	wasRestarted = 0	if (!(doForce))		DoWindow LineScanAnalysis		if (V_flag)			DoAlert	1,"Are you sure you want to restart LineScan?"			if (V_flag!=1)				Print "Not restarting LineScan..."				Abort			else				Print "Restarting LineScan...",Date(),Time()			endif			wasRestarted = 1		endif	endif	String/G	LS_setupStr = "\t"	DoWindow /K ImageViewer	DoWindow /K ImageViewer2	DoWindow /K ImageViewer3	DoWindow /K ImageViewer4	DoWindow /K ImageViewer5	Print "Setting up variables for LineScanAnalysis at "+Time()+", "+Date()	Variable	i	Variable/G	ColCounter = 0//	Make_MsPerLinePopUpStr()		LS_GlobalVariable("ConditionStr",0,"",1)	// Data management	Variable/G	nParams = 20//	LS_GlobalVariable("nParams",20,"",0)	LS_GlobalVariable("ParamsFilename",0,"{none selected}",1)	if (!exists("ParameterNumWave"))		Make/O/N=(nParams)		ParameterNumWave		ParameterNumWave = NaN		Make/T/O/N=(nParams)		ParameterTextWave		ParameterTextWave = ""		Make/T/O/N=(nParams)	ParameterDescrWave		ParameterDescrWave[0] = "Animal age"		ParameterNumWave[0] = 18		ParameterDescrWave[1] = "Brain region"		ParameterTextWave[1] = "Somatosensory cortex"		ParameterDescrWave[2] = "Cell type"		ParameterTextWave[2] = "Pyramidal L5"		ParameterDescrWave[3] = "Date"		Variable/G	DeltaDate = -1		SetAutoDateProc("")		ParameterDescrWave[4] = "Position"		ParameterNumWave[4] = 684		ParameterTextWave[4] = "µm"		ParameterDescrWave[5] = "Path"		ParameterTextWave[5] = "<empty>"		ParameterDescrWave[6] = "File name"		ParameterTextWave[6] = "<empty>"		ParameterDescrWave[7] = "Dendrite length"		ParameterNumWave[7] = 1000		ParameterTextWave[7] = "µm"		ParameterDescrWave[8] = "Dendritic recording"		ParameterNumWave[8] = 260		ParameterTextWave[8] = "µm"		ParameterDescrWave[9] = "Branch point"		ParameterNumWave[9] = 500		ParameterTextWave[9] = "µm"		ParameterDescrWave[10] = "Dendritic diameter Green"		ParameterNumWave[10] = -1		ParameterTextWave[10] = "µm"		ParameterDescrWave[11] = "Dendritic diameter Red"		ParameterNumWave[11] = -1		ParameterTextWave[11] = "µm"		ParameterDescrWave[12] = "scanAmplitudeX"		ParameterNumWave[12] = NaN		ParameterTextWave[12] = ""		ParameterDescrWave[13] = "zoomFactor"		ParameterNumWave[13] = NaN		ParameterTextWave[13] = ""		ParameterDescrWave[14] = "pixelsPerLine"		ParameterNumWave[14] = NaN		ParameterTextWave[14] = ""		ParameterDescrWave[15] = "LS description"		ParameterNumWave[15] = NaN		ParameterTextWave[15] = "basal"	else		// If waves already exist, then make sure to update their sizes		// This should not erase previously entered values		Make/O/N=(nParams)		ParameterNumWave		Make/T/O/N=(nParams)	ParameterTextWave		Make/T/O/N=(nParams)	ParameterDescrWave	endif		// Handle the suffices to ignore data	LS_GlobalVariable("NPointsToIgnore",1,"",0)						// Number of points to ignore	LS_GlobalVariable("IvalStart",-1,"",0)							// Start of an interval of points to ignore	LS_GlobalVariable("IvalEnd",-1,"",0)								// End of an interval of points to ignore	Variable	MaxNPointsToIgnore = 30								// Not a global! Decides the maximum number of points that may be skipped	i = 0	do																// Reset the data points to ignore to point number zero (Used in the panel only)		LS_GlobalVariable("DataPoint_"+num2str(i+1),0,"",0)		i += 1	while (i < MaxNPointsToIgnore)	if (!(Exists("SuffToIgnoreWave")==1))		Make/O/N=(MaxNPointsToIgnore) SuffToIgnoreWave		SuffToIgnoreWave = -1										// This wave is what is used during actual analysis -- contains the same data as the above variables	endif	DoWindow/K SuffToIgnorePanel									// If the panel is restarted, close the points-to-ignore panel		// Extracted data variables	LS_GlobalVariable("RealignBaselineCheckVar",0,"",0)	// Realign compiled traces on baseline region?//	LS_GlobalVariable("ReAnNewStartCheckVar",0,"",0)	LS_GlobalVariable("ReAnalyzeStart",60,"",0)	// Suffix start when reanalyzing a new set of linescans starting at a different suffix	LS_GlobalVariable("ReAnalyzeNFiles",6,"",0)	// Number of waves when reanalyzing	LS_GlobalVariable("nCategories",0,"",0)		// Number of categories	LS_GlobalVariable("mWinWidth",5,"",0)		// Window width for measuring peak etc [ms]	LS_GlobalVariable("fixPos1",115,"",0)		// Fixed position #1 [ms]	LS_GlobalVariable("fixPos2",195,"",0)		// Fixed position #2 [ms]	LS_GlobalVariable("baseStart",0,"",0)		// Start of baseline [ms]	LS_GlobalVariable("baseWin",100,"",0)		// Width of baseline [ms]	LS_GlobalVariable("IntegralStart",100,"",0)	// Start of integral [ms]	LS_GlobalVariable("IntegralEnd",200,"",0)	// End of integral [ms]	LS_GlobalVariable("baseVal",0,"",0)			// Value of baseline	LS_GlobalVariable("MaxLoc",0,"",0)			// Position of max [ms]	LS_GlobalVariable("MaxVal",0,"",0)			// Value at max	LS_GlobalVariable("Pos1Val",0,"",0)			// Value at Pos 1	LS_GlobalVariable("Pos2Val",0,"",0)			// Value at Pos 2	LS_GlobalVariable("IntegralVal",0,"",0)		// Value of integral	LS_GlobalVariable("LS_ReanalyzingData",0,"",0)	// Stupid programmatic variable: Suppress graphs when Reanalyzing Data	LS_GlobalVariable("CompileGraphShowSEM",0,"",0)	// Boolean: Show the SEM in the compiled traces graph	LS_GlobalVariable("CompileGrSmMedian",0,"",0)	// Boolean: Median Smooth? Otherwise Mean Smooth.	LS_GlobalVariable("CompileGrSmBlock",0,"",0)	// Boolean: Blcok Smooth? Otherwise sliding smooth, like with Smooth/B command	LS_GlobalVariable("CompileGraphSmooth",0,"",0)	// Boolean: Smooth traces in the compiled traces graph	LS_GlobalVariable("CompileGraphSmVal",7,"",0)	// When smoothing traces in the compiled traces graph, use this value for the box smooth	LS_GlobalVariable("RecallROICheckVar",0,"",0)	// Boolean: Remember ROIs when reanalyzing?	LS_GlobalVariable("ImRegCheckVar",0,"",0)		// Boolean: Do image registration?	LS_GlobalVariable("ImRegPolyStr",0,"",1)		// String: Polygon that is moved around through image registration	LS_GlobalVariable("PreSmoothCheckVar",0,"",0)	// Boolean: PRE-smooth traces?	LS_GlobalVariable("PreSmoothVal",3,"",0)		// When PRE-smoothing traces, use this value for the box smooth	LS_GlobalVariable("ScSc",1,"",0)				// BUG?  ScreenResolution/PanelResolution("")			// The screen scale tells Igor where to position Panels (only really applies in Windows, not on Macs)		LS_GlobalVariable("RAT_Str",0,"<Empty>",1)		// The Read-All-Tags string that will contain the TIFF comments produced by ScanImage (NB! Different for v3.7 vs SI 2015 and up!)	LS_GlobalVariable("LS_ModernLoadMode",1,"",0)	// Load TIFF header RAT string as in SI 2015 and up? Or as in v3.7? (see above)	//// Define variables for the progress bar	LS_GlobalVariable("Progress_Val",0,"",0)	LS_GlobalVariable("Progress_Counter",0,"",0)	LS_GlobalVariable("Progress_Max",100,"",0)	LS_GlobalVariable("Progress_MessageStr",0,"",1)	//// Define regions	LS_GlobalVariable("LeftBound",-1,"",0)		// Boundary for from best fit gaussian	LS_GlobalVariable("RightBound",-1,"",0)		// Boundary for from best fit gaussian	LS_GlobalVariable("LS_Left",107,"",0)		// Boundary for linescan left	LS_GlobalVariable("LS_Right",119,"",0)		// Boundary for linescan right	LS_GlobalVariable("BG_Left",42,"",0)			// Background left	LS_GlobalVariable("BG_Right",79,"",0)		// Background right	LS_GlobalVariable("F0_Upper",2,"",0)		// Baseline upper boundary	LS_GlobalVariable("F0_Lower",98,"",0)		// Baseline lower boundary		// Dendritic diameters	LS_GlobalVariable("DiamRed",-1,"",0)			// Dendritic diameter [µm] based on the red channel	LS_GlobalVariable("DiamGreen",-1,"",0)		// Dendritic diameter [µm] based on the green channel	//// Analysis parameters	LS_GlobalVariable("SubBGFlag",1,"",0)			// Subtract background? Should always be on, really	LS_GlobalVariable("FixBleaching",0,"",0)		// Try to account for strong bleaching	LS_GlobalVariable("BleachSmooth",15,"",0)		// Use a running background estimate that is smoothed by this much	LS_GlobalVariable("dt",2.3,"",0)				// Default ms-per-line [ms]	LS_GlobalVariable("Calc_mode",1,"",0)	LS_GlobalVariable("SPoints",11,"",0)				// Smoothing points [samples]	LS_GlobalVariable("Smth",0,"",0)		LS_GlobalVariable("SizeToShow",300,"",0)		// Size of image when displaying it [pixels]	LS_GlobalVariable("LS_autoGreen",1,"",0)		// Boolean: Auto green LUT	LS_GlobalVariable("LS_autoRed",1,"",0)			// Boolean: Auto red LUT	LS_GlobalVariable("LS_lowGreen",0,"",0)			// Low end of manual green LUT	LS_GlobalVariable("LS_highGreen",255,"",0)		// High end of manual green LUT	LS_GlobalVariable("LS_lowRed",0,"",0)			// Low end of manual red LUT	LS_GlobalVariable("LS_highRed",255,"",0)		// High end of manual red LUT		LS_GlobalVariable("TimeIsOffBy",0,"",0)			// When matching electrophys to imaging, the computer clocks were off by this many seconds													// A negative number means electrophys waves were time stamped with an earlier time than the imaging daata	LS_GlobalVariable("TimeSlop",2,"",0)			// When matching electrophys to imaging, allow for this much slop in the timing [seconds]		//// Frame parameters	LS_GlobalVariable("ImageWidth",0,"",0)			// Width of image file [pixels]	LS_GlobalVariable("ImageHeight",0,"",0)			// Height of image file [pixels]	LS_GlobalVariable("nFrames",0,"",0)				// Number of frames [per channel]	LS_GlobalVariable("frameNumber",0,"",0)			// Which frame to currently view when using the slider	LS_GlobalVariable("frameRate",0,"",0)			// The frame rate when in frame scan mode	LS_GlobalVariable("frameBaseStart",0,"",0)		// Baseline start when in frame scan mode	LS_GlobalVariable("frameBaseEnd",11,"",0)		// Baseline end when in frame scan mode	LS_GlobalVariable("frameHeight",0,"",0)			// Height of each frame in image file [pixels]	//// Image loading parameters	LS_GlobalVariable("FileNum",NaN,"",0)			// Suffix number of image file {established from selected file}	LS_GlobalVariable("FileNumStr",0,"",1)			// Suffix number as a string	NVAR	FileNum	SVAR	FileNumStr	FileNumStr = num2str(FileNum)					LS_GlobalVariable("CurrentChannel",0,"",0)		// Current channel number shown	LS_GlobalVariable("flipCh",0,"",0)				// Boolean: Flip green and red channels?	NVAR	flipCh	NVAR	CurrentChannel	if (flipCh)		CurrentChannel = 1-CurrentChannel 			// Flip channels	endif	// Note to self:	//		- When channels are *not* flipped, then green is channel 1, and red is channel 2	//		- When channels *are* flipped, then red is channel 1, and green is channel 2	LS_GlobalVariable("ImageData",0,"",1)						// Image header	LS_GlobalVariable("BaseName",0,"{no image}",1)				// Base name of file	LS_GlobalVariable("PathName",0,"{no image}",1)				// Path name of image file	LS_GlobalVariable("ePhysPathName",0,"{not decided}",1)		// Path name of ePhys data	LS_GlobalVariable("ePhysImagPathsSame",1,"",0)				// Boolean: Path names for ePhys and imaging the same?	LS_GlobalVariable("ShowPathName",0,"{no path selected}",1)	// Last characters of pathname, just for displaying it in the panel	LS_GlobalVariable("ImageFileName",0,"{no image}",1)			// File name	LS_GlobalVariable("dFData",0,"",1)							// Name of analyzed data wave	if (!exists("AllImage"))		Make/O		AllImage	endif	if (!exists("CurrentImage"))		Make/O		CurrentImage	endif	LS_GlobalVariable("FrameFlag",0,"",0)				// Boolean: This is a frame scan, not a line scan	LS_GlobalVariable("LS_nChannels",2,"",0)			// Number of channels loaded (largely used to get rid of accidentally acquired Dodt channel)	Variable/G	LS_doOneOnly = 0						// These should always be reset to zero when re-starting panel	Variable/G	LS_whichOne = 0		//// Multiple Analysis parameters	LS_GlobalVariable("Multi_nFiles",6,"",0)			// When analyzing multiple linescans, this is the number of files	LS_GlobalVariable("Multi_SuffIncr",3,"",0)			// When analyzing multiple linescans, this is the suffix increment between files	LS_GlobalVariable("ReviewSlotNumber",0,"",0)		// When reviewing individual linescans, look at this slot	LS_GlobalVariable("SuffixStr",0,"",1)				// Remember suffix as a string too, for the purposes of using with PopUp menus	//// Blank artifact params	LS_GlobalVariable("BlankCheckVar",0,"",0)			// Blank artifact?	LS_GlobalVariable("BlankStart",90,"",0)				// Blanking out artifact, start here [ms]	LS_GlobalVariable("BlankEnd",120,"",0)				// Blanking out artifact, end here [ms]	LS_GlobalVariable("BlankInAverage",0,"",0)			// Blank artifact in averaged traces too?	//// Scan Area	LS_GlobalVariable("LS_RunningScanArea",0,"",0)		// Boolean: Running Scan Area right now?	LS_GlobalVariable("LS_pDiff",0,"",0)				// p value for a given pixel	LS_GlobalVariable("LS_integralSupralin",0,"",0)		// Supralinearity for a given pixel run		//// ROI analysis in movies for Airi's astrocytes	LS_GlobalVariable("LS_operateOnROI",1,"",0)			// Which ROI to act on	LS_GlobalVariable("RecallROICounter",0,"",0)		// Count total number of ROIs stored	LS_GlobalVariable("LS_moveROI_x",1,"",0)			// Which ROI to act on	LS_GlobalVariable("LS_moveROI_y",1,"",0)			// Which ROI to act on	print LS_setupStr	Print "Done setting up variables..."	LS_setupStr = "\t"		Print "Setting up waves (T - text wave, N - numerical wave, X - wave already exists)"	colCounter = 0		MakeWaveIfNotExists("SuffixWave","T")	MakeWaveIfNotExists("LegendWave","T")	MakeWaveIfNotExists("MaxPeakWave","N")	MakeWaveIfNotExists("Pos1Wave","N")	MakeWaveIfNotExists("Pos2Wave","N")	MakeWaveIfNotExists("IntegralWave","N")	MakeWaveIfNotExists("pMaxPeakWave","N")	MakeWaveIfNotExists("pPos1Wave","N")	MakeWaveIfNotExists("pPos2Wave","N")	MakeWaveIfNotExists("pIntegralWave","N")	MakeWaveIfNotExists("SuffixStartWave","N")	MakeWaveIfNotExists("nFilesWave","N")	MakeWaveIfNotExists("IncrementWave","N")	MakeWaveIfNotExists("RecallWaveListWave","T")	print LS_setupStr	Print "Done setting up waves"	if (!exists("CumulMaxPeakWave"))		ResetCumulWaves()	endif	//// Make LineScanPanel	MakeLineScanPanel()		if (wasRestarted)		ProduceImage()	endif	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Choose wave suffices to ignore in the averages etc. --> to avoid outliers, bad waves, whatever...Function SuffToIgnoreProc(ctrlName) : ButtonControl	String ctrlName		SuffToIgnorePanelProc()	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Create the choose-data-points-to-ignore panelFunction SuffToIgnorePanelProc()		Variable		ScSc = PanelResolution("")/ScreenResolution	NVAR		NPointsToIgnore =		NPointsToIgnore	NVAR		IvalStart =				IvalStart								// Start of an interval of points to ignore	NVAR		IvalEnd =				IvalEnd									// End of an interval of points to ignore	Variable	PanWidth = 160	Variable	PanHeight = 66+21+21+(NPointsToIgnore-1)*(17+4)	Variable	PanX = 160	Variable	PanY = 64		Variable	i	String		CommandStr	String		VariableStr		// If panel already exists, keep it in the same place, please	DoWindow SuffToIgnorePanel	if (V_flag)		GetWindow SuffToIgnorePanel, wsize		PanX = V_left/ScSc		PanY = V_top/ScSc	endif	DoWindow/K SuffToIgnorePanel	NewPanel/K=2 /W=(PanX,PanY,PanX+PanWidth,PanY+PanHeight) as "Choose points!"	DoWindow/C SuffToIgnorePanel		Button CloseThePanelButton,pos={4,4},size={PanWidth-8,17},proc=CloseSuffToIgnorePanel,title="Close this panel",fSize=11,font="Arial"	SetVariable NPointsToIgnoreSetVar,pos={4,17+4+4},size={PanWidth-8,17},proc=UpdateNSufficesToIgnoreProc,title="# of points:"	SetVariable NPointsToIgnoreSetVar,limits={0,30,1},value= NPointsToIgnore,fSize=11,font="Arial"	SetVariable IvalStartSetVar,pos={4,17+4+4+21},size={PanWidth-8,17},title="Start I-val:"	SetVariable IvalStartSetVar,limits={-1,Inf,1},value= IvalStart,fSize=11,font="Arial"	SetVariable IvalEndSetVar,pos={4,17+4+4+21*2},size={PanWidth-8,17},title="End I-val:"	SetVariable IvalEndSetVar,limits={-1,Inf,1},value= IvalEnd,fSize=11,font="Arial"		i = 0	do		CommandStr = "DataPointSetVar_"+num2str(i+1)		VariableStr = "DataPoint_"+num2str(i+1)		SetVariable $CommandStr,pos={4+8,17+4+21+21+4+(17+4)*(i+1)},size={PanWidth-8-8,17},proc=ReadSuffToIgnorePanel,title="Point #"+JS3_num2digstr(2,i+1)+": "		SetVariable $CommandStr,limits={-1,Inf,1},value= $VariableStr,fSize=11,font="Arial"		i += 1	while (i<30)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Close the choose-data-points-to-ignore panelFunction CloseSuffToIgnorePanel(ctrlName) : ButtonControl	String ctrlName	DoReadSuffToIgnorePanel()	DoWindow/K SuffToIgnorePanelEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Calls the DoReadSuffToIgnorePanel function as soon as the value of a data point variable has been changed//Function ReadSuffToIgnorePanel(ctrlName,varNum,varStr,varName) : SetVariableControl//	String ctrlName//	Variable varNum//	String varStr//	String varName//	//	DoReadSuffToIgnorePanel()//	//EndFunction ReadSuffToIgnorePanel(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update			Variable dval = sva.dval			String sval = sva.sval			DoReadSuffToIgnorePanel()			break		case -1: // control being killed			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// This function reads the data in the single variables present in the panel and updates the wave that contains the corresponding//// values. The wave is then used in the DoItProc to speed things upFunction DoReadSuffToIgnorePanel()	Variable	i	String		CommandStr		NVAR		NPointsToIgnore =		NPointsToIgnore	WAVE		SuffToIgnoreWave =		SuffToIgnoreWave		if (NPointsToIgnore>0)		i = 0		do			CommandStr = "DataPointSetVar_"+num2str(i+1)			ControlInfo/W=SuffToIgnorePanel $CommandStr			SuffToIgnoreWave[i] = V_value			i += 1		while (i<NPointsToIgnore)	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Change the number of points shown in the choose-suffices-to-ignore panel//Function UpdateNSufficesToIgnoreProc(ctrlName,varNum,varStr,varName) : SetVariableControl//	String ctrlName//	Variable varNum//	String varStr//	String varName////	SuffToIgnorePanelProc()////EndFunction UpdateNSufficesToIgnoreProc(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update			Variable dval = sva.dval			String sval = sva.sval			SuffToIgnorePanelProc()			break		case -1: // control being killed			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Make wave if it doesn't already existFunction MakeWaveIfNotExists(theName,theType)	String	theName	String	theType		NVAR		colCounter	if (exists("LS_setupStr"))		SVAR		LS_setupStr	else		String/G	LS_setupStr = "\t"	endif	if (!exists(theName))//		Print "\t\tMaking the wave:",theName		if (StringMatch(theType,"T"))			Make/T/O/N=(0) $theName			LS_setupStr += "T"		else			Make/O/N=(0) $theName			LS_setupStr += "N"		Endif	else		LS_setupStr += "X"	Endif	colCounter += 1	if (colCounter>64)		colCounter = 0		LS_setupStr += "\r\t"	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Produces a global variable unless it already exists. This way, old variable values won't be over-written, when using a//// new version of the DatAn procedure.Function LS_GlobalVariable(VarName,NumValue,StrValue,StrFlag)	String		VarName							// Name of variable	Variable	NumValue							// If numerical, its value	String		StrValue							// If string, its value	Variable	StrFlag								// Boolean: Variable is a string		NVAR		colCounter		if (exists("LS_setupStr"))		SVAR		LS_setupStr	else		String/G	LS_setupStr = "\t"	endif	if (!exists(VarName))		if (StrFlag)			String/G	$VarName = StrValue		else			Variable/G	$VarName = NumValue		endif		LS_setupStr += "1"	else		LS_setupStr += "0"	endif		colCounter += 1	if (colCounter>64)		colCounter = 0		LS_setupStr += "\r\t"	endifEnd//////////////////////////////////////////////////////////////////////////////////////////////////////// Reset the waves in which the cumulative data is stored	Function ResetCumulWaves()//	Print "\t\t"+Time()+"\t\t-\t\tResetting the cumulative data storage"	Make/O/N=(0) CumulMaxPeakWave,CumulMaxLocWave,CumulbaseValWave,CumulPos1Wave,CumulPos2Wave,CumulIntegralwave,CumulSuffixWave,CumulGroupTagWave	Variable/G	CumulCounter = 0End///////////////////////////////////////////////////////////////////////////////////// Copy baseline in ms from analysis section to frame scan sectionFunction CopyFrameBaseProc(ctrlName) : ButtonControl	String ctrlName		NVAR	frameBaseStart	NVAR	frameBaseEnd	NVAR	frameRate		NVAR	baseStart	NVAR	baseWin		frameBaseStart = Floor(baseStart*1e-3*frameRate)	frameBaseEnd = Floor((baseStart+baseWin)*1e-3*frameRate)-1	End//////////////////////////////////////////////////////////////////////////////////////////////////////// Sometimes the font in the panel does not update properly	Function LS_FixFontInPanel()	DefaultGUIFont/W=LineScanAnalysis popup={"Arial",10,1},all={"Arial",10,0}	DoWindow ImageViewer	if (V_flag)		DefaultGUIFont/W=ImageViewer popup={"Arial",10,1},all={"Arial",10,0}	endif	End//////////////////////////////////////////////////////////////////////////////////////////////////////// Make the LineScanPanel	Function MakeLineScanPanel(): Panel		Variable	xPos = 8	Variable	yPos = 50	Variable	panWidth = 288	Variable	panHeight= 260+17+20*21+20+20+20		NVAR		CurrentChannel = CurrentChannel	NVAR		flipCh = flipCh	NVAR		Calc_mode = Calc_mode	NVAR		ScSc = ScSc	NVAR		ePhysImagPathsSame = ePhysImagPathsSame	NVAR		FixBleaching	NVAR		SubBGFlag		Dowindow /K LineScanAnalysis	NewPanel /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+panWidth*ScSc,yPos*ScSc+panHeight*ScSc) as "Scan Analysis"	Dowindow /C LineScanAnalysis	ModifyPanel/W=LineScanAnalysis fixedSize=1	DoUpdate	LS_FixFontInPanel()	Variable	fade = 2 	//// Load & Display	Variable	yShift = 12	GroupBox LoadBox,title="Load & Display",pos={20-4-4,2},size={100+4+100+4+16+36+4,20*9+6+13},fStyle=1,fSize=11,frame=1,fColor=(0,0,65535)	CheckBox LoadModeCheck,pos={panWidth/2,2},title="ScanImage 2015 or higher",fSize=9,value=1,help={"Unchecked means load as if acquired by ScIm v3.7 or earlier."}	SetVariable ImagePathSetVar pos={20,28-15-4+yShift},size={200-50+100,15},fstyle=1,title="Path:",value=ShowPathName,noedit=1,frame=1	SetVariable ImageFileNameSetVar pos={20,28-15-4+yShift+17},size={200-50-4,15},fstyle=1,title="File name:",value=BaseName,noedit=1,frame=1	SetVariable ImageFileNameSuffixSetVar pos={20+200-50,28-15-4+yShift+17},size={100,15},fstyle=1,title="Suffix#:",value=FileNumStr,noedit=1,frame=1 	Button LoadImage, pos={20,28+yShift+17}, size={80,18}, proc=LoadImage2, title="Load Image",fStyle=1,fColor=(65535/fade,65535/fade,65535)	Button PrevImg, pos={102-1,28+yShift+17}, size={16,18}, proc=LSMoveFile, title="<"	Button NextImg, pos={102+14+1,28+yShift+17}, size={16,18}, proc=LSMoveFile, title=">" 	Button RefreshButton, pos={102+14+2+14+2,28+yShift+17}, size={58,18}, proc=RefreshProc, title="Refresh"	SetVariable ImageSize pos={168-20-6+34+22,28+yShift+17},size={74,15},proc=ModImSizeProc,limits={100,Inf,50},title="Size",value=SizeToShow	PopupMenu ViewChan, pos={20,50+yShift+17},size={100+20,24}, value = "Green;Red;",mode=((flipCh==1)*(1-CurrentChannel)+(flipCh==0)*CurrentChannel+1), proc=ViewChanSet, help={"Set the channel currently viewed in the image window."},title="View:"	PopupMenu ChannelOrder, pos={20+60+20+6+2+4+4+8,50+yShift+17},size={152,24}, value = "green 1, red 2;red 1, green 2;",mode=(flipCh+1), help={"This setting affects the dG/G and dG/R calculations."}, proc=ChannelOrderSet,title="Order:"	Button FindMatchingFiles, pos={20,28+yShift+17+20+20+4}, size={60+20,18}, proc=FindWavesMatchingInTime, title="Match ePhys",help={"Put all .ibw files in path specfied above, then click this button to find the waves which were acquired at the same time as the image at hand."}	SetVariable TimeIsOffBySetVar pos={20+60+20+4,28+yShift+17+20*2+4},size={88,15},limits={-Inf,Inf,1},title="Off by [s]:",help={"Negative means that the electrophysiology waves were stamped with an earlier time than the imaging data."},value=TimeIsOffBy	SetVariable TimeSlopSetVar pos={20+60+20+4+88,28+yShift+17+20*2+4},size={80,15},limits={-Inf,Inf,1},title="Slop [s]:",help={"Allow for this much slop in the search."},value=TimeSlop	CheckBox UseCacheCheck,pos={20,28+yShift+17+20*3+4},title="Use cache?",value=1,help={"This cache is used to speed up the search for electrophys waves that match in time."}	Button KillCacheButton, pos={20+122+4+22+20-80-4,28+yShift+17+20*3+4}, size={40,18}, proc=KillCacheProc, title="Kill"	Button ShowCacheButton, pos={20+122+4+22+20-40,28+yShift+17+20*3+4}, size={40,18}, proc=ShowCacheProc, title="Show"	CheckBox ZIPedDataCheck,pos={20+122+4+22+20+4,28+yShift+17+20*3+4},title="ZIP-ed data?",value=0,help={"If data was zipped, then the file creator data was messed up and date & info has to be extracted from within the file. This is slower."}	CheckBox ePhysSamePathCheck,pos={20,28+yShift+17+20*4+4},title="ePhys path same as imaging?",Proc=Toggle_ePhysPathProc,value=ePhysImagPathsSame,help={"Use same directory for the electrophys and imaging data."}	Button ShowPathsButton, pos={20+122+4+22+20,28+yShift+17+20*4+4}, size={80+4,18}, proc=Show_PathsProc, title="Show paths"	Button ShowCommentsButton, pos={20,28+yShift+17+20*5+4}, size={122,18}, proc=ShowCommentsProc, title="ScanImage Notes",help={"Show the ScanImage notes."}	Button ShowMPNotesButton, pos={20+122+4,28+yShift+17+20*5+4}, size={122+4,18}, proc=ShowMPNotesProc, title="MultiPatch Notes",help={"Show the MultiPatch notes."}	NVAR	FrameFlag	CheckBox FrameFlagCheck,pos={20,28+yShift+17+20*6+4},title="Frame scan?",Proc=Toggle_FrameFlagProc,value=FrameFlag,help={"Check this to load frame scans rather than to load line scans."}	SetVariable frameBaseStartSetVar pos={20+74+4,28+yShift+17+20*6+4},size={85,15},limits={0,Inf,1},title="Bsln strt:",value=frameBaseStart	SetVariable frameBaseEndSetVar pos={20+100+4+59,28+yShift+17+20*6+4},size={65,15},limits={0,Inf,1},title="end:",value=frameBaseEnd	Button CopyFrameBaseButton, pos={20+100+4+59+65,28+yShift+17+20*6+4}, size={20+4,18}, proc=CopyFrameBaseProc, title="Cp",help={"Copy frame baseline start and end (in terms of frames) from Bsln strt and wid (in ms) in analysis section below."}	//// Analysis	yShift = 20+20+20+20	GroupBox AnalyzeBox,title="Analysis",pos={20-4-4,100-10+17+20+yShift},size={100+4+100+4+16+36+4,26+15+15+2+17+20*18},fStyle=1,fSize=11,frame=1,fColor=(0,0,65535)	Button Analyze, pos={20,100+8+17+22+yShift}, size={100, 18}, proc=Linescan2, title="Analyze",fStyle=1,fColor=(65535/fade,65535/fade,65535)	PopupMenu CalcMode, title="Calc Mode", mode=(Calc_mode+1), pos={124,108+19+20+yShift-2}, value = "DG/G;DG/R;R/G;", proc=CalcModeSet, help={"Set Calcuration Mode"}	CheckBox FixBleachingCheck, pos={20,100+26+4+17+20+yShift}, size={60, 18},title="Bleach?",value=FixBleaching,help={"Try to account for rapid bleaching by using running background average."}	SetVariable BleachSmoothSetVar pos={82,100+26+4+17+20+yShift},size={75,15},title="Smooth",value= BleachSmooth,limits={3,Inf,1}	CheckBox SubtractBGCheck, pos={20+82+65+4+10,100+26+4+17+20+yShift}, size={60, 18},title="Subtract BG?",value=SubBGFlag,help={"Subtract background. This should in principle always be checked."}	yShift += 20	Button MultiAnalyze, pos={20,100+26+4+17+20+yShift-2}, size={100, 18}, proc=MultiAnalysisProc, title="Analyze multi",fStyle=1,fColor=(65535/fade,65535/fade,65535)	SetVariable AnMulti_nFiles pos={20+100+4,100+26+4+17+20+yShift},size={70,15},limits={2,Inf,1},title="nFiles:",value=Multi_nFiles	SetVariable AnMulti_SuffIncr pos={20+100+4+74,100+26+4+17+20+yShift},size={70,15},limits={1,Inf,1},title="Step:",value=Multi_SuffIncr	Button ReviewLineScans, pos={20,100+26+4+17+20+yShift-2+20}, size={100, 17}, proc=ReviewLineScansProc, title="Review LSs"	SetVariable ReviewSlotNumber pos={20+100+4,100+26+4+17+20+20-2+yShift},size={70,15},limits={0,Inf,1},title="Slot#:",value=ReviewSlotNumber	Button SuffToIgnore,pos={20+100+4+74,100+26+4+17+20+yShift-2+20}, size={70, 15}, proc=SuffToIgnoreProc, title="Skip LSs"	SetVariable SCANRATE pos={20,100+26+4+15+2+2+15+17+20+2+yShift},size={140,15},proc=LineScan2FromSetVar,limits={0,Inf,0.1},title="Scan rate (ms/line)",value= dt	Button AutomaticRegionsButton, pos={134+34,100+26+4+15+2+2+15+17+20+yShift+2}, size={100,17}, proc=AutomaticRegionsProc, title="Auto regions"//	PopupMenu MsPerLinePopUp, title="Presets:", mode=1, pos={20,100+26+4+15+2+2+15+17+17+2+20+yShift+2}, value =#"MsPerLinePopUpStr", proc=MsPerLinePopUpProc, help={"Get scan rate from pre-set values"}	// Adjust MsPerLinePopUp when drawing panel -- select popup value that matches the current scan rate dt//	SVAR	MsPerLinePopUpStr = MsPerLinePopUpStr//	NVAR	dt = dt//	String	SearchStr = num2str(dt)//	if (dt==Floor(dt))//		SearchStr += ".00"//	endif//	Variable StrStart = StrSearch(MsPerLinePopUpStr,SearchStr,0)//	Variable StrEnd = StrSearch(MsPerLinePopUpStr,";",StrStart)//	String	TargetStr = MsPerLinePopUpStr[StrStart,StrEnd-1]//	Variable PopUpChoice = WhichListItem(TargetStr,MsPerLinePopUpStr)//	If (PopUpChoice == -1)//		Beep;Print "\t\tPeculiar error on refresh: Could not set the \"Presets\"pop-up menu. PopUpChoice is ",PopUpChoice," and TargetStr is \""+TargetStr+"\".\rIs defafult dt set to a funny value? dt = ",dt//	else//		PopupMenu MsPerLinePopUp,win=LineScanAnalysis,mode=(PopUpChoice+1)//	endif	fade = 2	Variable	xShift = 34	yShift = 186+20*5	Button LS_GrabButton, pos={20,yShift+17+20}, size={38, 17}, proc=LS_GrabProc, title="Grab",fColor=(65535/fade,65535/fade,0)	SetVariable LSLEFT pos={23+xShift+6,yShift+17+20},size={100,15},proc=SetLines2,title="LS_Left",value= LS_Left	SetVariable LSRIGHT pos={134+xShift,yShift+17+20},size={100,15},proc=SetLines2,title="LS_Right",value= LS_Right	Button BG_GrabButton, pos={20,yShift+19*1+17+20}, size={38, 17}, proc=BG_GrabProc, title="Grab",fColor=(65535/fade,0,0)	SetVariable BGLEFT pos={23+xShift+6,yShift+19*1+17+20},size={100,15},proc=SetLines2,title="BG_Left",value= BG_Left	SetVariable BGRIGHT pos={134+xShift,yShift+19*1+17+20},size={100,15},proc=SetLines2,title="BG_Right",value= BG_Right	Button F0_GrabButton, pos={20,yShift+19*2+17+20}, size={38, 17}, proc=F0_GrabProc, title="Grab",fColor=(0,65535/fade,0)	SetVariable F0UP pos={23+xShift+6,yShift+19*2+17+20},size={100,15},proc=SetLines2,title="F0_Upper",value= F0_Upper	SetVariable F0LOW pos={134+xShift,yShift+19*2+17+20},size={100,15},proc=SetLines2,title="F0_Lower",value= F0_Lower	yShift = 186+20*2+19*2+17+20+20+20+20+20	xShift = 248/4	Variable	rowCount = 0	Button ShowExtractedDataButton, pos={20+xShift*0,yShift}, size={xShift-4, 17}, proc=ShowExtractedDataProc, title="Show data"	Button KillDataTableButton, pos={20+xShift*1,yShift}, size={xShift-4, 17}, proc=KillDataTableProc, title="Close data"	Button KillExtractedDataButton, pos={20+xShift*2,yShift}, size={xShift-4, 17}, proc=KillExtractedDataProc, title="Kill data"	PopupMenu ShowBarsPopUp, title="Bars", mode=0, pos={20+xShift*3,yShift-2},size={xShift-4,17}, value ="MaxPeakWave;Pos1Wave;Pos2Wave;IntegralWave;", proc=LS_MakeBarsProc, help={"Make simple bar graph from data table"}	PopupMenu ShowBarsPopUp bodyWidth=xShift-4	rowCount +=1	xShift = 248/3	Button FrontGraphsButton, pos={20+xShift*0,yShift+20*rowCount}, size={xShift-4, 17}, proc=ManageGraphsProc, title="Graphs to front"	Button BackGraphsButton, pos={20+xShift*1,yShift+20*rowCount}, size={xShift-4, 17}, proc=ManageGraphsProc, title="Graphs to back"	Button KillGraphsButton, pos={20+xShift*2,yShift+20*rowCount}, size={xShift-4, 17}, proc=ManageGraphsProc, title="Kill graphs"	rowCount +=1	SetVariable nCategoriesSetVar pos={20,yShift+20*rowCount},size={122,15},limits={0,Inf,1},title="Next data point:",value=nCategories	SetVariable mWinWidthSetVar pos={20+122+4,yShift+20*rowCount},size={122,15},limits={0,Inf,1},title="Win width [ms]:",value=mWinWidth	rowCount +=1		SetVariable fixPos1SetVar pos={20,yShift+20*rowCount},size={122,15},limits={0,Inf,1},title="Point 1 [ms]: ",value=fixPos1	SetVariable fixPos2SetVar pos={20+122+4,yShift+20*rowCount},size={122,15},limits={0,Inf,1},title="Point 2 [ms]:",value=fixPos2	rowCount +=1		SetVariable baseStartSetVar pos={20,yShift+20*rowCount},size={122,15},limits={0,Inf,10},title="Bsln strt [ms]:",value=baseStart	SetVariable baseWinSetVar pos={20+122+4,yShift+20*rowCount},size={122,15},limits={0,Inf,10},title="Bslne wid [ms]:",value=baseWin	rowCount +=1		SetVariable IntegralStartSetVar pos={20,yShift+20*rowCount},size={122,15},limits={0,Inf,10},title="Intgrl strt [ms]:",value=IntegralStart	SetVariable IntegralEndSetVar pos={20+122+4,yShift+20*rowCount},size={122,15},limits={0,Inf,10},title="Intgrl end [ms]:",value=IntegralEnd	rowCount +=1		xShift = 248/3	Button ReAnalyzeDataSetButton, pos={20+xShift*0,yShift+20*rowCount}, size={xShift-4, 17}, proc=ReAnalyzeDataSetProc, title="Reanalyze",fStyle=1,fColor=(65535/fade,65535/fade,65535)	PopupMenu StoreROIPopUp, title="ReAn one", mode=0, pos={20+xShift*1,yShift+20*rowCount-2},size={xShift-4,17}, value=#"SuffixStr", proc=ReAnalyzeOneProc, help={"In an already analyzed dataset, reanalyze only one condition."}	PopupMenu StoreROIPopUp bodyWidth=xShift-4,fSize=10,font="Arial"	Button MakeCompiledGraphButton, pos={20+xShift*2,yShift+20*rowCount}, size={xShift-4, 17}, proc=MakeCompiledGraphProc, title="Compile traces"	rowCount +=1	xShift = 248/2	CheckBox RecallROICheck,pos={20+xShift*0,yShift+20*rowCount+1},size={xShift-4,17},title="Recall ROI",Variable=RecallROICheckVar	CheckBox ImRegCheck,pos={20+xShift*1,yShift+20*rowCount+1},size={xShift-4,17},title="Image registration",Variable=ImRegCheckVar	rowCount +=1	CheckBox CT_ShowSEMCheck,pos={20,yShift+20*rowCount},title="SEM",Variable=CompileGraphShowSEM	CheckBox CT_SmMedianCheck,pos={20+40+3,yShift+20*rowCount},title="Median",Variable=CompileGrSmMedian	CheckBox CT_SmBlockCheck,pos={20+40+50+7,yShift+20*rowCount},title="Block",Variable=CompileGrSmBlock	CheckBox CT_SmoothTracesCheck,pos={20+195-60+14,yShift+20*rowCount},title="Smooth:",Variable=CompileGraphSmooth	SetVariable CT_SmValSetVar pos={20+195+13,yShift+20*rowCount},size={40,15},limits={1,Inf,1},title=" ",value=CompileGraphSmVal	rowCount +=1	Button UpdateParamsButton, pos={20,yShift+20*rowCount}, size={72, 17}, proc=UpdateParamsProc, title="Update"	SetVariable ReAnalyzeStartSetVar pos={20+160-84,yShift+20*rowCount},size={79,15},limits={1,Inf,1},title="Start:",value=ReAnalyzeStart	SetVariable ReAnalyzeNFilesSetVar pos={20+160+4-5,yShift+20*rowCount},size={89,15},limits={1,Inf,1},title="# of LSs:",value=ReAnalyzeNFiles	rowCount +=1	CheckBox RealignBaselineCheck,pos={20,yShift+20*rowCount},title="Realign baseline",Variable=RealignBaselineCheckVar	CheckBox PreSmoothTracesCheck,pos={20+68+4+45,yShift+20*rowCount},title="Pre-smooth:",Variable=PreSmoothCheckVar	SetVariable PreSmoothValSetVar pos={20+195,yShift+20*rowCount},size={53,15},limits={1,Inf,1},title=" ",value=PreSmoothVal	rowCount +=1	CheckBox BlankCheck,pos={20,yShift+20*rowCount},title="Blank",Variable=BlankCheckVar	SetVariable BlankStartSetVar pos={20+160-84-20,yShift+20*rowCount},size={79+20,15},limits={1,Inf,1},title="Start [ms]:",value=BlankStart	SetVariable BlankEndSetVar pos={20+160+4-5,yShift+20*rowCount},size={89,15},limits={1,Inf,1},title="End [ms]:",value=BlankEnd	rowCount +=1	CheckBox BlankInAveCheck,pos={20,yShift+20*rowCount},title="Blank in averages",Variable=BlankInAverage	Button ShowBleachGraphsButton, pos={20+122+4,yShift+20*rowCount}, size={122+4,18}, proc=MakeBleachGraphsProc, title="Bleach analysis"	rowCount +=1	//// Manage data	yShift = 441+26+20+20+20+20+20+20+2+20+20+20	GroupBox DataManagementBox,title="Data Management",pos={20-4-4,yShift},size={100+4+100+4+16+36+4,20*5},fStyle=1,frame=1,fSize=11,fColor=(0,0,65535)	Button ShowParametersButton, pos={20,yShift+18+20*0}, size={140, 17}, proc=ShowParametersProc, title="Show parameters"	Button KillParametersButton, pos={20+140+4,yShift+18+20*0}, size={104, 17}, proc=KillParametersProc, title="Kill parameters"	Button SetAutoDateButton, pos={20,yShift+18+20*1}, size={140-32-12-12-4-4-4, 17}, proc=SetAutoDateProc, title="Auto date"	Button DeltaDateDown10Button,pos={20+140-32-12-12-4-4,yShift+18+20*1},size={32,17},proc=LS_DeltaDateProc,title="<10"	Button DeltaDateDownButton,pos={20+140-12-12-6,yShift+18+20*1},size={16,17},proc=LS_DeltaDateProc,title="<"	Button DeltaDateUpButton,pos={20+140-14,yShift+18+20*1},size={16,17},proc=LS_DeltaDateProc,title=">"	Button ExportDataButton, pos={20+140+4,yShift+18+20*1}, size={104, 17}, proc=ExportDataProc, title="Export data",fStyle=1,fColor=(65535/fade,65535/fade,65535)	Button AutoFillInButton, pos={20,yShift+18+20*2}, size={140, 17}, proc=AutoFillInProc, title="Auto fill-in data"	Button AutoParamFNameButton, pos={20+140+4,yShift+18+20*2}, size={104, 17}, proc=AutoParamFNameProc, title="Auto filename"	SetVariable ParamsFileNameSetVar pos={20,yShift+18+20*3},size={250,15},fstyle=1,title="File name:",value=ParamsFilename,frame=1		// This sorts out a stupid bug associated with the GroupBox, which overlap in mysterious ways on a Mac unless you show the tools and then remove them	ShowTools/W=LineScanAnalysis	DoUpdate	HideTools/W=LineScanAnalysis	DoUpdateEnd/////////////////////////////////////////////////////////////////////////// Set the parameter table such that a reanalysis results in a different starting point and// different number of waves.Function UpdateParamsProc(ctrlName) : ButtonControl	String ctrlName		NVAR	ReAnalyzeStart	NVAR	ReAnalyzeNFiles	WAVE	SuffixStartWave	WAVE	nFilesWave		Print "Updating start and number of linescans at "+Time()+" on "+Date()	print "\tStarting suffix:",ReAnalyzeStart	print "\tNumber of files:",ReAnalyzeNFiles		Variable	dummy = ReAnalyzeStart-SuffixStartWave[0]	SuffixStartWave = SuffixStartWave+dummy		nFilesWave = ReAnalyzeNFilesEnd/////////////////////////////////////////////////////////////////////////// Toggle the ePhys data path to be the same, or different as, the imaging data path.Function Toggle_FrameFlagProc(ctrlName,checked) : CheckBoxControl	String		ctrlName	Variable	checked		NVAR		FrameFlag		FrameFlag = checked		if (FrameFlag)		Print "Loaded images will be interpreted as frame scans."	else		Print "Loaded images will be interpreted as line scans."	endifEnd/////////////////////////////////////////////////////////////////////////// Toggle the ePhys data path to be the same, or different as, the imaging data path.Function Toggle_ePhysPathProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked		SVAR	ePhysPathName = ePhysPathName	SVAR	PathName = PathName	NVAR	ePhysImagPathsSame = ePhysImagPathsSame		ePhysImagPathsSame = checked	//	ControlInfo/W=LineScanAnalysis ePhysSamePathCheck					// Should ePhys path also be updated?//	Variable CheckBoxExists = (V_flag==2)//	Variable SamePath//	if (CheckBoxExists)//		SamePath = V_value//	else//		SamePath = 1//	endif		if (ePhysImagPathsSame)		Print "--- ePhys data path is now the same as that of the imaging data ---"		ePhysPathName = PathName	else		NewPath/O/Q/M="Chose the path to the ePhys data!" ePhysPath		PathInfo ePhysPath		if (V_flag)			ePhysPathName = S_path		else			print "ERROR! Path doesn't appear to exist!"			ePhysPathName = PathName		endif		Print "--- ePhys data path is now *not* the same as that of the imaging data ---"	endif		Print "\t\t"+ePhysPathName	KillCacheProc("Override")			// Don't ask user if cache should be killed...	End/////////////////////////////////////////////////////////////////////////// Review the selected set of linescanFunction ReviewLineScansProc(ctrlName) : ButtonControl	String ctrlName		NVAR		ReviewSlotNumber = ReviewSlotNumber	WAVE/T	RecallWaveListWave = RecallWaveListWave	Variable	xPos = 200+40	Variable	yPos = 270	Variable	Width = 600	Variable	Height = 420			if (ReviewSlotNumber+1<=numpnts(RecallWaveListWave))			String		TheLineScans = RecallWaveListWave[ReviewSlotNumber]		String		CurrLS		Variable	nWaves = ItemsInList(TheLineScans,",")				WAVE/T	LegendWave = LegendWave		//		Print "Found ",nWaves," linescans to review for ",LegendWave[ReviewSlotNumber]				DoWindow/K ReviewLSGr		Display /W=(xPos,yPos,xPos+Width,yPos+Height)  as "Slot #"+num2str(ReviewSlotNumber)+": "+LegendWave[ReviewSlotNumber]		DoWindow/C ReviewLSGr				Variable  	i = 0		do			CurrLS = StringFromList(i,TheLineScans,",")//			Print "--- Adding:",CurrLS			AppendToGraph/W=ReviewLSGr $CurrLS			ModifyGraph lSize($(CurrLS))=2			ModifyGraph rgb($(CurrLS))=(65535*i/(nWaves-1),0,65535*(nWaves-1-i)/(nWaves-1))			i += 1		while(i<nWaves)		ModifyGraph fSize=18		Label left "dG/R"		Label bottom "time [s]"		//SetAxis bottom 0.05,0.5		Legend		ControlBar 22	 	Button KillItButton, pos={0,2}, size={20,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	Button ZoomInButton, pos={24,2}, size={20,17},proc=ZoomInProc, title="Z",fSize=10,font="Arial"		Button AutoYRangeButton, pos={2+24+24,2}, size={20,17},proc=AutoYRangeProc, title="A",fSize=10,font="Arial"		Button MeasureAllButton, pos={2+24+24+24,2}, size={60,17},proc=ReviewLSMeasureProc, title="Measure",fSize=10,font="Arial"		Button SpreadTracesButton, pos={2+24+24+24+2+60,2}, size={60,17},proc=LS_SpreadTracesProc, title="Spread",fSize=10,font="Arial"		Button GoLeftButton, pos={2+24+24+24+2+60+2+60,2}, size={20,17},proc=LS_GoReviewProc, title="<",fSize=10,font="Arial"		Button GoRightButton, pos={2+24+24+24+2+60+2+60+2+20,2}, size={20,17},proc=LS_GoReviewProc, title=">",fSize=10,font="Arial"		NVAR		baseStart = baseStart		NVAR		baseWin = baseWin	 		 	LS_AlignBaseline(baseStart/1e3,(baseStart+baseWin)/1e3)	 	ModifyGraph zero(left)=2	 		 else	 	Print "Slot number ",ReviewSlotNumber," does not exist."	 endifEnd/////////////////////////////////////////////////////////////////////////// Go up or down in slot of Review LS graphFunction LS_GoReviewProc(ctrlName) : ButtonControl	String ctrlName		NVAR		ReviewSlotNumber	WAVE/T	LegendWave	Variable	n = numpnts(LegendWave)-1		if (StringMatch(ctrlName,"GoLeftButton"))		ReviewSlotNumber -= 1	else		ReviewSlotNumber += 1	endif		if (ReviewSlotNumber<0)		ReviewSlotNumber = 0	endif		if (ReviewSlotNumber>n)		ReviewSlotNumber = n	endif		ReviewLineScansProc("")	End/////////////////////////////////////////////////////////////////////////// Spread traces in top graphFunction LS_SpreadTracesProc(ctrlName) : ButtonControl	String ctrlName	 	JT_SpreadTracesInGraph() End/////////////////////////////////////////////////////////////////////////// Print the ePhys path to the command windowFunction Show_PathsProc(ctrlName) : ButtonControl	String ctrlName		SVAR	PathName = PathName	SVAR	ePhysPathName = ePhysPathName		Print "\tThe imaging data is located here in this directory: "	Print "\t\t"+PathName	Print "\tThe ePhys data is located here in this directory: "	Print "\t\t"+ePhysPathName		End/////////////////////////////////////////////////////////////////////////// Kills the Match ePhys cacheFunction KillCacheProc(ctrlName) : ButtonControl	String ctrlName	Variable	ShouldKillCache	DoWindow/K ePhysCache	if (!stringMatch(ctrlName,"Override"))		DoAlert 1,"Really kill the cache?"		ShouldKillCache = V_flag	else		ShouldKillCache = 1	endif	if (ShouldKillCache==1)		print "Killed cache at "+Time()+"."		KillWaves/Z DateTimeCacheWave,TimeStrCacheWave,FileNameStrCacheWave	else		print "Cache was not killed."	endif	End/////////////////////////////////////////////////////////////////////////// Show the Match ePhys cacheFunction ShowCacheProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K ePhysCache	Edit/W=(146,104,500,619) FileNameStrCacheWave,TimeStrCacheWave	ModifyTable width(FileNameStrCacheWave)=138,width(TimeStrCacheWave)=114	DoWindow/C ePhysCache	End/////////////////////////////////////////////////////////////////////////// Export the data, to permit analysis of ensemble data using other softwares.Function ExportDataProc(ctrlName) : ButtonControl	String ctrlName		WAVE		ParameterNumWave = ParameterNumWave	WAVE/T	ParameterTextWave = ParameterTextWave	WAVE/T	ParameterDescrWave = ParameterDescrWave	WAVE/T	SuffixWave = SuffixWave	WAVE/T	LegendWave = LegendWave	WAVE		MaxPeakWave = MaxPeakWave	WAVE		Pos1Wave = Pos1Wave	WAVE		Pos2Wave = Pos2Wave	WAVE		IntegralWave = IntegralWave	WAVE		SuffixStartWave = SuffixStartWave	WAVE		nFilesWave = nFilesWave	WAVE		IncrementWave = IncrementWave		SVAR 		ParamsFilename = ParamsFilename		if (numpnts(SuffixWave)==0)		Abort "Found no data to store away. Data table is empty."	endif		Print "+++ Exporting data +++"	Print "\tat "+Time()+" on "+Date()		String/G	fList								// List of all the waves to be saved...	//// FIND PATH ////	String		HD_Name = ""	PathInfo LS_StoreHere	if (V_Flag)		PathInfo/S LS_StoreHere													// Make next dialog open where it was opened the last time data was exported	else		PathInfo/S Igor_Stuff												// Find out which HD this procedure file was loaded from		if (V_Flag)			Print "Located the path \"Igor Stuff\"."			HD_Name = StringFromList(0,S_Path,":")		else				Print "Could not located the path \"Igor Stuff\" -- using default HD."	//		HD_Name = "Snowpea"			HD_Name = "Aluminium HD"		endif		Print "\tHD is:",HD_Name		NewPath/O/Q DummyPath,HD_Name+":Users:jesper:Experiments:Extracted 2PLSM:"		PathInfo/S DummyPath													// Make next dialog open in the Extracted 2PLSM folder	endif	NewPath/Q/O/M="Where do you want to save the exported data?" LS_StoreHere	//// COPY WAVES ////	String		ExportFileSuffix = ParamsFilename[2,StrLen(ParamsFilename)-1]	fList = ""	Duplicate/O	ParameterNumWave,$("pNum"+ExportFileSuffix)	fList += ("pNum"+ExportFileSuffix)+";"	Duplicate/O/T	ParameterTextWave,$("pTxt"+ExportFileSuffix)	fList += ("pTxt"+ExportFileSuffix)+";"	Duplicate/O/T	ParameterDescrWave,$("pDsc"+ExportFileSuffix)	fList += ("pDsc"+ExportFileSuffix)+";"	Duplicate/O/T	SuffixWave,$("Suff"+ExportFileSuffix)	fList += ("Suff"+ExportFileSuffix)+";"	Duplicate/O/T	LegendWave,$("Lgnd"+ExportFileSuffix)	fList += ("Lgnd"+ExportFileSuffix)+";"	Duplicate/O	MaxPeakWave,$("Max"+ExportFileSuffix)	fList += ("Max"+ExportFileSuffix)+";"	Duplicate/O	Pos1Wave,$("Pos1"+ExportFileSuffix)	fList += ("Pos1"+ExportFileSuffix)+";"	Duplicate/O	Pos2Wave,$("Pos2"+ExportFileSuffix)	fList += ("Pos2"+ExportFileSuffix)+";"	Duplicate/O	IntegralWave,$("Igrl"+ExportFileSuffix)	fList += ("Igrl"+ExportFileSuffix)+";"	Duplicate/O	SuffixStartWave,$("SfSt"+ExportFileSuffix)	fList += ("SfSt"+ExportFileSuffix)+";"	Duplicate/O	nFilesWave,$("nFls"+ExportFileSuffix)	fList += ("nFls"+ExportFileSuffix)+";"	Duplicate/O	IncrementWave,$("Incr"+ExportFileSuffix)	fList += ("Incr"+ExportFileSuffix)+";"		Variable	i,j	Variable	n = numpnts(SuffixWave)	i = 0	if (n>0)		do			Duplicate/O $("meanWave"+SuffixWave[i]),$("m"+JS3_num2digstr(3,i+1)+ExportFileSuffix)			fList += ("m"+JS3_num2digstr(3,i+1)+ExportFileSuffix)+";"			Duplicate/O $("SEMWaveL"+SuffixWave[i]),$("sL"+JS3_num2digstr(3,i+1)+ExportFileSuffix)			fList += ("sL"+JS3_num2digstr(3,i+1)+ExportFileSuffix)+";"			Duplicate/O $("SEMWaveU"+SuffixWave[i]),$("sU"+JS3_num2digstr(3,i+1)+ExportFileSuffix)			fList += ("sU"+JS3_num2digstr(3,i+1)+ExportFileSuffix)+";"			i += 1		while(i<n)	else		print "\tStrange error: Found no averaged traces to store away..."	endif		//// DUMP NOTES ////	i = 0	n = ItemsInList(fList)	Variable nColumns = 4	Printf "\tStoring these waves:"	do		if (mod(i,nColumns)==0)			printf "\r\t\t"		else			printf ",    "		endif		printf StringFromList(i, fList)		i += 1	while (i<n)	print "\r"	//// SAVE WAVES ////	save/B/T/W/O/P=LS_StoreHere fList as ParamsFilename	PathInfo LS_StoreHere	Print "\tStored these waves in the file \""+ParamsFilename+"\" in the directory \""+S_path+"\""	Print "+++ Done exporting data +++"End////////////////////////////////////////////////////////////////////////////////////	This function returns a string representing a number padded with zeros, so that the number of character//	= digits. If num occupies more digits than requested, the excess low digits of the number are truncated. // 	e.g. calling JS3_num2digstr (3,1234) returns "123", while  calling JS3_num2digstr (6,1234) returns "001234"// Borrowed from SNUtilities2.3 on 2004-03-08, Jesper SjostromFunction /S JS3_num2digstr(digits,num)	variable digits, num	String outstr, zerostr="000000000000", numstr = num2istr(num)	variable i=1		if (strlen(numstr) <= digits) 		outstr = zerostr[0,digits-1]				outstr[digits-strlen(numstr),digits-1] = numstr	else		outstr = numstr[0,digits-1]	endif		return outstrEnd/////////////////////////////////////////////////////////////////////////// Auto fill-in of data in the Parameters table// *	Set position automatically, based on the relative position found in the//		ScanImage comments// *	Auto fill-in the path and the file basenameFunction AutoFillInProc(ctrlName) : ButtonControl	String ctrlName	WAVE/T	ParameterDescrWave = ParameterDescrWave	WAVE		ParameterNumWave = ParameterNumWave	WAVE/T	ParameterTextWave = ParameterTextWave	SVAR		RAT_Str = RAT_Str		SVAR		ShowPathName = ShowPathName	SVAR		PathName = PathName	SVAR		BaseName = BaseName	NVAR		DiamGreen	NVAR		DiamRed	NVAR		LS_Left = LS_Left	NVAR		LS_Right = LS_Right	if (StringMatch(RAT_Str,"<Empty>"))		Abort "ScanImage Notes header not found. Is no image loaded yet? Make sure you are using Igor PRO v5.03 or higher."	endif	Variable	ScanImageDistance = Round(str2num(StringByKey("state.motor.distance",RAT_Str,"=","\r")))	Print "Getting position from ScanImage TIFF header:",ScanImageDistance,"µm"	if (abs(ParameterNumWave[4]-ScanImageDistance)>1)		DoAlert 1,"Distance in table does not match that in ScanImage header. Update table?"		if (V_flag==1)			ParameterNumWave[4]=ScanImageDistance			Print "\tTable was updated..."		else			Print "\tTable not updated..."		endif	endif	Print "Storing pathname and filename",BaseName,ShowPathName	ParameterTextWave[5] = PathName	ParameterTextWave[6] = BaseName		ParameterDescrWave[9] = "Branch point"	ParameterTextWave[9] = "µm"	Variable	scanAmplitudeX = str2num(StringByKey("state.acq.scanAmplitudeX",RAT_Str,"=","\r"))	Variable	zoomFactor = str2num(StringByKey("state.acq.zoomFactor",RAT_Str,"=","\r"))	Variable	pixelsPerLine = str2num(StringByKey("state.acq.pixelsPerLine",RAT_Str,"=","\r"))		// Dendritic diameter GREEN	ParameterDescrWave[10] = "Dendritic diameter Green"	ParameterNumWave[10] = DiamGreen	ParameterTextWave[10] = "µm"	// Dendritic diameter RED	ParameterDescrWave[11] = "Dendritic diameter Red"	ParameterNumWave[11] = DiamRed	ParameterTextWave[11] = "µm"	// Scan amplitude X	ParameterDescrWave[12] = "scanAmplitudeX"	ParameterNumWave[12] = scanAmplitudeX	ParameterTextWave[12] = ""	// zoomFactor	ParameterDescrWave[13] = "zoomFactor"	ParameterNumWave[13] = zoomFactor	ParameterTextWave[13] = ""	// pixelsPerLine	ParameterDescrWave[14] = "pixelsPerLine"	ParameterNumWave[14] = pixelsPerLine	ParameterTextWave[14] = ""End/////////////////////////////////////////////////////////////////////////// Set filename automatically// This routine takes the current date and concatenates the contents of numerical parameter// number 4 (default value contains the position of the linescan relative to the soma)Function AutoParamFNameProc(ctrlName) : ButtonControl	String ctrlName		WAVE		ParameterNumWave = ParameterNumWave	WAVE/T	ParameterTextWave = ParameterTextWave		WAVE		SuffixStartWave = SuffixStartWave	SVAR 		ParamsFilename = ParamsFilename		Variable	n = StrLen(ParameterTextWave[3])	String		ModDateString = ParameterTextWave[3]	Variable	i		i = 0	do		if (StringMatch(ModDateString[i]," "))			ModDateString[i,i] = "_"		endif		if (StringMatch(ModDateString[i],","))			ModDateString = ModDateString[0,i-1]+ModDateString[i+1,StrLen(ModDateString)]			i -= 1		endif		i += 1	while (i<n)	ParamsFilename = "LS_"+ModDateString+"_"+num2str(ParameterNumWave[4])+"_i"+num2str(SuffixStartWave[0])		Print "Setting the filename for exported data to:",ParamsFilenameEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Ajusting the DeltaDate up or down//// WARNING!!! -- I borrowed this proc from MP_DatAn, make sure to keep track of data folders correctly!!!Function LS_DeltaDateProc(ctrlName) : ButtonControl	String ctrlName	NVAR		DeltaDate = DeltaDate	strswitch(ctrlName)		case "DeltaDateUpButton":			Print "Adjusting date up one day"			DeltaDate += 1			break		case "DeltaDateDown10Button":			Print "Adjusting date down 10 days"			DeltaDate -= 10			break		case "DeltaDateDownButton":			Print "Adjusting date down one day"			DeltaDate -= 1			break		default:			Print "Strange error in {LS_DeltaDateProc}"	endswitch	SetAutoDateProc("")End/////////////////////////////////////////////////////////////////////////// Set date automatically to today's dateFunction SetAutoDateProc(ctrlName) : ButtonControl	String ctrlName		NVAR		DeltaDate = DeltaDate	WAVE/T	ParameterTextWave = ParameterTextWave	Variable 	now = DateTime	if (StringMatch(ctrlName,"SetAutoDateButton"))		Print "Adjusting date to today's date minus one day"		DeltaDate = -1	endif	//	ParameterTextWave[3] = secs2date(now+24*60*60*DeltaDate,2)	ParameterTextWave[3] = JT_MakeOldDateFormat(now+24*60*60*DeltaDate)End	/////////////////////////////////////////////////////////////////////////// Kill the parameter tableFunction KillParametersProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K ParamTableEnd	/////////////////////////////////////////////////////////////////////////// Show the parameter tableFunction ShowParametersProc(ctrlName) : ButtonControl	String ctrlName		NVAR		nParams = nParams	WAVE		ParameterNumWave = ParameterNumWave	WAVE/T	ParameterTextWave = ParameterTextWave	WAVE/T	ParameterDescrWave = ParameterDescrWave		DoWindow/K ParamTable	Edit/W=(297,378,771,608+80) ParameterDescrWave,ParameterNumWave,ParameterTextWave	DoWindow/C ParamTable	ModifyTable width(ParameterDescrWave)=130,width(ParameterNumWave)=110,width(ParameterTextWave)=136	End	/////////////////////////////////////////////////////////////////////////// Manage the graphsFunction ManageGraphsProc(ctrlName) : ButtonControl	String ctrlName		WAVE/T	SuffixWave = SuffixWave	Variable	i	Variable	nGraphs = numpnts(SuffixWave)		if (nGraphs == 0)		Print "No graphs have been generated yet."	else		i = 0		do			strswitch(ctrlName[0,3])				case "Kill":					DoWindow/K $("Gr"+SuffixWave[i])					break				case "Fron":					DoWindow/F $("Gr"+SuffixWave[i])					break				case "Back":					DoWindow/B $("Gr"+SuffixWave[i])					break				default:					Abort "Strange error when killing graphs: Cannot find the button that was pressed."			endswitch			i += 1		while (i<nGraphs)				strswitch(ctrlName[0,3])			case "Kill":				DoWindow/K AllTracesGr				DoWindow/K basalCa_graph				DoWindow/K BaseCaOverTime				DoWindow/K CaSigOverTime				DoWindow/K PeakSignalBars				break			case "Fron":				DoWindow/F AllTracesGr				DoWindow/F basalCa_graph				DoWindow/F BaseCaOverTime				DoWindow/F CaSigOverTime				DoWindow/F PeakSignalBars				break			case "Back":				DoWindow/B AllTracesGr				DoWindow/B basalCa_graph				DoWindow/B BaseCaOverTime				DoWindow/B CaSigOverTime				DoWindow/B PeakSignalBars				break		endswitch		endifEnd/////////////////////////////////////////////////////////////////////////// Scan entire ROI, pixel by pixel, for supralinearityFunction LS_ScanArea()	DoAlert	1,"Are you sure you want to run LS_ScanArea?"	if (V_flag!=1)		Print "Not running LS_ScanArea -- user aborted."		Abort	endif	NVAR		SizeToShow = SizeToShow	NVAR		ScSc = ScSc	Variable	xPos = 32	Variable	yPos = 50+50	Variable	Width = SizeToShow*1.6	Variable	Height = Width	WAVE		TheROI	WAVE		TheBG		NVAR		ImageWidth	NVAR		ImageHeight	NVAR		FrameFlag		Variable	ROI_width = 3	Variable	ROI_centre = 1		Variable	pixelCounter = 0	Duplicate/O TheROI,RememberROI																	// Integers	Duplicate/O TheBG,RememberBG	if ((!(Exists("LS_RunningScanArea"))) %| (!(Exists("pPos1Wave"))))		Print "Problem! You need to restart Scan Analysis panel to set up more variables & waves!"		Abort "Problem! You need to restart Scan Analysis panel to set up more variables & waves!"	endif	Make /O/N=(ImageWidth, ImageHeight) TheResultsImage	,ThepValueImage							// Floats	TheResultsImage = 0	ThepValueImage = 1	Make /O/N=(ImageWidth, ImageHeight) MaxPeakImage,Pos1Image,Pos2Image,IntegralImage			// Floats	MaxPeakImage = 0	Pos1Image = 0	Pos2Image = 0	IntegralImage = 0	Make /O/N=(ImageWidth, ImageHeight) pMaxPeakImage,pPos1Image,pPos2Image,pIntegralImage		// Floats	pMaxPeakImage = 0	pPos1Image = 0	pPos2Image = 0	pIntegralImage = 0		WAVE		MaxPeakWave	WAVE		Pos1Wave	WAVE		Pos2Wave	WAVE		IntegralWave	WAVE		pMaxPeakWave	WAVE		pPos1Wave	WAVE		pPos2Wave	WAVE		pIntegralWave	NVAR/Z		LS_integralSupralin	NVAR		LS_pDiff	NVAR/Z		LS_RunningScanArea	LS_RunningScanArea = 1		Variable	AspectRatio	SVAR		RAT_Str	if (StrLen(StringByKey("state.acq.scanAmplitudeY",RAT_Str,"=","\r"))==0)		AspectRatio = abs(str2num(StringByKey("state.acq.scanAngularRangeSlow",RAT_Str,"=","\r"))/str2num(StringByKey("state.acq.scanAngularRangeFast",RAT_Str,"=","\r")))	else		AspectRatio = abs(str2num(StringByKey("state.acq.scanAmplitudeY",RAT_Str,"=","\r"))/str2num(StringByKey("state.acq.scanAmplitudeX",RAT_Str,"=","\r")))	endif//	DoWindow/F ImageViewer3	DoWindow/K ScanAreaProgress	Display/W=(xPos*ScSc+Width*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as "ScanArea Progress"	DoWindow/C ScanAreaProgress	AppendImage /T theROI	SetAxis/A/R left	ModifyGraph height={Aspect,AspectRatio}	ModifyGraph mirror=3	ModifyImage theROI ctab= {0,2,Yellow,0}	AppendMatrixContour/W=ScanAreaProgress/T RememberROI	ModifyContour/W=ScanAreaProgress RememberROI rgbLines=(65535,65535,0),autoLevels={*,*,1},labels=0	ModifyGraph/W=ScanAreaProgress lsize=1 	DoUpdate 		AppendMatrixContour/W=ScanAreaProgress/T theBG	ModifyContour/W=ScanAreaProgress theBG rgbLines=(32768,40777,65535),autoLevels={*,*,1},labels=0	ModifyGraph/W=ScanAreaProgress lsize=1 	AutoPositionWindow/M=0/R=LineScanAnalysis ScanAreaProgress//	DoWindow/F ResultsImageViewer2		Variable	Keys		Variable	nConditions	Variable	i,j,k	i = 0	do		j = 0		do			if (RememberROI[i][j])				print "+++ Found a pixel in ROI at (",i,",",j,") with value "+num2str(RememberROI[i][j])+". Now examining this pixel... +++"				TheROI = 0				k = 0				do					TheROI[i+k-ROI_centre][j] = 1					k += 1				while (k<ROI_width)				pixelCounter += 1				if (1)					// Set to zero for testing					ReAnalyzeDataSetProc("")					nConditions = numpnts(MaxPeakWave)					TheResultsImage[i][j] = LS_integralSupralin					ThepValueImage[i][j] = LS_pDiff					MaxPeakImage[i][j] = MaxPeakWave[nConditions-1]		// This all presupposes that the "APs only" condition is the last one					Pos1Image[i][j] = Pos1Wave[nConditions-1]					Pos2Image[i][j] = Pos2Wave[nConditions-1]					IntegralImage[i][j] = IntegralWave[nConditions-1]					pMaxPeakImage[i][j] = pMaxPeakWave[nConditions-1]	// Get corresponding p values too					pPos1Image[i][j] = pPos1Wave[nConditions-1]					pPos2Image[i][j] = pPos2Wave[nConditions-1]					pIntegralImage[i][j] = pIntegralWave[nConditions-1]//					print LS_pDiff,ThepValueImage[i][j]					Duplicate/O TheROI,MostRecentROI					Keys = GetKeyState(0)					if (Keys & 2^2)						Print "You pressed the shift key -- now terminating the loop gracefully."						j = inf						i = inf					endif				else					TheResultsImage[i][j] = 1				endif			endif			j += 1		while(j<ImageHeight)		i += 1	while(i<ImageWidth-ROI_width+1)//	TheResultsImage = theROI	Print "Examined ",pixelCounter,"pixels."	Duplicate/O RememberROI,TheROI	Duplicate/O RememberBG,TheBG		LS_RunningScanArea = 0		DoWindow/K PeakSignalBars	DoWindow/K basalCa_graph	DoWindow/K ScanAreaProgress	LS_ProduceResultsImages(3)		// Defaulting to Pos2 calcium signalEnd/////////////////////////////////////////////////////////////////////////// After scanning entire ROI, pixel by pixel, produce the results figureFunction LS_ProduceResultsImages(source)	Variable	source	NVAR		SizeToShow = SizeToShow	NVAR		ScSc = ScSc	Variable	xPos = 32	Variable	yPos = 50+50	Variable	Width = SizeToShow*1.6	Variable	Height = Width		Variable	nContourLines = 5	Variable	fade = 0.6	Variable	gap	Variable	size		Variable	AspectRatio	SVAR		RAT_Str	if (StrLen(StringByKey("state.acq.scanAmplitudeY",RAT_Str,"=","\r"))==0)		AspectRatio = abs(str2num(StringByKey("state.acq.scanAngularRangeSlow",RAT_Str,"=","\r"))/str2num(StringByKey("state.acq.scanAngularRangeFast",RAT_Str,"=","\r")))	else		AspectRatio = abs(str2num(StringByKey("state.acq.scanAmplitudeY",RAT_Str,"=","\r"))/str2num(StringByKey("state.acq.scanAmplitudeX",RAT_Str,"=","\r")))	endif		WAVE		TheImage2	WAVE		TheResultsImage	WAVE		ThepValueImage	Duplicate/O TheResultsImage,TheResultsImageMOD	imageStats TheImage2	Variable	threshold = (V_max-V_min)*0.1+V_min	TheResultsImageMOD = TheImage2 [p][q] > threshold ? TheResultsImage[p][q] : 0	Variable	lowEnd = 70	Variable	highEnd = 140//	TheResultsImageMOD = ( (ThepValueImage[p][q] < 0.1) %& (TheResultsImageMOD[p][q]>100) %& (TheResultsImageMOD[p][q]<400) ) ? TheResultsImageMOD[p][q] : 100	TheResultsImageMOD = ( ((ThepValueImage[p][q] < 0.05) %| (ThepValueImage[p+1][q]< 0.05) %| (ThepValueImage[p-1][q] < 0.05)) %& (TheResultsImageMOD[p][q]>100) %& (TheResultsImageMOD[p][q]<300)) ? TheResultsImageMOD[p][q] : 100	// Display the RAW results image	DoWindow /K ResultsImageViewer2	Display /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as "Results Image RAW"	DoWindow /C ResultsImageViewer2	AppendImage /T TheResultsImage	SetAxis/A/R left	ModifyGraph height={Aspect,AspectRatio}	ModifyGraph mirror=3	ModifyImage TheResultsImage ctab= {lowEnd,highEnd,YellowHot,0}	ModifyImage TheResultsImage minRGB=0	ModifyImage TheResultsImage maxRGB=0	AppendMatrixContour/W=ResultsImageViewer2/T TheImage2	ModifyContour/W=ResultsImageViewer2 TheImage2 rgbLines=(65535*fade,65535*fade,65535*fade),autoLevels={*,*,nContourLines},labels=0	ModifyGraph/W=ResultsImageViewer2 lsize=1		ColorScale/C/N=text0/A=RT/X=1.00/Y=5.00 "both/sum (%)"	ColorScale/C/N=text0 nticks=3		// Display the p-modified results image	DoWindow /K ResultsImageViewer	Display /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as "Results Image"	DoWindow /C ResultsImageViewer	AppendImage /T TheResultsImageMOD	SetAxis/A/R left	ModifyGraph height={Aspect,AspectRatio}	ModifyGraph mirror=3	ModifyImage TheResultsImageMOD ctab= {*,*,YellowHot,0}	ModifyImage TheResultsImageMOD minRGB=0	ModifyImage TheResultsImageMOD maxRGB=0	AppendMatrixContour/W=ResultsImageViewer/T TheImage2	ModifyContour/W=ResultsImageViewer TheImage2 rgbLines=(65535*fade,65535*fade,65535*fade),autoLevels={*,*,nContourLines},labels=0	ModifyGraph/W=ResultsImageViewer lsize=1		ColorScale/C/N=text0/A=RT/X=1.00/Y=5.00 "both/sum (%)"	ColorScale/C/N=text0 nticks=3		// Display the p-value image	DoWindow /K ResultsImageViewer4	Display /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as "p values"	DoWindow /C ResultsImageViewer4	AppendImage /T ThepValueImage	SetAxis/A/R left	ModifyGraph height={Aspect,AspectRatio}	ModifyGraph mirror=3	ModifyImage ThepValueImage ctab= {*,*,Rainbow,0}	AppendMatrixContour/W=ResultsImageViewer4/T TheImage2	ModifyContour/W=ResultsImageViewer4 TheImage2 rgbLines=(65535*fade,65535*fade,65535*fade),autoLevels={*,*,nContourLines},labels=0	ModifyGraph/W=ResultsImageViewer4 lsize=1		ColorScale/C/N=text0/A=RT/X=1.00/Y=5.00 "p value"	ColorScale/C/N=text0 nticks=3		// Display the calcium signal image	WAVE		MaxPeakImage	WAVE		Pos1Image	WAVE		Pos2Image	WAVE		IntegralImage	WAVE		pMaxPeakImage	WAVE		pPos1Image	WAVE		pPos2Image	WAVE		pIntegralImage		String		SourceStr = ""	Variable	pThres = 0.05	switch(source)		case 1:			Duplicate/O	MaxPeakImage,TheCaSignalImage			TheCaSignalImage = (pMaxPeakImage[p][q] < pThres) ? TheCaSignalImage[p][q] : 0			TheCaSignalImage *= 100			SourceStr = "Max Peak"			break		case 2:			Duplicate/O	Pos1Image,TheCaSignalImage			TheCaSignalImage = (pPos1Image[p][q] < pThres) ? TheCaSignalImage[p][q] : 0			TheCaSignalImage *= 100			SourceStr = "Pos 1"			break		case 3:			Duplicate/O	Pos2Image,TheCaSignalImage			TheCaSignalImage = (pPos2Image[p][q] < pThres) ? TheCaSignalImage[p][q] : 0			TheCaSignalImage *= 100			SourceStr = "Pos 2"			break		case 4:			Duplicate/O	IntegralImage,TheCaSignalImage			TheCaSignalImage = (pIntegralImage[p][q] < pThres) ? TheCaSignalImage[p][q] : 0			SourceStr = "Integral"			break	endswitch	TheCaSignalImage = (TheCaSignalImage[p][q] < 0) ? 0 : TheCaSignalImage[p][q]	DoWindow /K ResultsImageViewer3	Display /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as "Calcium signal: "+SourceStr	DoWindow /C ResultsImageViewer3	AppendImage /T TheCaSignalImage	SetAxis/A/R left	ModifyGraph height={Aspect,AspectRatio}	ModifyGraph mirror=3	ModifyImage TheCaSignalImage ctab= {0,*,Green,0}	ModifyImage TheCaSignalImage minRGB=0	ModifyImage TheCaSignalImage maxRGB=0	AppendMatrixContour/W=ResultsImageViewer3/T TheImage2	ModifyContour/W=ResultsImageViewer3 TheImage2 rgbLines=(65535*fade,65535*fade,65535*fade),autoLevels={*,*,nContourLines},labels=0	ModifyGraph/W=ResultsImageViewer3 lsize=1		if (source==4)		ColorScale/C/N=text0/A=RT/X=1.00/Y=5.00 "dG/R*t (%s)"	else		ColorScale/C/N=text0/A=RT/X=1.00/Y=5.00 "dG/R (%)"	endif	ColorScale/C/N=text0 nticks=3		DoUpdate 	AutoPositionWindow/E/M=1/R=ResultsImageViewer2 ResultsImageViewer4	DoUpdate 	AutoPositionWindow/E/M=1/R=ResultsImageViewer4 ResultsImageViewer	DoUpdate 	AutoPositionWindow/E/M=1/R=ResultsImageViewer ResultsImageViewer3	End/////////////////////////////////////////////////////////////////////////// Reanalyze one condition in the data setFunction ReAnalyzeOneProc(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr		NVAR		LS_whichOne	LS_whichOne = 0	NVAR		LS_doOneOnly	LS_doOneOnly = 1		if (StrLen(popStr)>0)		print "Reanalyzing \""+popStr+"\""		LS_whichOne = popNum		ReAnalyzeDataSetProc("_"+popStr)	else		print "Empty string."	endif	LS_doOneOnly = 0	LS_whichOne = 0	End/////////////////////////////////////////////////////////////////////////// Reanalyze the entire data setFunction ReAnalyzeDataSetProc(ctrlName) : ButtonControl	String ctrlName	NVAR		doOneOnly = LS_doOneOnly//	Variable		doOneOnly = 0	String		whichOne = ""	NVAR		LS_whichOne		if (StringMatch(ctrlName[0],"_"))		doOneOnly = 1		whichOne = ctrlName[1,strLen(ctrlName)-1]	endif		WAVE/T	SuffixWave = SuffixWave	WAVE/T	LegendWave = LegendWave	WAVE		SuffixStartWave = SuffixStartWave	WAVE		nFilesWave = nFilesWave	WAVE		IncrementWave = IncrementWave	NVAR		FileNum = FileNum	NVAR		Multi_nFiles = Multi_nFiles	NVAR		Multi_SuffIncr = Multi_SuffIncr	NVAR		ReAnalyzeStart = ReAnalyzeStart	SVAR		BaseName = BaseName	SVAR		FileNumStr = FileNumStr	SVAR		PathName = PathName	SVAR		ImageData = ImageData	SVAR		ImageFileName = ImageFileName		SVAR		ConditionStr = ConditionStr		NVAR		LS_ReanalyzingData = LS_ReanalyzingData		NVAR		RecallROICheckVar		// If checked, do image registration	NVAR		ImRegCheckVar	LS_ReanalyzingData = 1										// Suppress showing intermediate graphs during re-analysis	Variable	i		NVAR	LS_RunningScanArea	if (LS_RunningScanArea==0)		if (doOneOnly)			Print "=== Reanalyzing one condition in the data set ==="			print "This one:",whichOne		else			Print "=== Reanalyzing the entire data set ==="		endif	endif		if (!(doOneOnly))		ManageGraphsProc("Kill")		KillFrameViewProc("")	endif		// Store away panel values	Variable	tempFileNum = FileNum	Variable	tempMulti_nFiles = Multi_nFiles	Variable	tempMulti_SuffIncr = Multi_SuffIncr		StoreAwayROIs("__LS")		// "__LS" (double underscore ell ess) is thus a reserved suffix!		Variable	nConditions = numpnts(SuffixStartWave)		if ((nConditions==0) %| (nConditions==0) )		Abort "Not sufficient number of conditions. Need at least two to reanalyze set."	endif		// Duplicate these waves, as they are killed before reanalysis and updated during reanalysis...	Duplicate/O SuffixStartWave,tempSuffixStartWave	Duplicate/O nFilesWave,tempnFilesWave	Duplicate/O IncrementWave,tempIncrementWave	Duplicate/O/T SuffixWave,tempSuffixWave	Duplicate/O/T LegendWave,tempLegendWave		if (!(doOneOnly))				// Kill data table		KillDataTableProc("")			// Kill the old data		KillExtractedDataProc("")	endif		// The main loop	Variable/G mainLoop = 0	if (Exists("firstGwave")==0)		 	Make/O/N=(0) firstGwave,bleachGwave,firstRwave,bleachRwave	endif	WAVE	firstGwave,bleachGwave	WAVE	firstRwave,bleachRwave	do	// Set values for current conditions		if ((doOneOnly) %& (!(StringMatch(whichOne,tempSuffixWave[mainLoop]))))			print "Skipping "+tempSuffixWave[mainLoop]		else			DoWindow/H/F			if (RecallROICheckVar)				RecallROIs(tempSuffixWave[mainLoop])			endif			if (ImRegCheckVar)				RecallImReg(tempSuffixWave[mainLoop])			endif			FileNum = tempSuffixStartWave[mainLoop]			Multi_nFiles = tempnFilesWave[mainLoop]			Multi_SuffIncr = tempIncrementWave[mainLoop]			if (LS_RunningScanArea==0)				Print "Doing \""+tempSuffixWave[mainLoop]+"\" now."			endif			MultiAnalysisProc("")			DoUpdate			ConditionStr = tempSuffixWave[mainLoop]//			ConditionStrWasTouchedProc("",LS_whichOne,"","")		// Old Igor notation			doConditionStrWasTouched(LS_whichOne)			// Store bleaching data			Duplicate/O firstGwave,$("wFirstG"+ConditionStr)			Duplicate/O bleachGwave,$("wBleachG"+ConditionStr)			Duplicate/O firstRwave,$("wFirstR"+ConditionStr)			Duplicate/O bleachRwave,$("wBleachR"+ConditionStr)		endif		mainLoop += 1	while (mainLoop<nConditions)		// Make Compiled-Traces Graph	LegendWave = tempLegendWave		// First restore legend text	MakeCompiledGraphProc("")		// Put graph at front	DoWindow/K MultiAnalGraph	ManageGraphsProc("Front")		// Kill temporary waves & restore data	if (RecallROICheckVar)		RecallROIs("__LS")	endif	FileNum = tempFileNum	Multi_nFiles = tempMulti_nFiles	Multi_SuffIncr = tempMulti_SuffIncr	FileNum2FileNumStr()	ImageFileName = BaseName + FileNumStr + ".tif"	ImageData = ImageFileName[0, strlen(ImageFileName)-5]	DoTheLoadImage("DoNotShowImage")	KillWaves/Z tempSuffixStartWave,tempnFilesWave,tempIncrementWave,tempSuffixWave	LS_ReanalyzingData = 0		// Report overal stats	SVAR		baseLineQualityStr	if (LS_RunningScanArea==0)		print baseLineQualityStr	endif	EndFunction RescueLostDataTable()	Duplicate/O tempSuffixStartWave,SuffixStartWave	Duplicate/O tempnFilesWave,nFilesWave	Duplicate/O tempIncrementWave,IncrementWave	Duplicate/O/T tempSuffixWave,SuffixWave	Duplicate/O/T tempLegendWave,LegendWaveEnd/////////////////////////////////////////////////////////////////////////// Make bleaching analysis plotsFunction MakeBleachGraphsProc(ctrlName) : ButtonControl	String ctrlName		MakeBleachGraphs()	End	Function MakeBleachGraphs()	Variable	i	WAVE		SuffixStartWave	WAVE/T	SuffixWave	WAVE/T	LegendWave	Variable	nConditions = numpnts(SuffixWave)	String		ConditionStr	String		LegStr = ""		KillBleachGraphs()	// GREEN	DoWindow/K BleachGr1	Display as "Green baseline"	DoWindow/C BleachGr1	i = 0	LegStr = "\\Z12"	do		ConditionStr = SuffixWave[i]		AppendToGraph $("wFirstG"+ConditionStr)		Duplicate/O $("wFirstG"+ConditionStr),bleachXwave		bleachXwave = p		LegStr += "\\s("+"wFirstG"+ConditionStr+") "+LegendWave[i]+", p="+num2str(Round(JT_DoPearsons("wFirstG"+ConditionStr,"bleachXwave")*1e3)/1e3)+"\r"		i += 1	while (i<nConditions)	CallColorizeTraces2()	ModifyGraph fSize=12	ModifyGraph manTick(bottom)={0,1,0,0},manMinor(bottom)={0,0}	DoUpdate	ModifyGraph mode=4,marker=8,opaque=1	Legend/F=0/B=1 LegStr	Button closeBleach, pos={1,1}, size={16, 17}, proc=KillBleachGraphsProc, title="X"	Label left,"absolute signal"	Label bottom,"iteration #"	DoWindow/K BleachGr2	Display as "Green end/beginning"	DoWindow/C BleachGr2	i = 0	LegStr = "\\Z12"	do		ConditionStr = SuffixWave[i]		AppendToGraph $("wBleachG"+ConditionStr)		Duplicate/O $("wBleachG"+ConditionStr),bleachXwave		bleachXwave = p		LegStr += "\\s("+"wBleachG"+ConditionStr+") "+LegendWave[i]+", p="+num2str(Round(JT_DoPearsons("wBleachG"+ConditionStr,"bleachXwave")*1e3)/1e3)+"\r"		i += 1	while (i<nConditions)	CallColorizeTraces2()	ModifyGraph fSize=12	ModifyGraph manTick(bottom)={0,1,0,0},manMinor(bottom)={0,0}	DoUpdate	ModifyGraph mode=4,marker=8,opaque=1	Legend/F=0/B=1 LegStr	SetDrawLayer UserBack	SetDrawEnv ycoord= left,dash= 11	DrawLine 0,1,1,1	Button closeBleach, pos={1,1}, size={16, 17}, proc=KillBleachGraphsProc, title="X"	Label left,"normalized end/beginning"	Label bottom,"iteration #"		if (nConditions==3)		JT_3BarGraphFromDataWithName("wBleachG"+SuffixWave[0],"wBleachG"+SuffixWave[1],"wBleachG"+SuffixWave[2],"GreenBleachBars")		DoWindow/T GreenBleachBars_graph,"Green end/beginning"		WAVE/T GreenBleachBars_xLabel		SetDrawLayer UserBack		SetDrawEnv ycoord= left,dash= 11		DrawLine 0,1,1,1		GreenBleachBars_xLabel = LegendWave		Button closeBleach, pos={1,1}, size={16, 17}, proc=KillBleachGraphsProc, title="X"		Label left,"norm end/beginning"	endif	// RED	DoWindow/K BleachGr3	Display as "Red baseline"	DoWindow/C BleachGr3	i = 0	LegStr = "\\Z12"	do		ConditionStr = SuffixWave[i]		AppendToGraph $("wFirstR"+ConditionStr)		Duplicate/O $("wFirstR"+ConditionStr),bleachXwave		bleachXwave = p		LegStr += "\\s("+"wFirstR"+ConditionStr+") "+LegendWave[i]+", p="+num2str(Round(JT_DoPearsons("wFirstR"+ConditionStr,"bleachXwave")*1e3)/1e3)+"\r"		i += 1	while (i<nConditions)	CallColorizeTraces2()	ModifyGraph fSize=12	ModifyGraph manTick(bottom)={0,1,0,0},manMinor(bottom)={0,0}	DoUpdate	ModifyGraph mode=4,marker=8,opaque=1	Legend/F=0/B=1 LegStr	Button closeBleach, pos={1,1}, size={16, 17}, proc=KillBleachGraphsProc, title="X"	Label left,"absolute signal"	Label bottom,"iteration #"	DoWindow/K BleachGr4	Display as "Red end/beginning"	DoWindow/C BleachGr4	i = 0	LegStr = "\\Z12"	do		ConditionStr = SuffixWave[i]		AppendToGraph $("wBleachR"+ConditionStr)		Duplicate/O $("wBleachR"+ConditionStr),bleachXwave		bleachXwave = p		LegStr += "\\s("+"wBleachR"+ConditionStr+") "+LegendWave[i]+", p="+num2str(Round(JT_DoPearsons("wBleachR"+ConditionStr,"bleachXwave")*1e3)/1e3)+"\r"		i += 1	while (i<nConditions)	CallColorizeTraces2()	ModifyGraph fSize=12	ModifyGraph manTick(bottom)={0,1,0,0},manMinor(bottom)={0,0}	DoUpdate	ModifyGraph mode=4,marker=8,opaque=1	Legend/F=0/B=1 LegStr	SetDrawLayer UserBack	SetDrawEnv ycoord= left,dash= 11	DrawLine 0,1,1,1	SetAxis/A left	Button closeBleach, pos={1,1}, size={16, 17}, proc=KillBleachGraphsProc, title="X"	Label left,"normalized end/beginning"	Label bottom,"iteration #"		if (nConditions==3)		JT_3BarGraphFromDataWithName("wBleachR"+SuffixWave[0],"wBleachR"+SuffixWave[1],"wBleachR"+SuffixWave[2],"RedBleachBars")		DoWindow/T RedBleachBars_graph,"Red end/beginning"		WAVE/T RedBleachBars_xLabel		RedBleachBars_xLabel = LegendWave		SetDrawLayer UserBack		SetDrawEnv ycoord= left,dash= 11		DrawLine 0,1,1,1		SetAxis/A left		Button closeBleach, pos={1,1}, size={16, 17}, proc=KillBleachGraphsProc, title="X"		Label left,"norm end/beginning"	endif	JT_ArrangeGraphs2("BleachGr1;BleachGr2;;BleachGr3;BleachGr4;;GreenBleachBars_graph;RedBleachBars_graph;",3,3)	BleachGraphsToFront()EndFunction BleachGraphsToFront()	JT_ArrangeGraphs3("BleachGr1;BleachGr2;BleachGr3;BleachGr4;GreenBleachBars_graph;RedBleachBars_graph;")EndFunction BleachGraphsToBack()	JT_ArrangeGraphs6("BleachGr1;BleachGr2;BleachGr3;BleachGr4;GreenBleachBars_graph;RedBleachBars_graph;")End/////////////////////////////////////////////////////////////////////////// Show current image againFunction KillBleachGraphsProc(ctrlName) : ButtonControl	String ctrlName		KillBleachGraphs()	End	Function KillBleachGraphs()	JT_ArrangeGraphs5("BleachGr1;BleachGr2;BleachGr3;BleachGr4;GreenBleachBars_graph;RedBleachBars_graph;")End/////////////////////////////////////////////////////////////////////////// Store data for image registrationFunction LS_StoreImRegProc(ctrlName,popNum,popStr) : PopupMenuControl	String		ctrlName	Variable	popNum	String		popStr		SVAR		ImRegPolyStr		Variable	Keys = GetKeyState(0)		if (StrLen(popStr)>0)		if (Keys & 4)			Print "You are holding the shift key --> Retrieving data instead"			RecallImReg(popStr)			LS_PutPolyInViewer(ImRegPolyStr)		else			print "Storing away image registration information for \""+popStr+"\""			StoreAwayImReg(popStr)		endif	else		print "Empty string."	endif	EndFunction StoreAwayImReg(suffix)					// Note! This stores BOTH polygon ROI as well as ImRegMask, so use with caution	String		suffix		SVAR		ImRegPolyStr		if (StrLen(ImRegPolyStr)==0)		Print "ImRegPolyStr is empty. You must chose a polygon, check Image Registration checkbox, and click the ROI button."		Abort "ImRegPolyStr is empty. You must chose a polygon, check Image Registration checkbox, and click the ROI button."	endif		String		tempStr = Note(ImRegRef)	if (StrLen(tempStr)==0)		Print "Note(ImRegRef) is empty. You must chose a polygon, check Image Registration checkbox, and click the ROI button."		Abort "Note(ImRegRef) is empty. You must chose a polygon, check Image Registration checkbox, and click the ROI button."	endif		// Store polygon and image for image registration	Duplicate/O ImRegRef,$("ImRegRef"+suffix)	// This copies the note as well, which contains the ImRegPolyStr		// Store Image Registration Mask	Duplicate/O ImRegMask,$("ImRegMask"+suffix)EndFunction RecallImReg(suffix)	String		suffix		if (StrLen(suffix)==0)		print "{RecallImReg} strange error: suffix string is empty."		Abort "{RecallImReg} strange error: suffix string is empty."	endif		SVAR		ImRegPolyStr	if (Exists("ImRegRef"+suffix))		Duplicate/O $("ImRegRef"+suffix),ImRegRef		Duplicate/O $("ImRegMask"+suffix),ImRegMask,ImRegMaskRef,ImRegMaskTest		// Note! ImageRegistration will manipulate ImRegMask		Redimension/S ImRegMaskRef,ImRegMaskTest							// This should be single precision float!		ImRegPolyStr = Note($("ImRegRef"+suffix))		if (StrLen(ImRegPolyStr)==0)			Print "{RecallImReg} Cannot find a polygon ROI saved for condition "+suffix+"."			Abort "{RecallImReg} Cannot find a polygon ROI saved for condition "+suffix+"."		endif		print "Getting image registration data for \""+suffix+"\"."	else		Print "{RecallImReg} Cannot find a reference image saved for condition "+suffix+"."		Abort "{RecallImReg}Cannot find a reference image saved for condition "+suffix+"."	endifEndFunction LS_ReviewImRegSlots()	WAVE/T	SuffixWave = SuffixWave		Variable	existsRef	Variable	existsMask	Variable	existsPolyROI	Variable	AllIsOkay = 1	String		suffix	Variable	n = numpnts(SuffixWave)	Variable	i	i = 0	do		suffix = SuffixWave[i]		if (Exists("ImRegRef"+suffix))			existsRef = 1			if (Strlen(Note($("ImRegRef"+suffix)))>0)				existsPolyROI = 1			else				existsPolyROI = 0			endif		else			existsRef = 0			existsPolyROI = 0		endif		if (Exists("ImRegMask"+suffix))			existsMask = 1		else			existsMask = 0		endif		if (!( (existsPolyROI) %& (existsRef) %& (existsMask) ))			AllIsOkay = 0		endif		print suffix,"existsRef="+num2str(existsRef),"existsPolyROI="+num2str(existsPolyROI),"existsMask="+num2str(existsMask)		i += 1	while(i<n)		if (AllIsOkay)		print "Everything seems okay with the stored Image Registration Data!"	else		print "Something is wrong with the stored Image Registration Data!"	endifEndFunction/S LS_GetPolyStrFromViewer()	String	polyStr = ""	NVAR	imRegCheckVar		// Note to self: Use DrawAction extractOutline in the future, so that user can employ rectangles or ovals or combinations thereof to select polygon ROI	DrawAction/W=ImageViewer2 getgroup=_all_,commands	Variable	foundStart = StrSearch(S_recreation,"DrawPoly",0)	if (foundStart>-1)		polyStr =  S_recreation[foundStart,StrSearch(S_recreation,"}",0)]	else		if (imRegCheckVar)			Print "WARNING! Could not find a polygon in the Red channel image!"			Beep		endif	endif	Return	PolyStrEnd/////////////////////////////////////////////////////////////////////////// Do the image registration// Reference image is in ImRegRef// Image registration masks are in ImRegMaskRef & ImRegMaskTestFunction LS_ImageReg()	SVAR		ImRegPolyStr	String		movedPolyStr = ""	Variable	foundStart = -1		Variable	startCoord	Variable	firstComma	Variable	secondComma		Variable	xCoord	Variable	yCoord	Variable	xCoordNew	Variable	yCoordNew		ImageRegistration/Q /CONV=0/ROT={0,0,0} /SKEW={0,0,0} /TRNS={1,1,0} testMask=ImRegMaskTest, refMask=ImRegMaskRef, testWave=TheImage2,refWave=ImRegRef	WAVE	W_RegParams	if (StrLen(ImRegPolyStr)>0)		startCoord = StrSearch(ImRegPolyStr," ",0)		firstComma = StrSearch(ImRegPolyStr,",",startCoord)		secondComma = StrSearch(ImRegPolyStr,",",firstComma+1)		xCoord = Str2Num(ImRegPolyStr[startCoord+1,firstComma-1])		yCoord = Str2Num(ImRegPolyStr[firstComma+1,secondComma-1])		xCoordNew = xCoord-W_RegParams[0]	// Negative sign because ROI is shifted from ref to test, whereas registration is done from test to ref		yCoordNew = yCoord-W_RegParams[1]		movedPolyStr = ""		movedPolyStr += "DrawPoly/W=ImageViewer2 "		movedPolyStr += num2str(xCoordNew)+","+num2str(yCoordNew)		movedPolyStr += ImRegPolyStr[secondComma,StrSearch(ImRegPolyStr,"}",0)]		print "Image registration shift by ("+num2str(W_RegParams[0])+","+num2str(W_RegParams[1])+") from ("+num2str(xCoord)+","+num2str(yCoord)+") to ("+num2str(xCoordNew)+","+num2str(yCoordNew)+")"		LS_PutPolyInViewer(movedPolyStr)		PickROIProc("")						// With empty string passed, this will pick only bitmap ROI, but not polygon ROI.	else		Print "{LS_ImageReg} Strange error: Found no polygon, as ImRegPolyStr is empty."		Abort "{LS_ImageReg} Strange error: Found no polygon, as ImRegPolyStr is empty."	endifEndFunction LS_PutPolyInViewer(polyStr)	String		polyStr	DoWindow/F ImageViewer2	if (V_flag==0)		print "{LS_ImageReg} strange error: ImageViewer2 window is not open."		Abort "{LS_ImageReg} strange error: ImageViewer2 window is not open."	endif	SetDrawLayer/W=ImageViewer2 ProgFront	DrawAction/W=ImageViewer2 delete//	DrawAction beginInsert=0				// Nasty bug -- won't draw polygon for ProgFront if you uncomment this line	SetDrawEnv linefgc= (65535,65535,0),fillpat= 0,xcoord= top,ycoord= left, save	Execute polyStrEnd/////////////////////////////////////////////////////////////////////////// Manage the recalling of ROIsFunction LS_StoreROIProc(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr		if (StrLen(popStr)>0)		print "Storing away ROI and BG for \""+popStr+"\""		StoreAwayROIs(popStr)	else		print "Empty string."	endif	EndFunction StoreAwayROIs(suffix)	String		suffix	// The regions of interest	WAVE/Z	TheROI	WAVE/Z	theBG	NVAR		LS_Left =					LS_Left	NVAR		LS_Right =					LS_Right	NVAR		BG_Left =					BG_Left	NVAR		BG_Right =					BG_Right	NVAR		F0_Upper =				F0_Upper	NVAR		F0_Lower =				F0_Lower		// Store the regions of interest	if (Exists("TheROI"))		Duplicate/O TheROI,$("TheROI"+suffix)		Duplicate/O theBG,$("theBG"+suffix)	else		Print "Does not exist:","TheROI"	endif	Make/O/N=6 $("LS_ROI_Data"+suffix)	WAVE	LS_ROI_Data = $("LS_ROI_Data"+suffix)	LS_ROI_Data[0] = {LS_Left,LS_Right,BG_Left,BG_Right,F0_Upper,F0_Lower}EndFunction RecallROIs(suffix)	String		suffix	// The regions of interest	WAVE/Z	TheROI	WAVE/Z	theBG	NVAR		LS_Left =					LS_Left	NVAR		LS_Right =				LS_Right	NVAR		BG_Left =					BG_Left	NVAR		BG_Right =				BG_Right	NVAR		F0_Upper =				F0_Upper	NVAR		F0_Lower =				F0_Lower		// Recall the regions of interest	if (Exists("TheROI"+suffix))		Duplicate/O $("TheROI"+suffix),TheROI		Duplicate/O $("theBG"+suffix),theBG	else		Print "Does not exist:","TheROI"+suffix	endif	WAVE	LS_ROI_Data = $("LS_ROI_Data"+suffix)	LS_Left = LS_ROI_Data[0]	LS_Right = LS_ROI_Data[1]	BG_Left = LS_ROI_Data[2]	BG_Right = LS_ROI_Data[3]	F0_Upper = LS_ROI_Data[4]	F0_Lower = LS_ROI_Data[5]End/////////////////////////////////////////////////////////////////////////// Show current image againFunction RefreshProc(ctrlName) : ButtonControl	String ctrlName	//	MakeLineScanPanel()	ProduceImage()	End	/////////////////////////////////////////////////////////////////////////// Edit the categoriesFunction KillDataTableProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K LS_DataTable	End	/////////////////////////////////////////////////////////////////////////// Kill the extracted dataFunction KillExtractedDataProc(ctrlName) : ButtonControl	String ctrlName		Variable	Kill = 0		WAVE/T	SuffixWave = SuffixWave		if (StringMatch(ctrlName,"KillExtractedDataButton"))		doAlert 1,"Really kill the data?"		Kill = V_flag		DoWindow $("Gr"+SuffixWave[0])		if ((Kill==1) %& (V_flag))			DoAlert 1,"Kill graphs too?"			if (V_flag==1)					ManageGraphsProc("Kill")			endif		endif	else		Print "{ReAnalyzeDataSetProc} killed old data."		Kill = 1	endif		if (Kill==1)		NVAR		nCategories = nCategories		SVAR		SuffixStr = SuffixStr		nCategories = 0		Make/T/O/N=(0) SuffixWave,LegendWave		SuffixStr = ""		Make/O/N=(0) MaxPeakWave,Pos1Wave,Pos2Wave,IntegralWave		Make/O/N=(0) pMaxPeakWave,pPos1Wave,pPos2Wave,pIntegralWave		Make/T/O/N=(0) RecallWaveListWave		Make/O/N=(0) SuffixStartWave,nFilesWave,IncrementWave		// Bugfix 2010-11-24 JSj//		print "Killed extracted data at "+Time()		ResetCumulWaves()	endif	End/////////////////////////////////////////////////////////////////////////// Edit/Show the extracted dataFunction ShowExtractedDataProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K LS_DataTable	Edit/W=(292,50,1210,168) SuffixWave,LegendWave,MaxPeakWave,Pos1Wave,Pos2Wave,IntegralWave,SuffixStartWave,nFilesWave,IncrementWave,RecallWaveListWave,pMaxPeakWave,pPos1Wave,pPos2Wave,pIntegralWave	DoWindow/C LS_DataTable	End/////////////////////////////////////////////////////////////////////////// Make simple bar graphFunction LS_MakeBarsProc(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr		WAVE/T		LegendWave	WAVE		w = $popStr		DoWindow/K	LS_BarGraph	Display /W=(150,200,550,400) $popStr vs LegendWave as popStr	DoWindow/C	LS_BarGraph	ModifyGraph lSize=2	ModifyGraph rgb=(0,0,0)	ModifyGraph hbFill=2	ModifyGraph usePlusRGB=1	ModifyGraph plusRGB=(16384,28160,65280)	ModifyGraph useNegRGB=1,negRGB=(16384,28160,65280)	Make/O/N=(0) dummyAxisW	AppendToGraph/R dummyAxisW	ModifyGraph fSize=14	SetAxis/A/N=1 left	DoUpdate	GetAxis/Q left	SetAxis right,V_min/w[0]*100,V_max/w[0]*100	Label right,"%"	 	Button UpdatePercButton, pos={0,2}, size={20,17},proc=UpdatePercProc, title="%",fSize=9,font="Arial"		Print popStr+":",LegendWave[0]+"/("+LegendWave[1]+"+"+LegendWave[2]+") = ",w[0]/(w[1]+w[2])*100,"%"	End	/////////////////////////////////////////////////////////////////////////// Update the right percentage axis manuallyFunction UpdatePercProc(ctrlName) : ButtonControl	String ctrlName	WAVE	w = $(StringFromList(0,TraceNameList("",";",1)))	GetAxis/Q left	SetAxis right,V_min/w[0]*100,V_max/w[0]*100	End/////////////////////////////////////////////////////////////////////////// Get preset ms-per-line value and store itFunction MsPerLinePopUpProc(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr		NVAR	dt = dt		dt = str2num(popStr[0,4])		if (!(StringMatch("fakeCall",ctrlName)))		print "\t\tNew scan rate & fill fraction: ",popStr	endif	End/////////////////////////////////////////////////////////////////////////// Automatically select the regions in the line scanFunction AutomaticRegionsProc(ctrlName) : ButtonControl	String ctrlName		NVAR		LeftBound	NVAR		RightBound	NVAR		LS_Left = LS_Left	NVAR		LS_Right = LS_Right	NVAR		BG_Left = BG_Left	NVAR		BG_Right = BG_Right	NVAR		F0_Upper = F0_Upper	NVAR		F0_Lower = F0_Lower//	NVAR		ImageWidth = ImageWidth//	WAVE		CurrentImage = CurrentImage//	Variable	nSDs = 1							// Number of standard deviations from center	Print "--- Automatically selecting the line scan regions ---"	// Check for shift key being pressed//	LeftBound = LS_Left//	RightBound = LS_Right	FitTheGaussian()	LS_Left = LeftBound	LS_Right = RightBound	BG_Left = Round(LeftBound*0.1)	BG_Right = Round(LeftBound*0.9)	print "\tDraw lines"	DrawLines2()	// If AutoRegionsGraph is exists, then update it	DoWindow AutoRegionsGraph	if (V_flag)		MakeAutoRegionsGraph()	endif	Print "--- Done ---"EndFunction MakeAutoRegionsGraph()		DoMakeAutoRegionsGraph(0)EndFunction DoMakeAutoRegionsGraph(which)	Variable	which	NVAR		LeftBound	NVAR		RightBound		String		GrName = "AutoRegionsGraph"	String		wName = "OneLine"	String		Suffix = ""	Variable	shift = 32		if (which==1)		Suffix = "_green"	endif	if (which==2)		Suffix = "_red"	endif		if (which!=0)		Duplicate/O $(wName),$(wName+Suffix)		Duplicate/O $("fit_"+wName),$("fit_"+wName+Suffix)		GrName+=Suffix		wName+=Suffix	endif	DoWindow/K $(GrName)	Display/W=(847+Shift*which,44+Shift*which,1242+Shift*which,252+Shift*which) $(wName) as "Auto regions graph - "+Suffix[1,strlen(Suffix)-1]	DoWindow/C $(GrName)	AppendToGraph $("fit_"+wName)	ModifyGraph lsize($("fit_"+wName))=2	ModifyGraph RGB($("fit_"+wName))=(0,0,0)		Variable	PercentExtend = 200	Variable	LeftFocus = LeftBound-abs(RightBound-LeftBound)*PercentExtend/100	Variable	RightFocus = RightBound+abs(RightBound-LeftBound)*PercentExtend/100		SetAxis bottom,LeftFocus,RightFocus		SetDrawEnv xcoord= bottom,linefgc= (0,0,65535),linethick= 2.00	DrawLine LeftBound,0,LeftBound,1	SetDrawEnv xcoord= bottom,linefgc= (0,0,65535),linethick= 2.00	DrawLine RightBound,0,RightBound,1End/////////////////////////////////////////////////////////////////////////// Operate on top graph, duplicate the waves and add a tag at the end of the wavesFunction DuplicateItProc(ctrlName) : ButtonControl	String ctrlName	DoWindow/K EnterConditionPanel	NewPanel/K=1 /W=(150,50+40,496,80+40)	DoWindow/C EnterConditionPanel	SetVariable EnterConditionSetVar,pos={2,2},size={325,19},title="Enter condition:"	SetVariable EnterConditionSetVar,fSize=14,fStyle=1,limits={0,0,0},barmisc={0,1000}	SetVariable EnterConditionSetVar,value=ConditionStr,proc=ConditionStrWasTouchedProcEndFunction AnalyzeAverageProc(ctrlName) : ButtonControl	String ctrlName		NVAR		nCategories = nCategories	WAVE/T	SuffixWave = SuffixWave	WAVE/T	LegendWave = LegendWave	WAVE		MaxPeakWave = MaxPeakWave	WAVE		Pos1Wave = Pos1Wave	WAVE		Pos2Wave = Pos2Wave	WAVE		IntegralWave = IntegralWave	NVAR		mWinWidth = mWinWidth	NVAR		fixPos1 = fixPos1	NVAR		fixPos2 = fixPos2	NVAR		baseStart = baseStart	NVAR		baseWin = baseWin	NVAR		MaxLoc = MaxLoc	NVAR		BaseVal = BaseVal	NVAR		MaxVal = MaxVal	NVAR		Pos1Val = Pos1Val	NVAR		Pos2Val = Pos2Val	NVAR		IntegralVal = IntegralVal	SVAR		ConditionStr = ConditionStr	NVAR		Calc_mode = Calc_mode		SVAR		ListOfAnalyzedWaves = ListOfAnalyzedWaves	//	Print "--- Extracting data ---"	WAVE		meanWave = meanWave	Variable	peakVal//	ctrlName == "AnalyzeAverageButton"//	WAVE		SEMWaveU = SEMWaveU	// wParams[0] -- MaxLoc	// wParams[1] -- baseVal	// wParams[2] -- MaxVal	// wParams[3] -- Pos1Val	// wParams[4] -- Pos2Val	DoMeasureWave("meanWave")	WAVE		wParams = wParams		// DoMeasureWave returns results here	MaxLoc = wParams[0]					// Position of peak	baseVal = wParams[1]					// Baseline value	MaxVal = wParams[2]					// Value at peak	Pos1Val = wParams[3]					// Position 1 value	Pos2Val = wParams[4]					// Position 2 value	IntegralVal = wParams[5]				// Value of integral//	print "\tIn averaged trace: Peak value ",MaxVal,"was found at",maxLoc," ms"		Variable	i	Variable	nWaves = ItemsInList(ListOfAnalyzedWaves)	String		CurrentWaveStr		if (nWaves>0)		ResetCumulWaves()		WAVE		CumulMaxPeakWave		WAVE		CumulMaxLocWave		WAVE		CumulbaseValWave		WAVE		CumulPos1Wave		WAVE		CumulPos2Wave		WAVE		CumulIntegralWave		WAVE		CumulSuffixWave		WAVE		CumulGroupTagWave				NVAR		CumulCounter = CumulCounter				NVAR/Z		mainLoop = mainLoop							// Provides a reference to the outer mainloop	//		Print "\tAnalyzing individual waves now"		i = 0		do			CurrentWaveStr = StringFromList(i,ListOfAnalyzedWaves)//			WAVE	w = $CurrentWaveStr			DoMeasureWave(CurrentWaveStr)			WAVE		wParams = wParams						// DoMeasureWave returns results here			CumulMaxLocWave[CumulCounter] = {wParams[0]}		// Position of peak			CumulbaseValWave[CumulCounter] = {wParams[1]}		// Baseline value			CumulMaxPeakWave[CumulCounter] = {wParams[2]	}	// Value at peak			CumulPos1Wave[CumulCounter] = {wParams[3]}		// Position 1 value			CumulPos2Wave[CumulCounter] = {wParams[4]}		// Position 2 value			CumulIntegralwave[CumulCounter] = {wParams[5]}		// Value of integral			CumulSuffixWave[CumulCounter] = {Str2Num(CurrentWaveStr[StrLen(CurrentWaveStr)-7,StrLen(CurrentWaveStr)-5])}			CumulGroupTagWave[CumulCounter] = {mainLoop}			CumulCounter += 1			i += 1		while(i<nWaves)	else		Print "Strange error: ListOfAnalyzedWaves is empty"	endif	DoWindow/F MultiAnalGraph	PutDataInPlot()End/////////////////////////////////////////////////////////////////// Measure stats in wave and return resultsFunction DoMeasureWave(theWaveName)	String		theWaveName	NVAR		mWinWidth = mWinWidth	NVAR		fixPos1 = fixPos1	NVAR		fixPos2 = fixPos2	NVAR		baseStart = baseStart	NVAR		baseWin = baseWin	NVAR		IntegralStart = IntegralStart	NVAR		IntegralEnd = IntegralEnd		Variable	PeakSearchSmoothVal = 5			// When searching for the peak value, first box-smooth the wave by this much	Make/O/N=(6) wParams		// wParams[0] -- MaxLoc	// wParams[1] -- baseVal	// wParams[2] -- MaxVal	// wParams[3] -- Pos1Val	// wParams[4] -- Pos2Val	// wParams[5] -- IntegralVal	Duplicate/O meanWave,DummyWave	Smooth/B	PeakSearchSmoothVal,DummyWave	WaveStats/Q DummyWave	wParams[0] = V_maxloc*1000				// Position of peak in smoothed wave	// Extract all other parameters in the original wave	Variable peakVal = mean($(theWaveName),(wParams[0]+mWinWidth/2)/1000,(wParams[0]+mWinWidth/2)/1000)	wParams[1] = mean($(theWaveName),baseStart/1000,(baseStart+baseWin)/1000)	wParams[2] = peakVal-wParams[1]	wParams[3] = mean($(theWaveName),fixPos1/1000,(fixPos1+mWinWidth)/1000)-wParams[1]	wParams[4] = mean($(theWaveName),fixPos2/1000,(fixPos2+mWinWidth)/1000)-wParams[1]	wParams[5] = area($(theWaveName),IntegralStart/1000,IntegralEnd/1000)/(IntegralEnd/1000-IntegralStart/1000) // Normalized area	End/////////////////////////////////////////////////////////////////// Plot extracted data in the MultiAnalGraph windowFunction PutDataInPlot()	NVAR		mWinWidth = mWinWidth	NVAR		fixPos1 = fixPos1	NVAR		fixPos2 = fixPos2	NVAR		baseStart = baseStart	NVAR		baseWin = baseWin	NVAR		MaxLoc = MaxLoc	NVAR		baseVal = baseVal	NVAR		MaxVal = MaxVal	NVAR		Pos1Val = Pos1Val	NVAR		Pos2Val = Pos2Val	NVAR		LS_RunningScanArea		if (LS_RunningScanArea==0)		SetDrawLayer /K UserFront		SetDrawLayer UserFront		SetDrawEnv xcoord= bottom,ycoord= left,linethick= 4,linefgc= (65535,0,0)		// Baseline		DrawLine baseStart/1000,baseVal,(baseStart+baseWin)/1000,baseVal		SetDrawEnv xcoord= bottom,ycoord= left,textrgb= (65535,0,0),fsize= 9;DelayUpdate		DrawText (baseStart+baseWin)/1000,baseVal," base: "+num2str(baseVal)			SetDrawEnv xcoord= bottom,ycoord= left,linethick= 4,linefgc= (65535,0,0)		// maxLoc		DrawLine (maxLoc-mWinWidth/2)/1000,BaseVal+MaxVal,(maxLoc+mWinWidth/2)/1000,BaseVal+MaxVal		SetDrawEnv xcoord= bottom,ycoord= left,textrgb= (65535,0,0),fsize= 9;DelayUpdate		DrawText (maxLoc+mWinWidth/2)/1000,BaseVal+MaxVal," peak: "+num2str(MaxVal)				SetDrawEnv xcoord= bottom,ycoord= left,linethick= 4,linefgc= (0,65535,0)		// Pos1		DrawLine fixPos1/1000,Pos1Val+baseVal,(fixPos1+mWinWidth)/1000,Pos1Val+baseVal		SetDrawEnv xcoord= bottom,ycoord= left,textrgb= (0,65535,0),fsize= 9;DelayUpdate		DrawText (fixPos1+mWinWidth)/1000,Pos1Val+baseVal," pos 1: "+num2str(Pos1Val)			SetDrawEnv xcoord= bottom,ycoord= left,linethick= 4,linefgc= (0,65535,0)		// Pos2		DrawLine fixPos2/1000,Pos2Val+baseVal,(fixPos2+mWinWidth)/1000,Pos2Val+baseVal		SetDrawEnv xcoord= bottom,ycoord= left,textrgb= (0,65535,0),fsize= 9;DelayUpdate		DrawText (fixPos2+mWinWidth)/1000,Pos2Val+baseVal," pos 2: "+num2str(Pos2Val)	endifEnd// OLD NOTATION//Function ConditionStrWasTouchedProc(ctrlName,varNum,varStr,varName) : SetVariableControl//	String		ctrlName//	Variable		varNum//	String		varStr//	String		varName//	//	print ctrlName,varNum,varStr,varName////EndFunction ConditionStrWasTouchedProc(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update			Variable dval = sva.dval			String sval = sva.sval			doConditionStrWasTouched(0)			// The zero is arbitrary here, because LS_doOneOnly should be zero.			break		case -1: // control being killed			break	endswitch	return 0EndFunction doConditionStrWasTouched(varNum)	Variable		varNum		NVAR		doOneOnly = LS_doOneOnly		Variable	doThisOneOnly = varNum			// Only doing one condition when reanalyzing -- special case to save time (popNum, not an index, so use -1 to get to wave index!)//	Variable	doOneOnly = doThisOneOnly > 0		SVAR		SuffixStr = SuffixStr		NVAR		nCategories = nCategories	WAVE/T		SuffixWave = SuffixWave	WAVE/T		LegendWave = LegendWave	WAVE		MaxPeakWave = MaxPeakWave	WAVE		Pos1Wave = Pos1Wave	WAVE		Pos2Wave = Pos2Wave	WAVE		IntegralWave = IntegralWave		WAVE		GR_Wave = GR_Wave	WAVE		SuffixStartWave = SuffixStartWave	WAVE		nFilesWave = nFilesWave	WAVE		IncrementWave = IncrementWave	NVAR		MaxVal = MaxVal	NVAR		Pos1Val = Pos1Val	NVAR		Pos2Val = Pos2Val	NVAR		IntegralVal = IntegralVal	SVAR		ConditionStr = ConditionStr	if (StringMatch(ConditionStr,"__LS"))		print "The condition string \"__LS\" is reserved, please choose another name."		Abort "The condition string \"__LS\" is reserved, please choose another name."	endif	NVAR		Calc_mode = Calc_mode		NVAR		FileNum = FileNum	NVAR		Multi_nFiles = Multi_nFiles	NVAR		Multi_SuffIncr = Multi_SuffIncr	NVAR		LS_ReanalyzingData		NVAR		ImRegCheckVar	NVAR		FrameFlag		StoreAwayROIs(ConditionStr)	if (!(LS_ReanalyzingData))		if (FrameFlag)			if (ImRegCheckVar)				StoreAwayImReg(ConditionStr)			endif		endif	endif	// Remember the list of waves that were averaged		WAVE/T	RecallWaveListWave = RecallWaveListWave	SVAR		ListOfAnalyzedWavesC = ListOfAnalyzedWavesC		// Comma-separated list of the waves that were averaged and analyzed		AnalyzeAverageProc("")	//	Print "--- Inserting data in table ---"	if (!(doOneOnly))		SuffixWave[nCategories] = {ConditionStr}		SuffixStr += ConditionStr+";"		if (StringMatch(ConditionStr[0],"_"))					// The user should subsitute this string with something else by editing the Extracted Data table			LegendWave[nCategories] = {ConditionStr[1,StrLen(ConditionStr)]}		else			LegendWave[nCategories] = {ConditionStr}		endif	endif	// Extract values from the averaged trace to ensure smoothing is accounted for	if (doOneOnly)		MaxPeakWave[doThisOneOnly-1] = MaxVal		Pos1Wave[doThisOneOnly-1] = Pos1Val		Pos2Wave[doThisOneOnly-1] = Pos2Val		IntegralWave[doThisOneOnly-1] = IntegralVal	else		MaxPeakWave[nCategories] = {MaxVal}		Pos1Wave[nCategories] = {Pos1Val}		Pos2Wave[nCategories] = {Pos2Val}		IntegralWave[nCategories] = {IntegralVal}	endif		// Extract p values from individual sweeps	WAVE	CumulMaxPeakWave						StatsTTest/Q/MEAN=0 CumulMaxPeakWave	WAVE/Z	W_StatsTTest	WAVE		pMaxPeakWave	if (doOneOnly)		pMaxPeakWave[doThisOneOnly-1] = W_StatsTTest[9]	else		pMaxPeakWave[nCategories] = {W_StatsTTest[9]}	endif		WAVE	CumulPos1Wave						StatsTTest/Q/MEAN=0 CumulPos1Wave	WAVE		pPos1Wave	if (doOneOnly)		pPos1Wave[doThisOneOnly-1] = W_StatsTTest[9]	else		pPos1Wave[nCategories] = {W_StatsTTest[9]}	endif		WAVE	CumulPos2Wave						StatsTTest/Q/MEAN=0 CumulPos2Wave	WAVE		pPos2Wave	if (doOneOnly)		pPos2Wave[doThisOneOnly-1] = W_StatsTTest[9]	else		pPos2Wave[nCategories] = {W_StatsTTest[9]}	endif		WAVE	CumulIntegralwave						StatsTTest/Q/MEAN=0 CumulIntegralwave	WAVE		pIntegralWave	if (doOneOnly)		pIntegralWave[doThisOneOnly-1] = W_StatsTTest[9]	else		pIntegralWave[nCategories] = {W_StatsTTest[9]}	endif	// Use these waves to reanalyze the entire set of data		if (doOneOnly)		SuffixStartWave[doThisOneOnly-1] = FileNum		nFilesWave[doThisOneOnly-1] = Multi_nFiles		IncrementWave[doThisOneOnly-1] = Multi_SuffIncr		RecallWaveListWave[doThisOneOnly-1] = ListOfAnalyzedWavesC[0,StrLen(ListOfAnalyzedWavesC)-2]//		nCategories += 1	else		SuffixStartWave[nCategories] = {FileNum}		nFilesWave[nCategories] = {Multi_nFiles}		IncrementWave[nCategories] = {Multi_SuffIncr}		RecallWaveListWave[nCategories] = {ListOfAnalyzedWavesC[0,StrLen(ListOfAnalyzedWavesC)-2]}		nCategories += 1	endif	DoWindow/K EnterConditionPanel	String		ListOfTraces = WaveList("*",";","WIN:")	Variable	nTraces = ItemsInList(ListOfTraces)	String		currTraceName	String		newTraceName	Variable	i		Variable	xPos = 540	Variable	yPos = 50	Variable	Width = 300	Variable	Height = 200	Variable	ySpacing = 24	Variable	xSpacing = 12		Duplicate/O GR_Wave,$("GR_Wave"+ConditionStr)			// Baseline G/R should not change over time -- keep track of it here		NVAR		LS_RunningScanArea		Variable	plotPos = nCategories		if (doOneOnly)		plotPos = doThisOneOnly	endif	if (LS_RunningScanArea==0)		DoWindow/K $("Gr"+ConditionStr)		Display /W=(xPos+mod((plotPos-1),4)*xSpacing,yPos+(plotPos-1)*ySpacing,xPos+mod((plotPos-1),4)*xSpacing+Width,yPos+(plotPos-1)*ySpacing+Height) as "Condition"+ConditionStr		DoWindow/C $("Gr"+ConditionStr)	endif	i = 0	do		currTraceName = StringFromList(i,ListOfTraces)		newTraceName = currTraceName+ConditionStr		print "\tDuplicating \""+currTraceName+"\" to \""+newTraceName+"\"."		Duplicate/O $currTraceName,$newTraceName		if (LS_RunningScanArea==0)			AppendToGraph $newTraceName			if ( (i==0) %| (i==1))				ModifyGraph rgb($newTraceName)=(32503,33032,65535)				ModifyGraph lStyle($newTraceName)=1			endif			if (i==2)				ModifyGraph lSize($newTraceName)=3				ModifyGraph rgb($newTraceName)=(0,0,65535)			endif		endif		i  += 1	while (i<nTraces)	if (LS_RunningScanArea==0)		ModifyGraph fSize=14		if (Calc_mode == 0)			Label left "dG/G"		endif		if (Calc_mode == 1)			Label left "dG/R"		endif		Label bottom "time [s]"		SetAxis Bottom,0,0.5		DoUpdate		ControlBar 22	 	Button KillItButton, pos={0,2}, size={20,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	Button ZoomInButton, pos={24,2}, size={20,17},proc=ZoomInProc, title="Z",fSize=10,font="Arial"		Button AutoYRangeButton, pos={2+24+24,2}, size={20,17},proc=AutoYRangeProc, title="A",fSize=10,font="Arial"		PutDataInPlot()	endifEnd/////////////////////////////////////////////////////////////////////////// Figure out which suffices we do NOT want to include in the averages...Function SkipThisSuffix(theSuffix)	Variable	theSuffix		NVAR		NPointsToIgnore =		NPointsToIgnore	NVAR		IvalStart =				IvalStart								// Start of an interval of points to ignore	NVAR		IvalEnd =				IvalEnd									// End of an interval of points to ignore	WAVE		SuffToIgnoreWave =		SuffToIgnoreWave		Variable	i		Variable	ThisPointShouldBeIgnored = 0		// Check if this suffix is in the list of bad suffices...	if (NPointsToIgnore>0)		do			if (theSuffix == SuffToIgnoreWave[i])					// A suffix to ignore was found				ThisPointShouldBeIgnored = 1						// Set boolean flag to true...				i = Inf												// ... and exit the search loop			endif			i += 1		while (i<NPointsToIgnore)	endif	// Also check the interval... suffix within interval?	if ( (theSuffix>=IvalStart) %& (theSuffix<=IvalEnd) )		ThisPointShouldBeIgnored = 1							// Set boolean flag to true...	endif		Return		ThisPointShouldBeIgnoredEnd/////////////////////////////////////////////////////////////////////////// Analyze and average multiple linescansFunction MultiAnalysisProc(ctrlName) : ButtonControl	String ctrlName	NVAR		LS_RunningScanArea	if (LS_RunningScanArea==0)		Print "--- Starting MultiAnalysis ---"	endif		NVAR		Multi_nFiles = Multi_nFiles	NVAR		Multi_SuffIncr = Multi_SuffIncr		NVAR		FileNum = FileNum	NVAR		ImageWidth = ImageWidth	NVAR		ImageHeight = ImageHeight	NVAR		FileNum = FileNum	NVAR		CurrentChannel = CurrentChannel	SVAR		ImageData = ImageData	SVAR		BaseName = BaseName	SVAR		FileNumStr = FileNumStr	SVAR		PathName = PathName	SVAR		ImageFileName = ImageFileName		NVAR		Calc_mode = Calc_mode	SVAR		dFData													// Name of analyzed data		Variable	i,j	Variable	SuffixCounter = FileNum	Variable	StoreFileNum = FileNum		NVAR		LS_ReanalyzingData = LS_ReanalyzingData		String/G	ListOfAnalyzedWaves = ""	String/G	ListOfAnalyzedWavesC = ""								// Same, but with commas as separator, for pretty & useful output	// Variables for the progress bar	NVAR		Progress_Val = Progress_Val	NVAR		Progress_Counter = Progress_Counter	NVAR		Progress_Max = Progress_Max	SVAR		Progress_MessageStr = Progress_MessageStr		// Frame analysis	NVAR		frameFlag	NVAR		nFrames	WAVE/Z	AllImage1	WAVE/Z	AllImage2	WAVE/Z	AllImageRAW	// Image registration		NVAR		ImRegCheckVar	// Look for bleaching	NVAR/Z		firstG,lastG 	NVAR/Z		firstR,lastR 	Make/O/N=(0) firstGwave,bleachGwave,firstRwave,bleachRwave		// If selected, prefilter with this amount	NVAR		PreSmoothVal		Variable	PreFilter = 0	ControlInfo/W=LineScanAnalysis PreSmoothTracesCheck	if (V_flag==2)		PreFilter = V_value	else		Print "{PreSmoothTracesCheck} missing Ñ restart LineScanAnalysis panel."		Abort "{PreSmoothTracesCheck} missing Ñ restart LineScanAnalysis panel."	endif	if (LS_RunningScanArea==0)		Print "\tLoading & analyzing the data"		if (PreFilter)			Print "\tPrefiltering the data with box size "+num2str(PreSmoothVal)+"."		endif	endif		Progress_Max = Multi_nFiles	if (LS_RunningScanArea==0)		LS_MakeProgressBar()		LS_UpdateProgressBar(0,"Loading and analyzing data...")	endif	Make/O/N=(0)	GR_Wave												// Baseline fluorescence//	NVAR		GR	String aveFrameName = ""		Variable	notDoneFirst = 1		i = 0	do		Progress_Counter = i		if (LS_RunningScanArea==0)			LS_UpdateProgressBar(Progress_Counter/Progress_Max,"Loading and analyzing data...")		endif		DoWindow/H/F		FileNum = SuffixCounter		FileNum2FileNumStr()		ImageFileName = BaseName + FileNumStr + ".tif"		ImageData = ImageFileName[0, strlen(ImageFileName)-5]		if (SkipThisSuffix(SuffixCounter))			Print "\t\t",i+1,"Skipping this file:",ImageFileName		else//			Print "\t\t",i+1,"Analyzing file:",ImageFileName			if ( (frameFlag) %& (ImRegCheckVar) )				DoTheLoadImage("ShowImage")								// If doing Image Registration, then we need to operate on the image graphs			else				DoTheLoadImage("DoNotShowImage")			endif//			if (frameFlag)				if (notDoneFirst)					aveFrameName = BaseName + FileNumStr					Duplicate/O AllImageRAW,$(aveFrameName+"_avg")					WAVE target = $(aveFrameName+"_avg")					notDoneFirst = 0				else					target += AllImageRAW				endif				if ((frameFlag) %& (ImRegCheckVar))						// Only do image registration if doing a framescan					LS_ImageReg()				endif//			endif			LineScan2("Analyze")			ReadFirstAndLastFluorescence()									// Look for bleaching//			print "Bleaching",firstG,firstR			firstGwave[numpnts(firstGwave)] = {firstG}			bleachGwave[numpnts(bleachGwave)] = {lastG/firstG}			firstRwave[numpnts(firstRwave)] = {firstR}			bleachRwave[numpnts(bleachRwave)] = {lastR/firstR}			ListOfAnalyzedWaves += dFData+";"			ListOfAnalyzedWavesC += dFData+","			if (PreFilter)				Smooth/B PreSmoothVal,$dFData							// Prefilter the data			endif		endif		SuffixCounter += Multi_SuffIncr		i += 1	while(i<Multi_nFiles)//	if ( (frameFlag) %& (!(LS_RunningScanArea)) )	if (!(LS_RunningScanArea))		print "-- Saving average --"		target /= ItemsInList(ListOfAnalyzedWaves)		SVAR	RAT_Str//		WAVE/T	T_Tags = root:T_Tags			// Use most recent tag wave as tag -- WARNING! possibly not entirely correct!//		T_Tags[5][4] = RAT_Str//		DeletePoints 0,5, T_Tags//		DeletePoints 1,9, T_Tags		Make/T/O/N=(1,5) myTags								// JSj 25 Mar 2020: Not 100% sure this will work beyond SI v3.7, but does it even matter?		myTags[0][0] = "270"									// Tag number		myTags[0][1] = "IMAGEDESCRIPTION"				// Tag description		myTags[0][2] = "2"									// Type: ASCII		myTags[0][3] = Num2Str(StrLen(RAT_Str)+1)	// Data length plus space for NUL byte		myTags[0][4] = RAT_Str+"\0"						// String TIFF tags must end with NUL byte		PathInfo home		if (StrLen(S_Path)!=0)			Print "Saving averaged stacks to home path as \""+aveFrameName+"_avg.tif\"."			ImageSave/O/D=16/S/T="tiff"/P=home/WT=myTags $(aveFrameName+"_avg") as aveFrameName+"_avg.tif"		else			Print "Saving averaged stacks to source path as \""+aveFrameName+"_avg.tif\"."			ImageSave/O/D=16/S/T="tiff"/P=ImagePath/WT=myTags $(aveFrameName+"_avg") as aveFrameName+"_avg.tif"		endif	endif		if (LS_RunningScanArea==0)		LS_UpdateProgressBar(1,"Loading and analyzing data...")		LS_KillProgressBar()		Print "\tAveraging the waves"	endif		DoWindow/K MultiAnalGraph	Progress_Max = ImageHeight-1	if (LS_RunningScanArea==0)		LS_MakeProgressBar()		LS_UpdateProgressBar(0,"Averaging the waves...")	endif	Duplicate/O $(dFData),meanWave,SEMWaveU,SEMWaveL			// Just duplicate the original wave to get the wave scaling and number of data points right	meanWave = 0	SEMWaveU = 0	SEMWaveL = 0	String	CurrentWaveStr		Variable	nForSEM = 0		if (LS_RunningScanArea==0)		Print "These are the waves to be averaged:",ListOfAnalyzedWavesC[0,StrLen(ListOfAnalyzedWavesC)-2]	endif		Variable k = 0	Variable updateEvery = floor(ImageHeight/10)				// Update progress bar 10 times during averaging (updating progress itself bar takes time)	Variable endOfLoop = ImageHeight-1	if (frameFlag)		endOfLoop = nFrames-1	endif	j = 0	do		Progress_Counter = j		k += 1		if (LS_RunningScanArea==0)			if (mod(k,updateEvery)==0)				LS_UpdateProgressBar(Progress_Counter/Progress_Max,"Averaging the waves...")			endif		endif		Make/O/N=(1) WorkWave		i = 0		do			CurrentWaveStr = StringFromList(i,ListOfAnalyzedWaves)			WAVE	w = $CurrentWaveStr			WorkWave[i] = {w[j]}			i += 1		while(i<ItemsInList(ListOfAnalyzedWaves))		WaveStats/Q WorkWave		meanWave[j] = V_avg		SEMWaveU[j] = V_avg+V_SDev/sqrt(V_npnts)		SEMWaveL[j] = V_avg-V_SDev/sqrt(V_npnts)		j += 1	while(j<endOfLoop)	meanWave[0] = meanWave[1]							// meanWave[0] is always NaN -- avoid bug by transplanting the number after it	SEMWaveU[0] = SEMWaveU[1]	SEMWaveL[0] = SEMWaveL[1]	if (LS_RunningScanArea==0)		LS_KillProgressBar()	endif		//// Make the graph	if (LS_RunningScanArea==0)		print "\tMaking graphs"		DoWindow/K MultiAnalGraph		Display /W=(292,50+26+300,1056-300+100,621-200+300) SEMWaveU,SEMWaveL,meanWave		DoWindow/C MultiAnalGraph		ModifyGraph lSize(meanWave)=3		ModifyGraph lStyle(SEMWaveU)=1		ModifyGraph rgb(meanWave)=(0,0,65535),rgb(SEMWaveU)=(32503,33032,65535),rgb(SEMWaveL)=(32503,33032,65535)		modifygraph fSize=18		label bottom,"time [s]"		if (Calc_mode==0)			label left,"dG/G"		endif		if (Calc_mode==1)			label left,"dG/R"		endif		ControlBar 22	 	Button KillItButton, pos={2,2}, size={20,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	Button AnalyzeAverageButton, pos={2+4+20,2}, size={60,17},proc=AnalyzeAverageProc, title="Analyze",fSize=10,font="Arial"	 	Button DuplicateItButton, pos={2+4+20+4+60,2}, size={70,17},proc=DuplicateItProc, title="Duplicate",fSize=10,font="Arial"	 	Button ZoomInButton, pos={2+4+20+4+60+70+4,2}, size={70,17},proc=ZoomInProc, title="Zoom in",fSize=10,font="Arial"		Button AutoYRangeButton, pos={2+4+20+4+60+70+4+70+4,2}, size={40,17},proc=AutoYRangeProc, title="AutoY",fSize=10,font="Arial"		ModifyGraph zero(left)=2	endif 		//// Restore variables & revert to original image	FileNum = StoreFileNum	FileNum2FileNumStr()	ImageFileName = BaseName + FileNumStr + ".tif"	ImageData = ImageFileName[0, strlen(ImageFileName)-5]	if (!(LS_ReanalyzingData))		if ( (frameFlag) %& (ImRegCheckVar) )			DoTheLoadImage("ShowImage")		else			DoTheLoadImage("DoNotShowImage")		endif	else		KillFrameViewProc("")	endif		if (LS_RunningScanArea==0)		Print "--- MultiAnalysis done ---"	endif	End/////////////////////////////////////////////////////////////////////////// Shuffle data points in top graph, to see them in temporal orderFunction LS_ShuffleProc(ctrlName) : ButtonControl	String ctrlName		String		TraceList = TraceNameList("",";",1)	Print "The list:",TraceList	String		currTrace	Variable	nTraces = ItemsInList(TraceList)	Variable	n = numpnts($(StringFromList(0,TraceList)))	Variable	nIsNotTheSame = 0	Variable	i,j	i = 0	do		currTrace = StringFromList(i,TraceList)		if (numpnts($(StringFromList(i,TraceList)))!=n)			i = inf			nIsNotTheSame = 1		endif		i += 1	while(i<nTraces)		if (nIsNotTheSame)		Print "N is not the same in those traces -- cannot reshuffle"	else		Make/O/N=(n*nTraces) ReshuffleWave,ReshuffleX,ReshuffleSym		Make/O/N=(3) symWave = {19,16,6}		ReshuffleX = p		j = 0		do			i = 0			do				currTrace = StringFromList(i,TraceList)				WAVE w = $(currTrace)				ReshuffleWave[j*nTraces+i] = w[j]				ReshuffleSym[j*nTraces+i] = symWave[i]				i += 1			while(i<nTraces)			j += 1		while(j<n)		DoWindow/K ReshuffleGraph		qp("ReshuffleWave","ReshuffleX")		nw("ReshuffleGraph")		label left,"signal"		label bottom,"iteration #"		ModifyGraph zmrkNum(ReshuffleWave)={ReshuffleSym}		ControlBar 22		Variable bx = 2	 	Button KillItButton, pos={bx,2}, size={20,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	bx += 22	 	Button EditButton, pos={bx,2}, size={32,17},proc=LS_EditProc, title="Edit",fSize=10,font="Arial"	 	bx += 32			endif	End/////////////////////////////////////////////////////////////////////////// Test third wave in graph vs the number zero// to see if AP-mediated calcium signal is different from zeroFunction LS_3rdVsZeroProc(ctrlName) : ButtonControl	String ctrlName		String	wList = wavelist("*",";","WIN:CaSigOverTime")	String	thirdWaveStr = StringFromList(2,wList)	if (StrLen(thirdWaveStr)==0)		print "There is no third wave, so cannot do this test."		return -1	else		WAVE	w = $thirdWaveStr		print "--- T-test for \""+thirdWaveStr+"\" vs. Zero:"		WaveStats/Q w		print "µ ± SEM:\t"+num2str(V_avg)+"\t"+num2str(V_SEM)		if (StrLen(ctrlName)>0)			print "\t(The mean and SEM are on the clipboard now.)"			PutScrapText num2str(V_avg)+"\t"+num2str(V_SEM)		endif		StatsTTest/Mean=0/Q w		WAVE	W_StatsTTest		print "p =",W_StatsTTest[7]		Return W_StatsTTest[7]	endif	End	/////////////////////////////////////////////////////////////////////////// Produce table of waves in top graphFunction LS_EditProc(ctrlName) : ButtonControl	String ctrlName		JT_EditTopGraphWaves()	End	/////////////////////////////////////////////////////////////////////////// Kill the top graph, table, or layoutFunction KillItProc(ctrlName) : ButtonControl	String ctrlName		Print "Killing the window named \""+WinName(0,7)+"\"."	DoWindow/K $(WinName(0,7))	End	////////////////////////////////////////////////////////// Convert the file suffix number to a stringFunction FileNum2FileNumStr()	NVAR	FileNum = FileNum	SVAR	FileNumStr = FileNumStr	if (FileNum < 10)		FileNumStr = "00" + num2str(FileNum)		elseif (FileNum >=10 && FileNum <100)			FileNumStr = "0" + num2str(FileNum)		else			FileNumStr = num2str(FileNum)	endif	End	/////////////////////////////////////////////////////////////////////////// Grab boundaries for the linescan, the background, and for the F0 readingsFunction LS_GrabProc(ctrlName) : ButtonControl	String ctrlName		NVAR	LS_Left = LS_Left	NVAR	LS_Right = LS_Right		DoWindow ImageViewer	if (V_flag==0)		Abort "Load image first -- no image to operate on..."	endif		LS_left = hcsr(A,"ImageViewer")	LS_right = hcsr(B,"ImageViewer")		DrawLines2()EndFunction BG_GrabProc(ctrlName) : ButtonControl	String ctrlName		NVAR	BG_Left = BG_Left	NVAR	BG_Right = BG_Right		DoWindow ImageViewer	if (V_flag==0)		Abort "Load image first -- no image to operate on..."	endif		BG_Left = hcsr(A,"ImageViewer")	BG_Right = hcsr(B,"ImageViewer")	DrawLines2()EndFunction F0_GrabProc(ctrlName) : ButtonControl	String ctrlName		NVAR	F0_Upper = F0_Upper	NVAR	F0_Lower = F0_Lower		DoWindow ImageViewer	if (V_flag==0)		Abort "Load image first -- no image to operate on..."	endif		F0_Upper = vcsr(A,"ImageViewer")	F0_Lower = vcsr(B,"ImageViewer")	DrawLines2()End//************************************************************************************// Open TIFF imagefile////************************************************************************************Function LoadImage2(ctrlName) : ButtonControl	String ctrlName		Variable dumvar		NVAR	ImageWidth = ImageWidth	NVAR	ImageHeight = ImageHeight	NVAR	FileNum = FileNum	NVAR	CurrentChannel = CurrentChannel	SVAR	ImageData = ImageData	SVAR	BaseName = BaseName	SVAR	FileNumStr = FileNumStr	SVAR	PathName = PathName	SVAR	ePhysPathName = ePhysPathName	SVAR	ShowPathName = ShowPathName	String	CurrentImageFile	SVAR	ImageFileName = ImageFileName	WAVE	CurrentImage = CurrentImage	WAVE	AllImage = AllImage		NVAR	FrameFlag																// Boolean: Load frame scan?	Variable	Keys = GetKeyState(0)	Variable	Reload = 0	if (Keys & 4)		Print "You are holding the shift key --> REFRESHING IMAGE DATA"		Reload = 1		Button LoadImage,fColor=(65535,0,0)									// Button turns red briefly when user presses shift key to do quick reload	else		Reload = 0	endif	if (!(Reload))		Open /D/R/T=".tif"  dumvar												// open dialogue box to read file name		FStatus dumvar			CurrentImageFile = S_fileName											// save full directory path name		ImageFileName = GetFileNameLS(CurrentImageFile)						// create short file name		PathName = GetPathNameLS(CurrentImageFile)							// get path name		ControlInfo/W=LineScanAnalysis ePhysSamePathCheck					// Should ePhys path also be updated?		if ((V_flag==2) %& (V_Value==1))									// Update ePhys path to imaging path if either user choses this...			ePhysPathName = PathName		else			if (V_flag==0)														// ...or if the corresponding checkbox in the panel is missing (old panel that should be updated)...				ePhysPathName = PathName			endif		endif																	// ...otherwise leave ePhys path alone, as the user probably set it to something.		SetShowPathName()		ImageData = ImageFileName[0, strlen(ImageFileName)-5]				// Store name of file, use this to name analyzed data waves		BaseName = ImageFileName[0, strlen(ImageFileName)-8]				// Store base name of file, use this to load next or previous file in series of files			FileNumStr = ImageFileName[strlen(ImageFileName)-7, strlen(ImageFileName)-5]		// Suffix number string		FileNum = str2num(FileNumStr)														// Suffix number (as a number)	endif		DoTheLoadImage("ShowImage")	Button LoadImage,fColor=(0,0,0)end/////////////////////////////////////////////////////////////////// Set the shortened version of the pathname -- for display purposes onlyFunction SetShowPathName()	SVAR	PathName	SVAR	ShowPathName	ShowPathName = PathName	if (StrLen(PathName)>32)		ShowPathName = PathName[0,8]+"..."+PathName[StrLen(PathName)-1-27,StrLen(PathName)-1]	endifEnd/////////////////////////////////////////////////////////////////// Find IMAGEDESCRIPTION tagFunction FindIMAGEDESCRIPTION(theWave)	WAVE/T	theWave	Variable	theIndex = -1		Variable	i = 0	Variable	nRows = DimSize(theWave,0)		do		if (StringMatch("IMAGEDESCRIPTION",theWave[i][1]))			theIndex = i			i = Inf		endif		i += 1	while (i<nRows)	Return	theIndex	end/////////////////////////////////////////////////////////////////// Load the actual image data//// 	File name is in ImageFileName//// 	Path is in PathNameFunction DoTheLoadImage(ShowImageOrNot)	String	ShowImageOrNot	NVAR	ImageWidth	NVAR	ImageHeight	NVAR	nFrames	NVAR	frameHeight	NVAR	CurrentChannel	NVAR	FileNum	SVAR	PathName	SVAR	ImageFileName = ImageFileName		SVAR	RAT_Str = RAT_Str	NVAR	LS_ModernLoadMode	WAVE 	CurrentImage	WAVE 	AllImage		NVAR	FrameFlag														// Boolean: Load frame scan?	NVAR/Z	LS_nChannels	if (Exists("LS_nChannels")==0)		Variable/G LS_nChannels = 0	endif	NVAR	FrameRate	NVAR	dt		Variable	msPerLineScaling = 1	Variable	msPerLineVar//	String	msPerLineStr	Variable	SuccessfullyLoaded = 0		String	CurrentImageFile	ControlInfo/W=LineScanAnalysis LoadModeCheck	LS_ModernLoadMode = V_Value	DoWindow/K ScanImageComments	//	Open /R/Z/P=$PathName dumvar as ImageFileName	CurrentImageFile = PathName + ImageFileName				// save full directory path name	//ImageFileInfo CurrentImageFile	Make /O AllImage	KillDataFolder/Z root:Tag0											// Avoid having these data folders build up as more images are loaded	KillDataFolder/Z root:Tag1//	ImageLoad/Q/Z/RAT/T=tiff /C=-1 /O/N='AllImageRAW' CurrentImageFile				// Old way of loading	ImageLoad/Q/Z/BIGT=1/LTMD/T=tiff/C=-1/O/N='AllImageRAW' CurrentImageFile	Variable	nImagesLoaded = DimSize(AllImageRAW,2)				// 23 Nov 2020, V_numImages produces unreliable results due to bug reported to WaveMetrics	if (nImagesLoaded>3)		print "Loaded "+num2str(nImagesLoaded)+" frames from the file \""+ImageFileName+"\"."	endif	WAVE/T	T_Tags = root:Tag0:T_Tags//	Duplicate/O/T root:Tag0:T_Tags,root:T_Tags	if (LS_ModernLoadMode)												// Old TIFF header style pertains to ScIm v3.7 and lower; Modern is ScIm 2015 and up (I think!)		RAT_Str = T_Tags[12]		msPerLineVar = Str2Num(StringByKey("SI.hRoiManager.linePeriod",RAT_Str," = ",num2char(10)))*1e3	// want it in ms, given in s		String	tempStr = StringByKey("SI.hChannels.channelSave",RAT_Str," = ",num2char(10))		// Apparently, SI sometimes stores SI.hChannels.channelSave as "[1;2;3;4]", other times as "[1 2 3 4]"		LS_nChannels = ItemsInList(tempstr," ")>ItemsInList(tempstr,";") ? ItemsInList(tempstr," ") : ItemsInList(tempstr,";")	else		RAT_Str = T_Tags[FindIMAGEDESCRIPTION(T_Tags)][4]		if (str2num(StringByKey("state.software.version",RAT_Str,"=","\r"))>=3.7)			msPerLineScaling = 1		else			msPerLineScaling = 1e3	// Before 3.7, ms per line state variable was reported in seconds, oddly enough		endif		msPerLineVar = str2num(StringByKey("state.acq.msPerLine",RAT_Str,"=","\r"))*msPerLineScaling		LS_nChannels = str2num(StringByKey("state.acq.numberOfChannelsSave",RAT_Str,"=","\r"))	endif	dt = msPerLineVar	SuccessfullyLoaded = V_flag	KillDataFolder/Z root:Tag0											// Avoid having these data folders build up as more images are loaded	KillDataFolder/Z root:Tag1											// JSj 9 Apr 2020: Build-up only happens with old /RAT flag, not with /LTMD? Had to add /Z to avoid error.	NewPath/O/Q ImagePath,PathName		if (nImagesLoaded>2)		ClearTags()	endif		Variable	VV_numCols	Variable	VV_numRows	if (LS_ModernLoadMode)		VV_numCols = Str2Num(StringByKey("SI.hRoiManager.pixelsPerLine",RAT_Str," = ",num2char(10)))		VV_numRows = Str2Num(StringByKey("SI.hRoiManager.linesPerFrame",RAT_Str," = ",num2char(10)))	else		VV_numCols = DimSize(AllImageRAW,0)			// ImageFileInfo became obsolete in Igor 7, so recreate those variables here		VV_numRows = DimSize(AllImageRAW,1)	endif	if(SuccessfullyLoaded)		if (FrameFlag)												// === FRAME SCAN ===			frameHeight = VV_numRows			nFrames = Floor(nImagesLoaded/LS_nChannels)		// Assumes two channels, unless modern load, in which case 2, 3, and 4 are allowed			ImageWidth = VV_numCols			ImageHeight = frameHeight			if (LS_ModernLoadMode)				FrameRate = Str2Num(StringByKey("SI.hRoiManager.scanFrameRate",RAT_Str," = ",num2char(10)))			else				FrameRate = 1/(frameHeight*dt*1e-3)			endif			DoWindow ImageViewer			if(V_flag == 1)				DoWindow /K ImageViewer			endif			ControlUpdate/W=LineScanAnalysis ViewChan	  	// 0: Red Channel, 1: Green channel			ControlInfo/W=LineScanAnalysis ViewChan   		// Re-read channel from pop-up menu			ViewChanSet("",V_Value,S_Value)			TransformImage()			if (StringMatch(ShowImageOrNot,"ShowImage"))				Printf "\t\tImageSize %d(W) x %d(H) pixels and %d channels\r", ImageWidth, ImageHeight,LS_nChannels				print "\t\tFrame rate is "+num2str(FrameRate)+" Hz or "+num2str(1/FrameRate*1e3)+" ms/frame."				ProduceImage()			endif			else														// === LINE SCAN ===			frameHeight = VV_numRows			nFrames = Floor(nImagesLoaded/LS_nChannels)		// Assumes two channels, unless modern load			ImageWidth = VV_numCols			ImageHeight = frameHeight*nFrames			Printf "\t\tImageSize %d(W) x %d(H) pixels and %d channels\r", ImageWidth, ImageHeight,LS_nChannels			DoWindow ImageViewer			if(V_flag == 1)				KillFrameViewProc("")			endif			ControlUpdate/W=LineScanAnalysis ViewChan	  	// 0: Red Channel, 1: Green channel			ControlInfo/W=LineScanAnalysis ViewChan   		// Re-read channel from pop-up menu			ViewChanSet("",V_Value,S_Value)			TransformImage()			TransferImage()			if (StringMatch(ShowImageOrNot,"ShowImage"))				ProduceImage()			endif			endif	endif	End///////////////////////////////////////////////////////////////////////////////////////////////////// Transform image from loaded data into useful 2D wave (take care of multiple frames, for example)//// AllImageRAW --> AllImageFunction TransformImage()	NVAR	ImageWidth	NVAR	ImageHeight	NVAR	nFrames	NVAR	frameHeight//	NVAR	CurrentChannel	WAVE	AllImageRAW		NVAR	FrameFlag	NVAR	LS_nChannels											// Only two channels are used. Discard third.		NVAR 		flipCh =					flipCh					// Boolean: Flip red & green channels?	Variable	i	if (FrameFlag)		Make /O/N=(ImageWidth, ImageHeight,nFrames) AllImage1,AllImage2		i = 0		do			if (flipCh)				AllImage1[0,ImageWidth-1][0,frameHeight-1][i] = AllImageRAW[p][q][i*LS_nChannels+1]				AllImage2[0,ImageWidth-1][0,frameHeight-1][i] = AllImageRAW[p][q][i*LS_nChannels]//				imagetransform/P=(i*LS_nChannels+1) getplane AllImageRAW//				WAVE		M_ImagePlane//				AllImage1[0,ImageWidth-1][0,frameHeight-1][i] = M_ImagePlane[p][q]//				imagetransform/P=(i*LS_nChannels) getplane AllImageRAW//				WAVE		M_ImagePlane//				AllImage2[0,ImageWidth-1][0,frameHeight-1][i] = M_ImagePlane[p][q]			else				AllImage1[0,ImageWidth-1][0,frameHeight-1][i] = AllImageRAW[p][q][i*LS_nChannels]				AllImage2[0,ImageWidth-1][0,frameHeight-1][i] = AllImageRAW[p][q][i*LS_nChannels+1]//				imagetransform/P=(i*LS_nChannels) getplane AllImageRAW//				WAVE		M_ImagePlane//				AllImage1[0,ImageWidth-1][0,frameHeight-1][i] = M_ImagePlane[p][q]//				imagetransform/P=(i*LS_nChannels+1) getplane AllImageRAW//				WAVE		M_ImagePlane//				AllImage2[0,ImageWidth-1][0,frameHeight-1][i] = M_ImagePlane[p][q]			endif			i += 1		while(i<nFrames)		// Account for ScanImage bug//		AllImage1[0,9][0][0] = AllImage1[10][0][0]//		AllImage2[0,9][0][0] = AllImage2[10][0][0]		AllImage1[0,11][0][] = AllImage1[12][0][r]		AllImage2[0,11][0][] = AllImage2[12][0][r]		AllImage1[][][nFrames-1] = AllImage1[p][q][nFrames-2]			// Note to self: should this be -3 if LS_nChannels is 3? What is this bug now again?		AllImage2[][][nFrames-1] = AllImage1[p][q][nFrames-2]	else		Make /O/N=(ImageWidth, ImageHeight,2) AllImage		i = 0		do			AllImage[0,ImageWidth-1][0+i*frameHeight,frameHeight-1+i*frameHeight][0] = AllImageRAW[p][q-i*frameHeight][0+i*LS_nChannels]			AllImage[0,ImageWidth-1][0+i*frameHeight,frameHeight-1+i*frameHeight][1] = AllImageRAW[p][q-i*frameHeight][1+i*LS_nChannels]			i += 1		while(i<nFrames)	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////// Transfer image from *converted* loaded data into ImageViewer 2D waveFunction TransferImage()	NVAR	ImageWidth	NVAR	ImageHeight	NVAR	nFrames//	NVAR	frameHeight	NVAR	CurrentChannel	WAVE	AllImage	Make /O/N=(ImageWidth, ImageHeight) CurrentImage	CurrentImage[0,ImageWidth-1][0,ImageHeight] = AllImage[p][q][CurrentChannel]End///////////////////////////////////////////////////////////////////////////////////////////////////// When using /RAT flag with ImageLoad, "Tag" folders build up when loading images. This procedure gets rid of//// them.Function ClearTags()	String		currFolder	Variable	i//	Print "Deleting old TIFF tags..."	do		currFolder = GetIndexedObjName("root:",4, i)		if (strlen(currFolder) == 0)			break		else			if ((StringMatch(currFolder[0,2],"Tag")) %& (!(StringMatch(num2str(str2num(currFolder[3])),"NaN"))))//				print "Killing: ",currFolder				KillDataFolder $currFolder				if (V_flag)					Print "Could not kill folder "+currFolder					abort "Strange error for folder "+currFolder				endif			else//				Print "Not killing:",currFolder				i += 1			endif		endif	while(1)End//************************************************************************************// MoveFile////************************************************************************************Function LSMoveFile(ctrlName) : ButtonControl	String ctrlName		NVAR	ImageWidth	NVAR	ImageHeight	NVAR	CurrentChannel	NVAR	FileNum	SVAR	ImageData	SVAR	BaseName	SVAR	FileNumStr	SVAR	PathName		SVAR	ImageFileName = ImageFileName	NVAR	Multi_SuffIncr = Multi_SuffIncr		NVAR	ReAnalyzeStart	Variable dumvar	String	stemp	stemp = ctrlName[strlen(ctrlName)-7, strlen(ctrlName)-1]	FileNum = str2num(FileNumStr)		Variable Step = 1		Variable Keys = GetKeyState(0)	if (Keys & 2^2)			// Shift key		Step = Multi_SuffIncr	endif	if (Keys & 2^0)			// Command key		Step = 10	endif	if (Keys & 2^1)			// Option key		if (exists("SuffixStartWave"))			WAVE	SuffixStartWave			if (numpnts(SuffixStartWave)>0)				print "You held down the option key -- jumping to the first file in the data analysis table..."				FileNum = SuffixStartWave[0]				if (FileNum < 0)					FileNum = 1					Print "{LSMoveFile} Strange error, FileNum < 0, so reset FileNum = 1, talk to Jesper about this weirdness..."				endif			else				print "You held down the option key -- Data analysis table found but empty, so now jumping to Update Start suffix value: "+num2str(ReAnalyzeStart)				FileNum = ReAnalyzeStart			endif		else			print "You held down the option key -- No data analysis table found, so now jumping to Update Start suffix value: "+num2str(ReAnalyzeStart)			FileNum = ReAnalyzeStart		endif	else		strswitch(stemp)			case "NextImg":				FileNum += Step				break			case "PrevImg":				FileNum -= Step				if (FileNum < 1)					FileNum = 1				endif				break		endswitch	endif		FileNum2FileNumStr()				ImageFileName = BaseName + FileNumStr + ".tif"	ImageData = ImageFileName[0, strlen(ImageFileName)-5]		DoTheLoadImage("ShowImage")end//***************************************************************************************// SetLines////***************************************************************************************//Function SetLines2(ctrlName,varNum,varStr,varName) : SetVariableControl//	String ctrlName//	Variable varNum//	String varStr//	String varName////	DrawLines2()//EndFunction SetLines2(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update			Variable dval = sva.dval			String sval = sva.sval			DrawLines2()			break		case -1: // control being killed			break	endswitch	return 0End//***************************************************************************************// DrawLines////***************************************************************************************Function DrawLines2()	NVAR LS_Left=LS_Left, LS_Right=LS_Right, BG_Left=BG_Left, BG_Right=BG_Right, F0_Upper=F0_Upper, F0_Lower=F0_Lower//	NVAR ImageWidth, ImageHeight			DoWindow /F ImageViewer	if (V_flag)		SetDrawLayer /K UserFront		SetDrawLayer UserFront			SetDrawEnv /W=ImageViewer xcoord=top, ycoord=prel, linefgc=(65535,65535,0), linethick=1		DrawLine /W=ImageViewer LS_Left, 0, LS_Left, 1		SetDrawEnv /W=ImageViewer xcoord=top, ycoord=prel, linefgc=(65535,65535,0), linethick=1		DrawLine /W=ImageViewer LS_Right, 0, LS_Right,1				SetDrawEnv /W=ImageViewer xcoord=top, ycoord=prel, linefgc=(65535,0,0), linethick=1		DrawLine /W=ImageViewer BG_Left, 0, BG_Left,1		SetDrawEnv /W=ImageViewer xcoord=top, ycoord=prel, linefgc=(65535,0,0), linethick=1		DrawLine /W=ImageViewer BG_Right, 0, BG_Right,1				SetDrawEnv /W=ImageViewer xcoord=prel, ycoord=left, linefgc=(0,65535,0), linethick=1		DrawLine /W=ImageViewer 0, F0_Upper,1, F0_Upper		SetDrawEnv /W=ImageViewer xcoord=prel, ycoord=left, linefgc=(0,65535,0), linethick=1		DrawLine /W=ImageViewer 0, F0_Lower,1, F0_Lower	endifEnd//***************************************************************************************// LineScanAnalysis////***************************************************************************************//Function LineScan2FromSetVar(ctrlName,varNum,varStr,varName) : SetVariableControl//	String ctrlName//	Variable varNum//	String varStr//	String varName//	//	LineScan2("Analyze")////EndFunction LineScan2FromSetVar(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update			Variable dval = sva.dval			String sval = sva.sval			LineScan2("Analyze")			break		case -1: // control being killed			break	endswitch	return 0EndFunction LineScan2(ctrlName) : ButtonControl	String ctrlName	String		stemp	Variable	i,j	Variable	F0													// The F0 value, i.e. the green baseline inside ROI, before response	Variable	F0_Height											// The height of the F0 rectangle	Variable	F0_Width											// The width of the F0 rectangle	Variable	R0													// The R0 value, i.e. the red baseline inside ROI, before response	Variable	R0_Height											// The height of the R0 rectangle	Variable	R0_Width											// The width of the R0 rectangle	Variable	BG													// The BG value, i.e. the background value taken from rectangle outside ROI	Variable	BG_Height											// The height of the BG rectangle	Variable	BG_Width											// The width of the BG rectangle	Variable	GR													// The GR value is the Green over Red ratio at rest, before response	Variable	bLineSD											// Standard deviation of the baseline signal -- a measure of signal noise	//	String /G dFData	SVAR		dFData	SVAR		ImageData	NVAR		ImageWidth = 				ImageWidth	NVAR		ImageHeight =				ImageHeight	NVAR		CurrentChannel	NVAR		Calc_mode	NVAR		dt	NVAR		LS_Left =						LS_Left	NVAR		LS_Right =					LS_Right	NVAR		BG_Left =						BG_Left	NVAR		BG_Right =					BG_Right	NVAR		F0_Upper =					F0_Upper	NVAR		F0_Lower =					F0_Lower	WAVE		CurrentImage	WAVE		AllImage		NVAR		LS_ReanalyzingData =		LS_ReanalyzingData		NVAR 		flipCh =						flipCh					// Boolean: Flip red & green channels?		NVAR	ImageWidth	NVAR	ImageHeight	NVAR	nFrames	NVAR	frameHeight	WAVE	AllImageRAW		NVAR	FrameFlag	WAVE/Z	TheImage1	WAVE/Z	AllImage1	WAVE/Z	AllImage2		NVAR	frameNumber		NVAR	frameRate		NVAR	frameBaseStart										// NOTE! Use this for frame scan analysis	NVAR	frameBaseEnd		NVAR	BlankStart	NVAR	BlankEnd	NVAR	BlankCheckVar	WAVE/Z	theROI	WAVE/Z	theBG		NVAR		FixBleaching	NVAR		BleachSmooth	ControlInfo/W=LineScanAnalysis FixBleachingCheck	FixBleaching = V_Value	NVAR		SubBGFlag	ControlInfo/W=LineScanAnalysis SubtractBGCheck	SubBGFlag = V_Value			if (FrameFlag)												// === FRAMESCAN ANALYSIS ===			stemp = ctrlName[strlen(ctrlName)-7 , strlen(ctrlName)-1]				if(stringmatch(stemp, "Analyze"))				imageStats theROI			if ((V_avg==0) %| (V_avg==1))				Print "Did you select a region of interest yet?"				Abort "Did you select a region of interest yet?"			endif					imageStats theBG			if ((V_avg==0) %| (V_avg==1))				Print "Did you select a background region of interest yet?"				Abort "Did you select a background region of interest yet?"			endif						FrameRate = 1/(frameHeight*dt*1e-3)				// Update in case user manually changes scan rate from TIFF header value						Make /O/N=(nFrames) DumWaveG			Make /O/N=(nFrames) DumWaveR					Make /O/N=(nFrames) DumWaveBG			Make /O/N=(nFrames) DumWaveBG_green,DumWaveBG_red			Make /O/N=(nFrames) dF			Make /O/N=(nFrames) TimeAxis			DumWaveG = 0			DumWaveR = 0			DumWaveBG = 0			DumWaveBG_green = 0			DumWaveBG_red = 0			dF = 0			TimeAxis = (p+1)*(1/FrameRate)*1e3				// TimeAxis goes in [ms]			ControlUpdate/W=LineScanAnalysis CalcMode  			// 0: DG/G, 1: DG/R					BG = 0			F0 = 0			R0=0				Duplicate/O theROI,theROI_inv								// Masks work backwards in Igor compared to how I think			theROI_inv = 1-theROI			Duplicate/O theBG,theBG_inv			theBG_inv = 1-theBG			for(j=0;j<nFrames;j+=1)									// j goes through frames				imageTransform/P=(j)/PTYP=0 getPlane,AllImage1	// Extract frame #j, green channel				imageTransform/R=theROI_inv roiTo1D M_ImagePlane	// Take all pixels within ROI from selected frame				DumWaveG[j] = mean(W_roi_to_1d)					// Store average of these pixels for this time point				imageTransform/R=theBG_inv roiTo1D M_ImagePlane	// Take all pixels within BG from selected frame				DumWaveBG[j] = mean(W_roi_to_1d)					// Store average of these pixels for this time point			endfor														// EndFrames			if (BlankCheckVar)				DoRemoveStimArtifact(BlankStart/1e3,(BlankEnd-BlankStart),"DumWaveBG",0)				DoRemoveStimArtifact(BlankStart/1e3,(BlankEnd-BlankStart),"DumWaveG",0)			endif			BG = Mean(DumWaveBG,0,nFrames-1)						// Normalized green background, taken over all frames				//// The "F0 rectangle"			F0 = Mean(DumWaveG,frameBaseStart,frameBaseEnd)		// Normalized green baseline				if (Calc_mode==0)				//// CALCULATE dG/G //////				dF = (DumWaveG-F0)/F0				if (!(SubBGFlag))					BG = 0				endif				dF = (DumWaveG-F0)/(F0-BG)				GR = F0//				WaveStats/Q/R=(frameBaseStart,frameBaseEnd) DumWaveG//				bLineSD = V_sdev				dFData = ImageData + "_dGG"			else				if (Calc_mode==1)					//// CALCULATE dG/R ////					// Work on red channel now					DumWaveBG = 0		// Careful here now! We are reusing this wave!					for(j=0;j<nFrames;j+=1)									// j goes through frames						imageTransform/P=(j)/PTYP=0 getPlane,AllImage2	// Extract frame #j, red channel						imageTransform/R=theROI_inv roiTo1D M_ImagePlane	// Take all pixels within ROI from selected frame						DumWaveR[j] = mean(W_roi_to_1d)					// Store average of these pixels for this time point						imageTransform/R=theBG_inv roiTo1D M_ImagePlane	// Take all pixels within BG from selected frame						DumWaveBG[j] = mean(W_roi_to_1d)					// Store average of these pixels for this time point					endfor														// EndFrames					if (BlankCheckVar)						DoRemoveStimArtifact(BlankStart/1e3,(BlankEnd-BlankStart),"DumWaveBG",0)						DoRemoveStimArtifact(BlankStart/1e3,(BlankEnd-BlankStart),"DumWaveR",0)					endif					BG = Mean(DumWaveBG,0,nFrames-1)						// Normalized RED background, taken over all frames					R0 = Mean(DumWaveR,0,nFrames-1)						// Normalized red signal					GR = F0/R0//					WaveStats/Q/R=(frameBaseStart,frameBaseEnd) DumWaveG//					bLineSD1 = V_sdev//					WaveStats/Q/R=(0,nFrames-1) DumWaveR//					bLineSD2 = V_sdev//					bLineSD = GR*sqrt((bLineSD1/F0)^2+(bLineSD2/R0))					// Calculate SDevs, see					//	http://www.cartage.org.lb/en/themes/sciences/chemistry/miscellenous/helpfile/Erroranalysis/MultiplicationDivision/MultiplicationDivision.htm					if (!(SubBGFlag))						BG = 0					endif					if (FixBleaching)						Smooth/B BleachSmooth,DumWaveR							// Warning -- work with care from here on!						dF = (DumWaveG-F0)/(DumWaveR-BG)					else						dF = (DumWaveG-F0)/(R0-BG)						//Yuste/Konnerth, p256: F0 denotes the background-subtracted prestimulus fluorescence level					endif					dFData = ImageData + "_dGR"				else					//// CALCULATE R/G ////				endif			endif		endif		WaveStats/Q /R=[frameBaseStart,frameBaseEnd] dF		bLineSD = V_sdev		Duplicate /O dF, $dFData		DoWindow/K LineScanGraph		if (!(LS_ReanalyzingData))			Display /W=(330,100-50+220,700,300-70+220)			DoWindow/C LineScanGraph			AppendToGraph $dFData			TextBox /A=LT /B=1 /C/N=text0 /F=0 "G/Rrest="+num2str(GR)		endif		SetScale/P x (1/FrameRate),(1/FrameRate),"",$dFData,DumWaveG, DumWaveR, DumWaveBG, dF		// This is how Kazuo scaled the time axis, not sure why it should start at (1/FrameRate) and not zero, though...	else															// === LINESCAN ANALYSIS ===			stemp = ctrlName[strlen(ctrlName)-7 , strlen(ctrlName)-1]				if(stringmatch(stemp, "Analyze"))				Make /O/N=(ImageHeight) DumWaveG			Make /O/N=(ImageHeight) DumWaveR					Make /O/N=(ImageHeight) DumWaveBG			Make /O/N=(ImageHeight) DumWaveBG_green,DumWaveBG_red			Make /O/N=(ImageHeight) dF			Make /O/N=(ImageHeight) TimeAxis						// Important! SetScale has to be done at the end (not here!), because we think in points up until the very end!						DumWaveG = 0			DumWaveR = 0			DumWaveBG = 0			DumWaveBG_green = 0			DumWaveBG_red = 0			dF = 0			TimeAxis = (p+1)*dt				ControlUpdate/W=LineScanAnalysis CalcMode  			// 0: DG/G, 1: DG/R			CurrentChannel = 0 											// Green Channel			if (flipCh)				CurrentChannel = 1-CurrentChannel						// Flip channels			endif				F0_Height = F0_Lower-F0_Upper+1			F0_Width = LS_Right-LS_Left+1				R0_Height = F0_Height											// Sorta boneheaded, but there we go...			R0_Width = F0_Width				BG_Height = ImageHeight			BG_Width = BG_Right-BG_Left+1						BG = 0			F0 = 0			R0=0					for(j=0;j<ImageHeight;j+=1)									// j goes through rows				//// Background				for(i=BG_Left;i<BG_Right;i+=1)							// i goes through columns					DumWaveBG[j] += AllImage[i][j][CurrentChannel]				endfor				//// LineScan				for(i=LS_Left;i<LS_Right;i+=1)							// i goes through columns					DumWaveG[j] += AllImage[i][j][CurrentChannel]				endfor			endfor															// EndRows			if (BlankCheckVar)				DoRemoveStimArtifact(BlankStart*dt,(BlankEnd-BlankStart)*1e3*dt,"DumWaveBG",0)				DoRemoveStimArtifact(BlankStart*dt,(BlankEnd-BlankStart)*1e3*dt,"DumWaveG",0)			endif			BG = Sum(DumWaveBG,F0_Upper,F0_Lower)/(BG_Height*BG_Width)	// Normalized green background, taken over baseline period				//// The "F0 rectangle"			F0 = Sum(DumWaveG,F0_Upper,F0_Lower)/(F0_Height*F0_Width)		// Normalized green baseline				if (Calc_mode==0)				//// CALCULATE dG/G ////				dF = (DumWaveG/F0_Width-F0)/(F0-BG)				GR = F0				dFData = ImageData + "_dGG"//				WaveStats/Q/R=(F0_Upper,F0_Lower) DumWaveG//				bLineSD = V_sdev/(F0_Height*F0_Width)			else				if (Calc_mode==1)					//// CALCULATE dG/R ////					CurrentChannel = 1					if (flipCh)						CurrentChannel = 1-CurrentChannel 					// Flip channels -- now look at red channel					endif					DumWaveBG = 0		// Careful here now! We are reusing this wave!					DumWaveR = 0			// Not this one, but can't be too safe					for(j=0;j<ImageHeight;j+=1)								// j goes through rows						for(i=BG_Left;i<BG_Right;i+=1)						// i goes through columns							DumWaveBG[j] += AllImage[i][j][CurrentChannel]						endfor						for(i=LS_Left;i<LS_Right;i+=1)						// i goes through columns							DumWaveR[j] += AllImage[i][j][CurrentChannel]						endfor					endfor					if (BlankCheckVar)						DoRemoveStimArtifact(BlankStart*dt,(BlankEnd-BlankStart)*1e3*dt,"DumWaveBG",0)						DoRemoveStimArtifact(BlankStart*dt,(BlankEnd-BlankStart)*1e3*dt,"DumWaveR",0)					endif					BG = Sum(DumWaveBG,3,ImageHeight-1)/((BG_Height-3)*BG_Width)		// Normalized red background					R0 = Sum(DumWaveR,F0_Upper,F0_Lower)/(R0_Height*R0_Width)		// Normalized red baseline					GR = F0/R0					Smooth/B BleachSmooth,DumWaveR						// Warning -- work with care from here on!					if (FixBleaching)						dF = (DumWaveG/F0_Width-F0)/(DumWaveR/R0_Width-BG)					else						dF = (DumWaveG/F0_Width-F0)/(R0-BG)						//Yuste/Konnerth, p256: F0 denotes the background-subtracted prestimulus fluorescence level					endif					dFData = ImageData + "_dGR"				else					//// CALCULATE R/G ////					// Green is at front					for(j=0;j<ImageHeight;j+=1)									// j goes through rows						//// Green background						for(i=BG_Left;i<BG_Right;i+=1)							// i goes through columns							DumWaveBG_green[j] += AllImage[i][j][CurrentChannel]						endfor						//// LineScan						for(i=LS_Left;i<LS_Right;i+=1)							// i goes through columns							DumWaveG[j] += AllImage[i][j][CurrentChannel]						endfor					endfor															// EndRows					if (BlankCheckVar)						DoRemoveStimArtifact(BlankStart*dt,(BlankEnd-BlankStart)*1e3*dt,"DumWaveBG_green",0)						DoRemoveStimArtifact(BlankStart*dt,(BlankEnd-BlankStart)*1e3*dt,"DumWaveG",0)					endif					CurrentChannel = 1					if (flipCh)						CurrentChannel = 1-CurrentChannel 					// Flip channels -- now look at red channel					endif					// Red is at front					for(j=0;j<ImageHeight;j+=1)								// j goes through rows						for(i=BG_Left;i<BG_Right;i+=1)						// i goes through columns							DumWaveBG_red[j] += AllImage[i][j][CurrentChannel]						endfor						for(i=LS_Left;i<LS_Right;i+=1)						// i goes through columns							DumWaveR[j] += AllImage[i][j][CurrentChannel]						endfor					endfor					if (BlankCheckVar)						DoRemoveStimArtifact(BlankStart*dt,(BlankEnd-BlankStart)*1e3*dt,"DumWaveBG_red",0)						DoRemoveStimArtifact(BlankStart*dt,(BlankEnd-BlankStart)*1e3*dt,"DumWaveR",0)					endif					R0 = Sum(DumWaveR,F0_Upper,F0_Lower)/(R0_Height*R0_Width)	// Normalized cumulative red baseline					GR = F0/R0						dF = (DumWaveR/F0_Width-DumWaveBG_red/BG_Width)/(DumWaveG/F0_Width-DumWaveBG_green/BG_Width)					dFData = ImageData + "_dGR"				endif			endif						dF[0] = dF[1]			// to avoid bug			WaveStats/Q/R=[F0_Upper,F0_Lower] dF			bLineSD = V_sdev			Duplicate /O dF, $dFData			DoWindow/K LineScanGraph				if (!(LS_ReanalyzingData))				Display /W=(292,100-50,700,300-70)				DoWindow/C LineScanGraph				AppendToGraph $dFData				TextBox /A=LT /B=1 /C/N=text0 /F=0 "G/Rrest="+num2str(GR)			endif				SetScale/P x dt*1e-3,dt*1e-3,"",$dFData,DumWaveG, DumWaveR, DumWaveBG, DumWaveBG_green, DumWaveBG_red, dF		// This is how Kazuo scaled the time axis, not sure why it should start at dt and not zero, though...		endif			endif		if (!(LS_ReanalyzingData))		ModifyGraph zero(left)=2		ModifyGraph fSize=12		Variable	lSp = 20		ControlBar lSp*3+2		Variable	bWid = 18		Variable 	bPos = 2	 	Variable 	yPos = 2		Variable	bSp = 1	 	Button KillItButton, pos={bPos,yPos}, size={bWid,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	bPos += bWid+bSp		Variable	fade = 2		bWid = 50		Button Analyze, pos={bPos,yPos}, size={bWid,17},size={100, 18}, proc=Linescan2, title="Analyze",fStyle=1,fColor=(65535/fade,65535/fade,65535),fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 36	 	Button ZoomInButton, pos={bPos,yPos}, size={bWid,17},proc=ZoomInProc, title="Zoom",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	Button PickPosButton, pos={bPos,yPos}, size={bWid,17},proc=PickPosProc, title="Pnts",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 28	 	Button PickBaselineButton, pos={bPos,yPos}, size={bWid,17},proc=PickBaselineProc, title="Bsl",fSize=10,font="Arial"	 	bPos += bWid+bSp		Button PickIntegralButton, pos={bPos,yPos}, size={bWid,17},proc=PickIntegralProc, title="Int",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 32		Button PickBlankButton, pos={bPos,yPos}, size={bWid,17},proc=PickBlankProc, title="Blnk",fSize=10,font="Arial"	 	bPos += bWid+bSp		Button AutoYRangeButton, pos={bPos,yPos}, size={bWid,17},proc=AutoYRangeProc, title="Auto",fSize=10,font="Arial"	 	bPos += bWid+bSp		Button GreeenAndRedButton, pos={bPos,yPos}, size={bWid,17},proc=Make_Green_and_Red_Proc, title="G&R",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bPos = 2		// new line	 	yPos += lSp	 	bWid = 34		Button SaveButton, pos={bPos,yPos}, size={bWid,17},proc=LS_SaveROI, title="Save",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 26		Button PutButton, pos={bPos,yPos}, size={bWid,17},proc=LS_PutROI, title="Put",fSize=10,font="Arial"	 	bPos += bWid+bSp		Button GetButton, pos={bPos,yPos}, size={bWid,17},proc=LS_GetROI, title="Get",fSize=10,font="Arial"	 	bPos += bWid+bSp		Button DeleteButton, pos={bPos,yPos}, size={bWid,17},proc=LS_DelROI, title="Del",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 70		NVAR LS_operateOnROI		SetVariable operateRoiSV,pos={bPos,yPos},size={bWid,17},title="which",proc=LS_operateRoiSVProc,value=LS_operateOnROI,limits={1,Inf,1},fsize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 40		Button DelAllButton, pos={bPos,yPos}, size={bWid,17},proc=LS_DelAllROIanalysis_Proc, title="Del all",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 34		Button ShowTableButton, pos={bPos,yPos}, size={bWid,17},proc=LS_ShowROIs_Proc, title="Table",fSize=10,font="Arial"	 	bPos += bWid+bSp		Button ReAnalyzeButton, pos={bPos,yPos}, size={bWid,17},proc=LS_ReanalyzeROIs_Proc, title="Redo",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bPos = 2		// new line	 	yPos += lSp	 	bWid = 50		Button MoveAllButton, pos={bPos,yPos}, size={bWid,17},proc=LS_moveROIs, title="Move all",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 70		Button MoveCurrentButton, pos={bPos,yPos}, size={bWid,17},proc=LS_moveROIs, title="Move current",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 60		NVAR LS_moveROI_x		SetVariable moveROI_x_SV,pos={bPos,yPos},size={bWid,17},title=" x:",value=LS_moveROI_x,limits={-Inf,Inf,1},fsize=10,font="Arial"	 	bPos += bWid+bSp		NVAR LS_moveROI_y		SetVariable moveROI_y_SV,pos={bPos,yPos},size={bWid,17},title=" y:",value=LS_moveROI_y,limits={-Inf,Inf,1},fsize=10,font="Arial"	 	bPos += bWid+bSp	 	DoWindow ImageViewer2	 	if (V_flag)	 		AutoPositionWindow/M=1/R=ImageViewer2 LineScanGraph	 	endif	endif	Note $dFData,"Rest:"+num2str(GR)+";bLineSD:"+num2str(bLineSD)		if (BlankCheckVar)		DoRemoveStimArtifact(BlankStart/1e3,(BlankEnd-BlankStart),dFData,0)	endif	End//////////////////////////////////////////////////////////////////////////////////// Move ROIs//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_moveROIs(ctrlName) : ButtonControl	String ctrlName	Variable	moveAll		if (StringMatch(ctrlName,"MoveAllButton"))		moveAll = 1	else		moveAll = 0	endif		NVAR		LS_moveROI_x	NVAR		LS_moveROI_y		Variable	i	NVAR		RecallROICounter	SVAR		dFData	NVAR		LS_operateOnROI		WAVE		ROI_BslnStart,ROI_BslnEnd		NVAR		frameBaseStart										// NOTE! Use this for frame scan analysis	NVAR		frameBaseEnd		NVAR		FrameFlag	if (!(FrameFlag))		print "This button only works for framescans!"		Abort	endif		doWindow/K LineScanGraph	if (moveAll)		Print "--- Moving all ROIs ---"		i = 1		do			LS_operateOnROI = i			LS_GetROI("")			LS_moveROI(LS_moveROI_x,LS_moveROI_y)			PickROIProc("")			LS_PutROI("")			i += 1		while(i<RecallROICounter+1)	else		Print "--- Moving current ROI ---"		LS_GetROI("")		LS_moveROI(LS_moveROI_x,LS_moveROI_y)		PickROIProc("")		LS_PutROI("")	endif	LineScan2("Analyze")		LS_updateROImap()EndFunction LS_moveROI(dx,dy)	Variable	dx,dy		WAVE		LS_xDraw	WAVE		LS_yDraw		LS_xDraw += dx	LS_yDraw += dyEnd//////////////////////////////////////////////////////////////////////////////////// Which ROI selection setvar//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_operateRoiSVProc(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update			Variable dval = sva.dval			String sval = sva.sval			LS_keepOperateRoiInBounds()			break		case -1: // control being killed			break	endswitch	return 0EndFunction LS_keepOperateRoiInBounds()	NVAR		RecallROICounter	NVAR 		LS_operateOnROI	if (LS_operateOnROI>RecallROICounter)		LS_operateOnROI = RecallROICounter	endifEnd//////////////////////////////////////////////////////////////////////////////////// Kill and restart ROI dataset//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_DelAllROIanalysis_Proc(ctrlName) : ButtonControl	String ctrlName		LS_doDelAllROIanalysis()	EndFunction LS_doDelAllROIanalysis()	NVAR		RecallROICounter	WAVE 		RecallTheROIs	NVAR		LS_operateOnROI		NVAR		FrameFlag	if (!(FrameFlag))		print "This button only works for framescans!"		Abort	endif	DoAlert/T="Sanity check!" 1,"This will delete all data.  Are you sure?"		if (V_flag==1)		Print "--- Restarting collection of ROIs and Sweeps ---"		RecallROICounter = 0		LS_operateOnROI = RecallROICounter		RecallTheROIs = 0		Make/O/N=(0) ROI_xPos,ROI_yPos,ROI_num,ROI_BslnStart,ROI_BslnEnd,ROI_size		DoWindow/K LS_ROI_table		DoWindow/K ROIViewer		DoWindow/K ROISweepsGraph	else		Print "Cencelled"	endifEnd	//////////////////////////////////////////////////////////////////////////////////// Make the table listing the ROIs//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_ShowROIs_Proc(ctrlName) : ButtonControl	String ctrlName		NVAR		FrameFlag	if (!(FrameFlag))		print "This button only works for framescans!"		Abort	endif	DoWindow LS_ROI_table			// Kill if it exists, draw otherwise	if (V_flag)		DoWindow/K LS_ROI_table	else		DoWindow/K LS_ROI_table		Edit/K=1 ROI_num,ROI_xPos,ROI_yPos,ROI_BslnStart,ROI_BslnEnd,ROI_size as "Show ROIs"		DoWindow/C LS_ROI_table	endif	End//////////////////////////////////////////////////////////////////////////////////// Delete a sweep and ROI//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_DelROI(ctrlName) : ButtonControl	String ctrlName		NVAR		LS_operateOnROI	NVAR		RecallROICounter		if (LS_operateOnROI>RecallROICounter)		print "Cannot delete a ROI that was not yet created!"		Abort "Cannot delete a ROI that was not yet created!"	endif		if (RecallROICounter==1)													// If only 1 slot is filled, then do "Del all" instead, to clean up.		LS_doDelAllROIanalysis()	else			DoWindow/K ROISweepsGraph													// Cannot delete sweeps in an existing graph			DeletePoints LS_operateOnROI-1,1,ROI_xPos,ROI_yPos,ROI_num,ROI_BslnStart,ROI_BslnEnd,ROI_size		WAVE		ROI_num		ROI_num = p+1			if (!Exists("theROI_"+JT_num2digstr(3,LS_operateOnROI)))			print "This ROI mask was not found. Data set was created with an older version of code.  Please redo analysis from scratch for this cell."			Abort "This ROI mask was not found. Data set was created with an older version of code.  Please redo analysis from scratch for this cell."		Endif			WAVE theStoredROI = $("theROI_"+JT_num2digstr(3,LS_operateOnROI))		WAVE RecallTheROIs		RecallTheROIs = RecallTheROIs && !theStoredROI		KillWaves/Z $("theROI_"+JT_num2digstr(3,LS_operateOnROI))		print "Removed ROI mask \""+"theROI_"+JT_num2digstr(3,LS_operateOnROI)+"\""			Killwaves/Z $("LS_xDraw_"+JT_num2digstr(3,LS_operateOnROI))		Killwaves/Z $("LS_yDraw_"+JT_num2digstr(3,LS_operateOnROI))		print "Removed ROI drawings \""+"LS_xDraw_"+JT_num2digstr(3,LS_operateOnROI)+"\" and \""+"LS_yDraw_"+JT_num2digstr(3,LS_operateOnROI)+"\""			KillWaves/Z $("ROI_Sweep_"+JT_num2digstr(3,LS_operateOnROI))		print "Remove sweep \""+"ROI_Sweep_"+JT_num2digstr(3,LS_operateOnROI)+"\""				Variable	i = LS_operateOnROI+1		if (i<RecallROICounter+1)			do				Rename $("theROI_"+JT_num2digstr(3,i)),$("theROI_"+JT_num2digstr(3,i-1))				Rename $("ROI_Sweep_"+JT_num2digstr(3,i)),$("ROI_Sweep_"+JT_num2digstr(3,i-1))				Rename $("LS_xDraw_"+JT_num2digstr(3,i)),$("LS_xDraw_"+JT_num2digstr(3,i-1))				Rename $("LS_yDraw_"+JT_num2digstr(3,i)),$("LS_yDraw_"+JT_num2digstr(3,i-1))				i += 1			while(i<RecallROICounter+1)		endif			RecallROICounter -= 1				LS_keepOperateRoiInBounds()		LS_makeROIsweepsGraph()	endif	End	//////////////////////////////////////////////////////////////////////////////////// Reanalyze all ROI data//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_ReanalyzeROIs_Proc(ctrlName) : ButtonControl	String ctrlName	Variable i	NVAR		RecallROICounter	SVAR		dFData	NVAR		LS_operateOnROI		WAVE		ROI_BslnStart,ROI_BslnEnd		NVAR		frameBaseStart										// NOTE! Use this for frame scan analysis	NVAR		frameBaseEnd		NVAR		FrameFlag	if (!(FrameFlag))		print "This button only works for framescans!"		Abort	endif		Print "--- Redoing all analysis ---"	doWindow/K LineScanGraph	i = 1	do//		Duplicate/O $("theROI_"+JT_num2digstr(3,i)),theROI			// Set the ROI//		frameBaseStart = ROI_BslnStart[i]							// Set the baseline//		frameBaseEnd = ROI_BslnEnd[i]		LS_operateOnROI = i		LS_GetROI("")		PickROIProc("")		LineScan2("Analyze")		Duplicate/O	$dFData,$("ROI_Sweep_"+JT_num2digstr(3,i))		print "Reanalyzing sweep in \""+"ROI_Sweep_"+JT_num2digstr(3,i)+"\""		LS_StoreStatsForROI(i)										// JSj added 9 Jan 2023		i += 1	while(i<RecallROICounter+1)		LS_makeROIsweepsGraph()End	//////////////////////////////////////////////////////////////////////////////////// Duplicate the sweep and remember ROI//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_SaveROI(ctrlName) : ButtonControl	String	ctrlName		NVAR		FrameFlag	if (!(FrameFlag))		print "This button only works for framescans!"		Abort	endif		NVAR	RecallROICounter	RecallROICounter += 1	LS_StoreStatsForROI(RecallROICounter)	LS_makeROIsweepsGraph()End//////////////////////////////////////////////////////////////////////////////////// Save ROI in specific slot//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_PutROI(ctrlName) : ButtonControl	String	ctrlName	NVAR		LS_operateOnROI	NVAR		RecallROICounter		NVAR		FrameFlag	if (!(FrameFlag))		print "This button only works for framescans!"		Abort	endif	LS_StoreStatsForROI(LS_operateOnROI)	End//////////////////////////////////////////////////////////////////////////////////// Get ROI from specific slot//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_GetROI(ctrlName) : ButtonControl	String	ctrlName	NVAR		LS_operateOnROI		NVAR		frameBaseStart												// NOTE! Use this for frame scan analysis	NVAR		frameBaseEnd		WAVE		ROI_BslnStart	WAVE		ROI_BslnEnd	NVAR		FrameFlag	if (!(FrameFlag))		print "This button only works for framescans!"		Abort	endif	frameBaseStart = ROI_BslnStart[LS_operateOnROI-1]			// baseline start	frameBaseEnd = ROI_BslnEnd[LS_operateOnROI-1]				// basline end	WAVE	LS_xDraw	WAVE	LS_yDraw	Duplicate/O $("LS_xDraw_"+JT_num2digstr(3,LS_operateOnROI)),LS_xDraw		// Recall GraphDraw coordinates so that user can edit ROI	Duplicate/O $("LS_yDraw_"+JT_num2digstr(3,LS_operateOnROI)),LS_yDrawEnd//////////////////////////////////////////////////////////////////////////////////// ROI store stats for slot//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_StoreStatsForROI(whichROI)	Variable	whichROI	SVAR		dFData		NVAR		RecallROICounter	// Frame scan stacks	NVAR		nFrames	WAVE/Z		AllImage1	WAVE/Z		AllImage2	WAVE		theROI	NVAR		frameBaseStart										// NOTE! Use this for frame scan analysis	NVAR		frameBaseEnd	Variable	i,j	Variable	theSize = 0	if (Exists("ROI_xPos")==0)		Make/O/N=(0) ROI_xPos,ROI_yPos,ROI_num	else		WAVE		ROI_xPos,ROI_yPos,ROI_num	endif	if (Exists("ROI_BslnStart")==0)		Make/O/N=(0) ROI_BslnStart,ROI_BslnEnd	else		WAVE		ROI_BslnStart,ROI_BslnEnd	endif	if (Exists("ROI_size")==0)		Make/O/N=(0) ROI_size	else		WAVE		ROI_size	endif	Make/O/N=(0) xCenterWave,yCenterWave	i = 0	do		j = 0		do			if (theROI[i][j])				xCenterWave[numpnts(xCenterWave)] = {i}				yCenterWave[numpnts(yCenterWave)] = {j}				theSize += 1			endif			j += 1		while(j<DimSize(theROI,1))		i += 1	while(i<DimSize(theROI,0))	// Store away stats for new slot	Print "--- Storing ROI #"+JT_num2digstr(3,whichROI)+" at time "+time()+". ---"	WaveStats/Q xCenterWave	ROI_xPos[whichROI-1] = {V_avg}						// x centre	WaveStats/Q yCenterWave	ROI_yPos[whichROI-1] = {V_avg}						// y centre	ROI_num[whichROI-1] = {whichROI}					// ROI number	ROI_BslnStart[whichROI-1] = {frameBaseStart}		// baseline start	ROI_BslnEnd[whichROI-1] = {frameBaseEnd}			// basline end	ROI_size[whichROI-1] = {theSize}					// ROI size (in pixel terms!)		Duplicate/O theROI,$("theROI_"+JT_num2digstr(3,whichROI))				// Store ROI as pixels	print "Stored ROI mask in \""+"theROI_"+JT_num2digstr(3,whichROI)+"\""	LS_updateROImap()	WAVE	LS_xDraw	WAVE	LS_yDraw	Duplicate/O LS_xDraw,$("LS_xDraw_"+JT_num2digstr(3,whichROI))			// Store GraphDraw coordinates so that user can edit ROI later	Duplicate/O LS_yDraw,$("LS_yDraw_"+JT_num2digstr(3,whichROI))	print "Stored ROI drawing in \""+"LS_xDraw_"+JT_num2digstr(3,whichROI)+"\" and \""+"LS_yDraw_"+JT_num2digstr(3,whichROI)+"\""	WAVE		sourceTrace = $dFData	Duplicate/O	sourceTrace,$("ROI_Sweep_"+JT_num2digstr(3,whichROI))		// Store analyzed sweep	print "Stored sweep in \""+"ROI_Sweep_"+JT_num2digstr(3,whichROI)+"\""End//////////////////////////////////////////////////////////////////////////////////// Update map of all ROIs//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_doUpdateROImap(ctrlName) : ButtonControl	String ctrlName	DoWindow /K ROIViewer	LS_updateROImap()EndFunction LS_updateROImap()	NVAR		SizeToShow = SizeToShow	WAVE		TheImage = CurrentImage		SVAR		ImageFileName = ImageFileName	NVAR		ImageWidth = ImageWidth	NVAR		ImageHeight = ImageHeight		NVAR		blankEnd	NVAR		BlankCheckVar	//	NVAR		ImRegCheckxVar	NVAR		ScSc = ScSc	SVAR		dFData	// Frame scan stacks	NVAR		nFrames	WAVE/Z	AllImage1	WAVE/Z	AllImage2	WAVE		theROI	NVAR		frameBaseStart										// NOTE! Use this for frame scan analysis	NVAR		frameBaseEnd	Variable	xPosW = 292+28	Variable	yPosW = 50	Variable	Width = SizeToShow	Variable	Height = Width	Variable	i,j	Variable	size	NVAR		RecallROICounter	WAVE		theROI	Duplicate/O theROI,RecallTheROIs	RecallTheROIs = 0		i = 0	do		WAVE/Z	thisROI = $("theROI_"+JT_num2digstr(3,i+1))		RecallTheROIs = RecallTheROIs || thisROI									// Include ROI in map of all ROIs		i += 1	while(i<RecallROICounter)	// Update the ROIViewer graph showing all ROIs collected over green channel	Variable	AspectRatio	SVAR		RAT_Str	NVAR		LS_ModernLoadMode	DoWindow ROIViewer	if (!(V_flag))		if (LS_ModernLoadMode)			Variable x1,x2,y1,y2			String tempStr = StringByKey("SI.hRoiManager.imagingFovDeg",RAT_Str," = ",num2char(10))			// Structure of "SI.hRoiManager.imagingFovDeg" is "[-1.8 -1.8;1.8 -1.8;1.8 1.8;-1.8 1.8]", so get rid of brackets, then find corner coordinates			tempStr = tempStr[1,strLen(tempStr)-2]			x1 = str2num(StringFromList(0,StringFromList(0,tempStr,";")," "))			y1 = str2num(StringFromList(1,StringFromList(0,tempStr,";")," "))			x2 = str2num(StringFromList(0,StringFromList(2,tempStr,";")," "))			y2 = str2num(StringFromList(1,StringFromList(2,tempStr,";")," "))			AspectRatio = abs(y2-y1)/abs(x2-x1)		else			if (StrLen(StringByKey("state.acq.scanAmplitudeY",RAT_Str,"=","\r"))==0)				AspectRatio = abs(str2num(StringByKey("state.acq.scanAngularRangeSlow",RAT_Str,"=","\r"))/str2num(StringByKey("state.acq.scanAngularRangeFast",RAT_Str,"=","\r")))			else				AspectRatio = abs(str2num(StringByKey("state.acq.scanAmplitudeY",RAT_Str,"=","\r"))/str2num(StringByKey("state.acq.scanAmplitudeX",RAT_Str,"=","\r")))			endif		endif		// Left window		DoWindow /K ROIViewer		Display /W=(xPosW*ScSc,yPosW*ScSc,xPosW*ScSc+Width*ScSc,yPosW*ScSc+Height*ScSc) as "ROIs over Green Channel"		DoWindow /C ROIViewer		AppendImage /T TheImage1		SetAxis/A/R left		ModifyGraph height={Aspect,AspectRatio}		NVAR		LS_lowGreen		NVAR		LS_highGreen		ModifyImage TheImage1 ctab= {LS_lowGreen,LS_highGreen,Green,0}		//ctab= {*,*,Green,0}		ModifyGraph mirror=3		// Add ROIs		AppendMatrixContour/W=ROIViewer/T RecallTheROIs		ModifyContour/W=ROIViewer RecallTheROIs rgbLines=(65535,0,0),autoLevels={*,*,1},labels=0		ModifyGraph/W=ROIViewer lsize=1		// Add index wave		AppendToGraph/T ROI_yPos vs ROI_xPos		ModifyGraph mode(ROI_yPos)=3,msize(ROI_yPos)=4,rgb(ROI_yPos)=(65535,0,0),textMarker(ROI_yPos)={ROI_num,"default",0,0,5,0.00,0.00}		// Add buttons		Variable	lSp = 20		ControlBar lSp*2+2		Variable	bWid = 18		Variable 	bPos = 2	 	Variable 	yPos = 2		Variable	bSp = 1	 	Button KillItButton, pos={bPos,yPos}, size={bWid,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 60		Button RedrawButton, pos={bPos,yPos}, size={bWid,17},proc=LS_doUpdateROImap, title="Redraw",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 100		NVAR LS_operateOnROI		SetVariable operateRoiSV,pos={bPos,yPos+1},size={bWid,17},title="Which ROI",proc=LS_operateRoiSVProc,value=LS_operateOnROI,limits={1,Inf,1},fsize=10,font="Arial"	 	bPos += bWid+bSp	 	bPos = 2		// new line	 	yPos += lSp	 	bWid = 50		Button MoveAllButton, pos={bPos,yPos}, size={bWid,17},proc=LS_moveROIs, title="Move all",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 70		Button MoveCurrentButton, pos={bPos,yPos}, size={bWid,17},proc=LS_moveROIs, title="Move current",fSize=10,font="Arial"	 	bPos += bWid+bSp	 	bWid = 60		NVAR LS_moveROI_x		SetVariable moveROI_x_SV,pos={bPos,yPos},size={bWid,17},title=" x:",value=LS_moveROI_x,limits={-Inf,Inf,1},fsize=10,font="Arial"	 	bPos += bWid+bSp		NVAR LS_moveROI_y		SetVariable moveROI_y_SV,pos={bPos,yPos},size={bWid,17},title=" y:",value=LS_moveROI_y,limits={-Inf,Inf,1},fsize=10,font="Arial"	 	bPos += bWid+bSp	endif	DoWindow/F ROIViewerEnd//////////////////////////////////////////////////////////////////////////////////// Make ROI Sweeps Graph//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_makeROIsweepsGraph()	Variable i	NVAR		RecallROICounter	DoWindow/K ROISweepsGraph	Display /W=(330,100-50+220,700+100,300+220) as "ROI sweeps"	DoWindow/C ROISweepsGraph	i = 0	do		AppendToGraph $("ROI_Sweep_"+JT_num2digstr(3,i+1))		i += 1	while(i<RecallROICounter)	label left,"dG/R (%)"	label bottom,"time (s)"//	Legend//	Legend/C/N=text0/A=RC/J/E	JT_ArrangeGraphs2("ROISweepsGraph;",3,4) 	AutoPositionWindow/M=1/R=ROIViewer ROISweepsGraph 	CallColorizeTraces2() 	doUpdate 	JT_SpreadTracesInGraph() 	SmartYAxisRange() 	// Add labels 	Variable xPos,yPos 	xPos = 0	i = 0	SetDrawLayer UserFront	do		WAVE w = $("ROI_Sweep_"+JT_num2digstr(3,i+1))		yPos = w[0]		SetDrawEnv xcoord= prel,ycoord= left,fSize=9		DrawText xPos,yPos+ReadYOffset("ROI_Sweep_"+JT_num2digstr(3,i+1)),JT_num2digstr(3,i+1)		i += 1	while(i<RecallROICounter)		ControlBar/T 22	Variable bx	Variable by	Variable	bSize	Variable bSp = 2	if (Exists("LS_Detect_nSigma")==0)		Variable/G LS_Detect_nSigma = 1	else		NVAR LS_Detect_nSigma	endif	if (Exists("LS_minBlipDur")==0)		Variable/G LS_minBlipDur = 1	else		NVAR LS_minBlipDur	endif	bx = 2	by = 4	bSize = 50 	Button CloseButton,pos={bx,by},size={bSize,17},proc=JT_WinCloseProc,title="Close",fSize=10,font="Arial" 	bx += bSize+bSp 	Button RedrawButton,pos={bx,by},size={bSize,17},proc=LS_RedrawROIsweepsGraphProc,title="Redraw",fSize=10,font="Arial" 	bx += bSize+bSp 	Button sizeButton,pos={bx,by},size={bSize,17},proc=JT_WinResizeProc,title="Resize",fSize=10,font="Arial" 	bx += bSize+bSp 	Button detectBlipsButton,pos={bx,by},size={bSize,17},proc=LS_DetectBlipsProc,title="Detect",fSize=10,font="Arial" 	bx += bSize+bSp	SetVariable SigmaSV,pos={bx,by},size={bSize*2,17},title="nSigma",value=LS_Detect_nSigma,limits={0.5,Inf,0.5},fsize=10,font="Arial" 	bx += bSize*2+bSp	SetVariable minBlipDurSV,pos={bx,by},size={bSize*2,17},title="Min dur (s)",value=LS_minBlipDur,limits={0.1,Inf,0.1},fsize=10,font="Arial" 	bx += bSize*2+bSpEnd//////////////////////////////////////////////////////////////////////////////////// Redraw ROI-sweeps graphFunction LS_RedrawROIsweepsGraphProc(ctrlName) : ButtonControl	String ctrlName		LS_makeROIsweepsGraph()	End//////////////////////////////////////////////////////////////////////////////////// Detect calcium blips in the ROI-sweeps graphFunction LS_DetectBlipsProc(ctrlName) : ButtonControl	String ctrlName		doDetectBlips()	EndFunction doDetectBlips()	Print "--- Detecting calcium blips ---"	Print Date(),Time()	Variable i,j,k	NVAR		RecallROICounter	NVAR		LS_Detect_nSigma	NVAR		LS_minBlipDur		Make/O/N=(0) blipROIsource,blipStart,blipDuration,blipMax,blipMean	Make/O/N=(RecallROICounter) nBlipsPerROIwave	Variable blipCounter = 0	Variable	maxBlips = 0		// Maximum number of blips for any one ROI	DoWindow/F ROISweepsGraph 	// Add lines 	Variable yPos,yOffs 	Variable	upStrokes,downStrokes	i = 0	SetDrawLayer/K UserBack	do		WAVE w = $("ROI_Sweep_"+JT_num2digstr(3,i+1))		WaveStats/Q w		yOffs = ReadYOffset("ROI_Sweep_"+JT_num2digstr(3,i+1))		yPos = V_SDev*LS_Detect_nSigma + yOffs			// Baseline is by definition at zero; ignoring mean of sweep		SetDrawEnv xcoord= prel,ycoord= left,dash=1		DrawLine 0,yPos,1,yPos		FindLevels/Q/DEST=LS_upStrokesWave/EDGE=1 w,V_SDev*LS_Detect_nSigma		upStrokes = V_LevelsFound		FindLevels/Q/DEST=LS_downStrokesWave/EDGE=2 w,V_SDev*LS_Detect_nSigma		downStrokes = V_LevelsFound		// Special case 1: If first downstroke is before first upstroke		if (LS_downStrokesWave[0]<LS_upStrokesWave[0])			DeletePoints 0,1,LS_downStrokesWave		endif		// Special case 2: If last event detected did not finish in this sweep...		if (downStrokes<upStrokes)			LS_downStrokesWave[numpnts(LS_downStrokesWave)] = {pnt2x(w,numpnts(w)-1)}		endif		// Eliminate durations that are too short		if (numpnts(LS_downStrokesWave)>0)			j = 0			do				if (LS_downStrokesWave[j]-LS_upStrokesWave[j] < LS_minBlipDur)					DeletePoints j,1,LS_downStrokesWave,LS_upStrokesWave				else					j += 1				endif			while(j<numpnts(LS_downStrokesWave))		endif		// Plot events and do stats		if (numpnts(LS_downStrokesWave)>0)			if (numpnts(LS_downStrokesWave)>maxBlips)			// Find ROI with most blips				maxBlips = numpnts(LS_downStrokesWave)			endif			j = 0			do				SetDrawEnv xcoord=bottom,ycoord=left,lineThick=2				DrawLine LS_upStrokesWave[j],yPos,LS_downStrokesWave[j],yPos				SetDrawEnv xcoord=bottom,ycoord=left,fSize=8,fStyle=2,textxjust=1				DrawText (LS_upStrokesWave[j]+LS_downStrokesWave[j])/2,yPos,num2str(blipCounter)				// Collect stats				blipROIsource[blipCounter] = {i+1}				blipStart[blipCounter] = {LS_upStrokesWave[j]}				blipDuration[blipCounter] = {LS_downStrokesWave[j]-LS_upStrokesWave[j]}				WaveStats/Q/R=(LS_upStrokesWave[j],LS_downStrokesWave[j]) w				blipMax[blipCounter] = {V_max}				blipMean[blipCounter] = {V_avg}				blipCounter += 1				j += 1			while(j<numpnts(LS_downStrokesWave))		endif		nBlipsPerROIwave[i] = numpnts(LS_downStrokesWave)		i += 1	while(i<RecallROICounter)		Print "Found "+num2str(numpnts(blipROIsource))+" blips"	WaveStats/Q blipDuration	Print "\tBlip duration:",V_avg,"±",V_SEM	WaveStats/Q blipMax	Print "\tBlip max:",V_avg,"±",V_SEM	WaveStats/Q blipMean	Print "\tBlip mean:",V_avg,"±",V_SEM		doWindow/K blipTable	Edit blipROIsource,blipStart,blipDuration,blipMax,blipMean as "Blip Stats"	doWindow/C blipTable	JT_ArrangeGraphs2("blipTable;",2,4)		// Plot BlipRaster	doWindow/K blipRasterGraph	Display /W=(652,73,1353,464) blipROIsource vs blipStart as "Blip Raster"	doWindow/C blipRasterGraph	ModifyGraph mode=3	ModifyGraph marker=10	ModifyGraph msize=8	ModifyGraph rgb=(19275,26985,49601)	ModifyGraph manTick(left)={0,1,0,0},manMinor(left)={0,0}	ModifyGraph nticks(bottom)=3	SetAxis/A/R left	SetAxis/A/N=1/E=1 bottom	label left,"ROI number"	label bottom,"time (s)"	JT_addCloseButton()	AutoPositionWindow/M=0/R=blipTable blipRasterGraph		// Export blipStart and blipDuration to clipboard	String	clipBoardStr = ""	String	infoTypeList = "_start;_dur"	k = 0		// Conditions	do		i = 0		// Blips		do			clipBoardStr += "ROI"+JT_num2digstr(3,i+1)+StringFromList(k,infoTypeList)			if (i<RecallROICounter-1)				clipBoardStr += "\t"			else				clipBoardStr += "\r"			endif			i += 1		while(i<RecallROICounter)				i = 0		do			j = 0		// ROIs			do				clipBoardStr += num2str(nthBlipInfoForThisROI(i,j+1,k))				if (j<RecallROICounter-1)					clipBoardStr += "\t"				else					clipBoardStr += "\r"				endif				j += 1			while(j<RecallROICounter)			i += 1		while(i<maxBlips)		// A couple of blank rows between the two types of info 		if (k==0)			clipBoardStr += "\r"			clipBoardStr += "\r"		endif		k += 1	while(k<2)		PutScrapText clipBoardStr		Print "*** BlipStart and blipDuration info is now on the clipboard, ready to be pasted into Excel! ***"	End//////////////////////////////////////////////////////////////////////////////////// Find the nth blip for a given ROI, return asked-for dataFunction nthBlipInfoForThisROI(blipNo,ROIno,returnDuration)	Variable	blipNo				// Starts counting from zero	Variable	ROIno					// Starts counting from one	Variable	returnDuration		// Boolean: Return blipDuration if True, otherwise return blipStart		WAVE 	blipROIsource,blipStart,blipDuration		Variable	n = numpnts(blipROIsource)	if (n==0)							// No blips at all		Return NaN			endif		Variable	startIndex	Variable	i	i = 0	do		if (blipROIsource[i]==ROIno)			startIndex = i			i = Inf		endif		i += 1	while(i<n)		if (startIndex+blipNo>n-1)	// Not enough data or not enough blips for last ROI		Return NaN	endif	if (blipROIsource[startIndex+blipNo]!=ROIno)	// Not enough blips for this ROI		Return NaN	endif	if (returnDuration)		Return (blipDuration[startIndex+blipNo])	else		Return (blipStart[startIndex+blipNo])	endifEnd//////////////////////////////////////////////////////////////////////////////////// Make green and red graphFunction Make_Green_and_Red_Proc(ctrlName) : ButtonControl	String ctrlName		Make_Green_and_Red_Graph()	EndFunction Make_Green_and_Red_Graph()	DoWindow/K Green_and_Red	Display /W=(292,260,701,440) DumWaveG as "Green and Red"	nw("Green and Red")	AppendToGraph/R DumWaveR	ModifyGraph rgb(DumWaveG)=(0,65535,0)	ModifyGraph zero(left)=2	ModifyGraph fSize=12	Label left,"green"	Label right,"red"	SetAxis/A=2 left	SetAxis/A=2 right	ControlBar 22	Variable bWid = 20	Variable bPos = 2 	Button KillItButton, pos={bPos,2}, size={bWid,17},proc=KillItProc, title="X",fSize=10,font="Arial" 	bPos += bWid+4 	bWid = 40 	 	ReadFirstAndLastFluorescence() 	NVAR		firstG,lastG 	NVAR		firstR,lastR 	print "Green:",firstG,"to",lastG," -- in percent:",lastG/firstG*100 	print "Red:",firstR,"to",lastR," -- in percent:",lastR/firstR*100 		Legend/C/N=text0/J "Green: "+num2str(lastG/firstG*100)+"%\rRed: "+num2str(lastR/firstR*100)+"%" 	End//////////////////////////////////////////////////////////////////////////////////// Read first and last fluorescence levels in green and in red channelsFunction ReadFirstAndLastFluorescence() 	variable/G	firstG,lastG 	variable/G	firstR,lastR 		firstG = mean(DumWaveG,0,10e-3) 	lastG = mean(DumWaveG,rightX(DumWaveG)-10e-3,rightX(DumWaveG)) 		firstR = mean(DumWaveR,0,10e-3) 	lastR = mean(DumWaveR,rightX(DumWaveR)-10e-3,rightX(DumWaveR))End//////////////////////////////////////////////////////////////////////////////////// Zoom in on relevant region in top graphFunction ZoomInProc(ctrlName) : ButtonControl	String ctrlName		Variable 	Keys = GetKeyState(0)	Variable	Shift = 0	if (Keys & 2^2)		Shift = 1	endif	if (Shift)		SetAxis/A bottom		SetAxis/A left	else		Nice_xAxisRange()		LS_SmartYAxisRange()	endifEnd//////////////////////////////////////////////////////////////////////////////////// Set Y axis range to min and max of current wavesFunction LS_SmartYAxisRange()	String		Name = WinName(0,1)		String		TraceList = TraceNameList("",";",1)		//WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(TraceList)	String		currWave		GetAxis/W=$Name /Q bottom	Variable	xMin = V_min	Variable	xMax = V_max		Variable	yMax = -Inf	Variable	yMin = Inf		Variable	i		Variable	xOffset,yOffset		i = 0	do		currWave = StringFromList(i,TraceList)//		print "\tWorking on:",currWave		yOffset = LS_ReadYOffset(currWave)		WaveStats/Q/R=(xMin,xMax)/Z $currWave		if (yMax<V_max+yOffset)			yMax = V_max+yOffset		endif		if (yMin>V_min+yOffset)			yMin = V_min+yOffset		endif		i += 1	while(i<nWaves)	SetAxis/W=$Name left,yMin,yMaxEndFunction LS_ReadYOffset(wName)	String		wName	String		InfoStr = TraceInfo("",wName,0)	String		ExtrStr = StringByKey("offset(x)",InfoStr,"=",";")	Variable	xOffset,yOffset	sscanf		ExtrStr,"{%f,%f}", xOffset, yOffset	Return		yOffsetEnd//************************************************************************************//	Smoothing//////************************************************************************************Function SmoothTraces(ctrlName) :ButtonControl	String ctrlName	String stemp	String SmoothData	NVAR SPoints	SVAR dFData	stemp = ctrlName[strlen(ctrlName)-7 , strlen(ctrlName)-1]		if(stringmatch(stemp, "SmthWav"))		if(mod(SPoints,2))			SmoothData = dFData + "_smth"			Duplicate /O $dFData, $SmoothData; DelayUpdate			Smooth /S=2 SPoints, $SmoothData			Display $SmoothData vs TimeAxis; DelayUpdate		else			DoAlert 0, "Smoothing points must be an odd number."			return -1		endif	endifEnd//************************************************************************************// Get PathName////************************************************************************************Function /S GetPathNameLS(fname) // extract file name from the full directory path name	String fname // full directory path name		Variable icnt, lasti		lasti = strlen(fname)-1		for (icnt = lasti; icnt >= 0; icnt -= 1)  		if (StringMatch(fname[icnt], ":") == 1) // found right-most colon within filename			break		endif	endfor		return fname[0, icnt]End // GetPathName//****************************************************************//****************************************************************//****************************************************************Function /S GetFileNameLS(fname) // extract file name from the full directory path name	String fname // full directory path name		Variable icnt, lasti		lasti = strlen(fname)-1		for (icnt = lasti; icnt >= 0; icnt -= 1)  		if (StringMatch(fname[icnt], ":") == 1) // found right-most colon within filename			break		endif	endfor		return fname[icnt+1, lasti]End // GetFileName//****************************************************************// Set calcuration mode////****************************************************************Function CalcModeSet(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr		NVAR Calc_mode		strswitch(popStr)		case "DG/G":			Calc_mode = 0			break		case "DG/R":			Calc_mode = 1			break		case "R/G":			Calc_mode = 2			break	endswitchEnd//////////////////////////////////////////////////////////////////// Set the order of the channels	// Note to self:	//		- When channels are *not* flipped, then green is channel 1, and red is channel 2	//		- When channels *are* flipped, then red is channel 1, and green is channel 2Function ChannelOrderSet(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr		NVAR	flipCh = flipCh		flipCh = popNum-1		switch(flipCh)		case 0:			Print "Option #1:\t\t\tChannel 1 is GREEN, Channel 2 is RED."			break		case 1:			Print "Option #2:\t\t\tChannel 1 is RED, Channel 2 is GREEN."			break		default:			Beep;Print "Strange error in {ChannelOrderSet}"	endswitch		MakeLineScanPanel() // This will ensure that the "Channel:" pop-up menu is redrawn	End//****************************************************************// Set View Channel////****************************************************************Function ViewChanSet(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr		NVAR	CurrentChannel	NVAR	ImageWidth	NVAR	ImageHeight	WAVE	CurrentImage	WAVE	AllImage		NVAR	flipCh = flipCh		strswitch(popStr[0,1])		case "Re":			CurrentChannel = 1			break		case "Gr":			CurrentChannel = 0			break	endswitch		//	Flip channels?	if (flipCh)		CurrentChannel = 1-CurrentChannel 	// Flip channels	endif	DoWindow ImageViewer	if(V_flag == 1)			TransferImage()		ProduceImage()	endifEnd/////////////////////////////////////////////////////////////////////////// Kill frame viewFunction KillFrameViewProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K ImageViewer	DoWindow/K ImageViewer2	DoWindow/K ImageViewer3	DoWindow/K ImageViewer4	DoWindow/K ImageViewer5		DoWindow/K ROI_Controls	End		/////////////////////////////////////////////////////////////////////////// Clear ROIFunction ClearROIProc(ctrlName) : ButtonControl	String ctrlName			DoWindow/F ImageViewer2	if (V_flag)		print "Killing ROI and BG."		WAVE	theROI		WAVE	theBG		theROI = 0		theBG = 0//		SetDrawLayer/K ProgFront		Set_ROI_Looks()		if (StrSearch(ContourNameList("ImageViewer",";"),"theROI",0)!=-1)			do				RemoveContour/W=ImageViewer theROI			while(StrSearch(ContourNameList("ImageViewer",";"),"theROI",0)!=-1)		endif		if (StrSearch(ContourNameList("ImageViewer",";"),"theBG",0)!=-1)			do				RemoveContour/W=ImageViewer theBG			while(StrSearch(ContourNameList("ImageViewer",";"),"theBG",0)!=-1)		endif	else		print "{ClearROIProc} Strange error: ImageViewer not found"	endifEnd/////////////////////////////////////////////////////////////////////////// Convert graph drawing to a polygon, that can then in turn be // converted to an image mask//// NOTE: This is for Airi's astrocyte movie analysis!!!Function LS_ConvertGraphDrawingToPoly()	if (Exists("LS_xDraw")==0)		print "You must draw a region of interest first!"	endif	WAVE	LS_xDraw	WAVE	LS_yDraw		if (numpnts(LS_xDraw)==0)		print "You must draw a region of interest first!"	endif	// In case user did not press "Done" first		DoWindow/F ImageViewer1	GraphNormal	DoWindow/F ImageViewer2	GraphNormal		SetDrawLayer/W=ImageViewer2/K ProgFront				// This empties UserFront	SetDrawEnv/W=ImageViewer2 xcoord= top,ycoord= left,linefgc= (65535,65535,0),fillpat= 0	DrawPoly/W=ImageViewer2/ABS 0,0,1,1,LS_xDraw,LS_yDraw  End	/////////////////////////////////////////////////////////////////////////// Pick ROIFunction PickROIProc(ctrlName) : ButtonControl	String		ctrlName	SVAR		ImRegPolyStr	NVAR		ImRegCheckVar	Variable	addMode = 0	Variable	Keys = GetKeyState(0)	if (StrLen(ctrlName)>0)		// Only read Shift key if called properly with button, not if called from a loop/other function		if (Keys & 2^2)			Print "Holding shift key --> Adding ROI to existing ROI."			addMode = 1		else			if (Keys & 2^0)				Print "Holding command key --> Subtracting ROI from existing ROI."				addMode = 2			endif		endif	endif		WAVE		theROI	WAVE		theBG		DoWindow/F ImageViewer2	if (V_flag)		print "Picking ROI bitmap."		LS_ConvertGraphDrawingToPoly()		if (StringMatch(ctrlName,"PickROIButton"))		// If button is pressed, then get polygon string from red channel image			if (ImRegCheckVar)				print "\tPicking polygon ROI and reference image for image registration."				ImRegPolyStr = LS_GetPolyStrFromViewer()				Duplicate/O TheImage2,ImRegRef				// Store away reference image				Note/K ImRegRef,ImRegPolyStr			endif		endif		ImageGenerateROIMask TheImage2		if (V_flag)			WAVE	M_ROIMask			switch(addMode)	// numeric switch				case 0:					Duplicate/O M_ROIMask,theROI					break				case 1:					theROI = theROI %| M_ROIMask					break				case 2:					theROI = theROI %& (!(theROI %& M_ROIMask))					break				default:							// optional default expression executed					Abort "Strange error in PickROIProc."			endswitch			Set_ROI_Looks()			if (StrSearch(ContourNameList("ImageViewer",";"),"theROI",0)==-1)				AppendMatrixContour/W=ImageViewer/T theROI			endif			ModifyContour/W=ImageViewer theROI rgbLines=(65535,65535,0),autoLevels={*,*,1},labels=0			ModifyGraph/W=ImageViewer lsize=1			CheckForOverlap()		else			print "ROI error"		endif	else		print "{PickROIProc} Strange error: ImageViewer2 not found"	endifEnd/////////////////////////////////////////////////////////////////////////// Pick Image Registration MaskFunction PickImRegMaskProc(ctrlName) : ButtonControl	String ctrlName		NVAR	ImRegCheckVar		if (ImRegCheckVar==0)		Print "Please check Image Registration checkbox to use this feature."		Abort "Please check Image Registration checkbox to use this feature."	endif			Variable addMode = 0	Variable Keys = GetKeyState(0)	if (Keys & 2^2)		Print "Holding shift key --> Adding ImRegMask to existing ImRegMask"		addMode = 1	else		if (Keys & 2^0)			Print "Holding command key --> Subtracting ImRegMask from existing ImRegMask"			addMode = 2		endif	endif		WAVE		ImRegMask	DoWindow/F ImageViewer2	if (V_flag)		print "Picking Image Registration Mask."		ImageGenerateROIMask TheImage2		if (V_flag)			WAVE	M_ROIMask			switch(addMode)	// numeric switch				case 0:					Duplicate/O M_ROIMask,ImRegMask					Redimension/S ImRegMask		// This should be single precision float!					break				case 1:					ImRegMask = ImRegMask %| M_ROIMask					break				case 2:					ImRegMask = ImRegMask %& (!(ImRegMask %& M_ROIMask))					break				default:							// optional default expression executed					Abort "Strange error in PickImRegMaskProc."			endswitch			Set_ROI_Looks()			if (StrSearch(ContourNameList("ImageViewer",";"),"ImRegMask",0)==-1)				AppendMatrixContour/W=ImageViewer/T ImRegMask			endif			ModifyContour/W=ImageViewer ImRegMask rgbLines=(65535,32768,40777),autoLevels={*,*,1},labels=0			ModifyGraph/W=ImageViewer lsize=1//			CheckForOverlap()			Duplicate/O ImRegMask,ImRegMaskRef,ImRegMaskTest		// Note! ImageRegistration will manipulate ImRegMask			Redimension/S ImRegMaskRef,ImRegMaskTest				// This should be single precision float!		else			print "ImRegMask error"		endif	else		print "{PickImRegMaskProc} Strange error: ImageViewer2 not found"	endifEnd/////////////////////////////////////////////////////////////////////////// Pick BGFunction PickBGProc(ctrlName) : ButtonControl	String ctrlName			Variable addMode = 0	Variable Keys = GetKeyState(0)	if (Keys & 2^2)		Print "Holding shift key --> Adding BG to existing BG"		addMode = 1	else		if (Keys & 2^0)			Print "Holding command key --> Subtracting BG from existing BG"			addMode = 2		endif	endif		WAVE		theROI	WAVE		theBG	DoWindow/F ImageViewer2	if (V_flag)		print "Picking BG."		LS_ConvertGraphDrawingToPoly()		ImageGenerateROIMask TheImage2		if (V_flag)			WAVE	M_ROIMask			switch(addMode)	// numeric switch				case 0:					Duplicate/O M_ROIMask,theBG					break				case 1:					theBG = theBG %| M_ROIMask					break				case 2:					theBG = theBG %& (!(theBG %& M_ROIMask))					break				default:							// optional default expression executed					Abort "Strange error in PickBGProc."			endswitch			Set_ROI_Looks()			if (StrSearch(ContourNameList("ImageViewer",";"),"theBG",0)==-1)				AppendMatrixContour/W=ImageViewer/T theBG			endif			ModifyContour/W=ImageViewer theBG rgbLines=(32768,40777,65535),autoLevels={*,*,1},labels=0			ModifyGraph/W=ImageViewer lsize=1			CheckForOverlap()		else			print "BG error"		endif	else		print "{PickBGProc} Strange error: ImageViewer2 not found"	endifEnd/////////////////////////////////////////////////////////////////////////// If ROI and BG overlap, produce warningFunction CheckForOverlap()	WAVE		theROI	WAVE		theBG	Duplicate/O theBG,tempMask	tempMask = theBG %& theROI	imageStats tempMask	if (V_avg!=0)		print "=== WARNING!! ==="		print "ROI and BG are overlapping! You should avoid this!";Beep	endif	KillWaves tempMaskEnd/////////////////////////////////////////////////////////////////////////// Set ROI looksFunction Set_ROI_Looks()	SetDrawLayer ProgFront	DrawAction beginInsert=0	SetDrawEnv linefgc= (65535,65535,0),fillpat= 0,xcoord= top,ycoord= left, saveEnd/////////////////////////////////////////////////////////////////////////// Choose which green frame to viewFunction FrameSliderProc(sa) : SliderControl	STRUCT WMSliderAction &sa		NVAR	ImageWidth	NVAR	ImageHeight	NVAR	nFrames	NVAR	frameHeight	WAVE	AllImageRAW		NVAR	FrameFlag	WAVE	TheImage1	WAVE	AllImage1		NVAR	flipCh		NVAR	frameNumber	switch( sa.eventCode )		case -1: // kill			break		default:			if( sa.eventCode & 2^0 ) // value set -- pick a frame				frameNumber = sa.curval				imagetransform/P=(frameNumber) getplane AllImage1				WAVE		M_ImagePlane				Duplicate/O M_ImagePlane,TheImage1//				TheImage1[0,ImageWidth-1][0,frameHeight-1] = AllImage1[p][q][frameNumber]				ControlInfo/W=ImageViewer AutoLUTCheck				LS_doToggleGreenAuto(V_value)//				ImageStats AllImage1//				ModifyImage/W=ImageViewer TheImage1 ctab= {V_min,V_max,Green,0}				DoUpdate			endif			if( sa.eventCode & 2^2 ) // mouse up -- maximum intensity projection				print "Reverting to mean intensity projection"				LS_MaxIntensProj()//				ImageTransform/METH=2 zProjection,AllImage1//				Duplicate/O M_zProjection,TheImage1				ControlInfo/W=ImageViewer AutoLUTCheck				LS_doToggleGreenAuto(V_value)//				ModifyImage/W=ImageViewer TheImage1 ctab= {*,*,Green,0}			endif			break	endswitch	return 0EndFunction LS_MaxIntensProj()	NVAR	blankCheckVar	NVAR	blankEnd//	NVAR	dt	NVAR	frameRate		Variable	blankEndInTime = Floor(blankEnd/(1e3/frameRate))	WAVE	AllImage1	if (blankCheckVar)		print "\t** Warning! ** \t Blanking is on: Only using frames after frame #"+num2str(blankEndInTime)+" for this projection"		Duplicate/O/R=[,][,][blankEndInTime,] AllImage1,tempImage		ImageTransform/METH=2 zProjection,tempImage		Duplicate/O M_zProjection,TheImage1	else		ImageTransform/METH=2 zProjection,AllImage1		Duplicate/O M_zProjection,TheImage1	endifEnd	/////////////////////////////////////////////////////////////////////////////////Function ModImSizeProc(SV_Struct) : SetVariableControl	STRUCT WMSetVariableAction &SV_Struct	switch( SV_Struct.eventCode )		case 1:		case 2:			ProduceImage()			break	endswitch	return 0EndFunction ProduceImage()			NVAR		SizeToShow = SizeToShow	WAVE		TheImage = CurrentImage		SVAR		ImageFileName = ImageFileName	NVAR		ImageWidth = ImageWidth	NVAR		ImageHeight = ImageHeight	NVAR		FrameFlag		NVAR		blankEnd	NVAR		BlankCheckVar		NVAR		ImRegCheckVar	NVAR		ScSc = ScSc	// Frame scan stacks	NVAR		nFrames	WAVE/Z	AllImage1	WAVE/Z	AllImage2	Variable	xPos = 292+28	Variable	yPos = 50	Variable	Width = SizeToShow	Variable	Height = Width	Variable	nButtons	Variable	fade	Variable	i	Variable	gap	Variable	ySp = 24	Variable	size		Variable	AspectRatio	SVAR		RAT_Str	NVAR		LS_ModernLoadMode	if (FrameFlag)		LS_MaxIntensProj()		ImageTransform/METH=2 zProjection,AllImage2		Duplicate/O M_zProjection,TheImage2		if (LS_ModernLoadMode)			Variable x1,x2,y1,y2			String tempStr = StringByKey("SI.hRoiManager.imagingFovDeg",RAT_Str," = ",num2char(10))			// Structure of "SI.hRoiManager.imagingFovDeg" is "[-1.8 -1.8;1.8 -1.8;1.8 1.8;-1.8 1.8]", so get rid of brackets, then find corner coordinates			tempStr = tempStr[1,strLen(tempStr)-2]			x1 = str2num(StringFromList(0,StringFromList(0,tempStr,";")," "))			y1 = str2num(StringFromList(1,StringFromList(0,tempStr,";")," "))			x2 = str2num(StringFromList(0,StringFromList(2,tempStr,";")," "))			y2 = str2num(StringFromList(1,StringFromList(2,tempStr,";")," "))			AspectRatio = abs(y2-y1)/abs(x2-x1)		else			if (StrLen(StringByKey("state.acq.scanAmplitudeY",RAT_Str,"=","\r"))==0)				AspectRatio = abs(str2num(StringByKey("state.acq.scanAngularRangeSlow",RAT_Str,"=","\r"))/str2num(StringByKey("state.acq.scanAngularRangeFast",RAT_Str,"=","\r")))			else				AspectRatio = abs(str2num(StringByKey("state.acq.scanAmplitudeY",RAT_Str,"=","\r"))/str2num(StringByKey("state.acq.scanAmplitudeX",RAT_Str,"=","\r")))			endif		endif		// Left window		if (Exists("LS_xDraw")==0)			Make/O/N=(0) LS_xDraw,LS_yDraw		endif		DoWindow /K ImageViewer		Display /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as "Green"		DoWindow /C ImageViewer		AppendImage/T TheImage1		AppendToGraph/T LS_yDraw vs LS_xDraw		ModifyGraph RGB(LS_yDraw)=(65535,65535,0),mode(LS_yDraw)=0,lstyle(LS_yDraw)=11		SetAxis/A/R left		ModifyGraph height={Aspect,AspectRatio}		ControlBar 22+20		Variable bx		Variable by		Variable	bSize		Variable bSp = 2		bx = 2		by = 4		NVAR	LS_autoGreen		bSize = 40		CheckBox AutoLUTCheck,pos={bx,by},size={bSize,17},title="Auto",value=(LS_autoGreen),proc=LS_toggleGreenAutoProc,fSize=10,font="Arial"	 	bx += bSize+bSp		bSize = 70		SetVariable lowEndSV,pos={bx,by},size={bSize,17},proc=LS_setGreenToManualProc,title="lo",value=LS_lowGreen,limits={-Inf,Inf,100},fsize=10,font="Arial"	 	bx += bSize+bSp		SetVariable highEndSV,pos={bx,by},size={bSize,17},proc=LS_setGreenToManualProc,title="hi",value=LS_highGreen,limits={-Inf,Inf,100},fsize=10,font="Arial"	 	bx += bSize+bSp		bSize = 50	 	Button SetToAutoButton,pos={bx,by},size={bSize,17},proc=LS_setGreenToAutoProc,title="Auto set",fSize=10,font="Arial"	 	bx += bSize+bSp	 	bx = 2	 	by += 20		bSize = 40	 	Button GraphWaveDrawButton1,pos={bx,by},size={bSize,17},proc=LS_GraphWaveDrawProc,title="Draw",fSize=10,font="Arial"	 	bx += bSize+bSp	 	Button GraphWaveDoneButton1,pos={bx,by},size={bSize,17},proc=LS_GraphWaveDoneProc,title="Done",fSize=10,font="Arial"	 	bx += bSize+bSp	 	Button GraphWaveEditButton1,pos={bx,by},size={bSize,17},proc=LS_GraphWaveEditProc,title="Edit",fSize=10,font="Arial"	 	bx += bSize+bSp	 	Button ClearGraphWaveButton,pos={bx,by},size={bSize,17},proc=LS_ClearGraphWaveProc,title="Clear",fSize=10,font="Arial"	 	bx += bSize+bSp		LS_doToggleGreenAuto(LS_autoGreen)		ModifyGraph mirror=3		if (Exists("theROI")!=0)			AppendMatrixContour/W=ImageViewer/T theROI			ModifyContour/W=ImageViewer theROI rgbLines=(65535,65535,0),autoLevels={*,*,1},labels=0			ModifyGraph/W=ImageViewer lsize=1		endif		if (Exists("theBG")!=0)			AppendMatrixContour/W=ImageViewer/T theBG			ModifyContour/W=ImageViewer theBG rgbLines=(32768,40777,65535),autoLevels={*,*,1},labels=0			ModifyGraph/W=ImageViewer lsize=1		endif	 	if (ImRegCheckVar)			if (Exists("ImRegMask")!=0)				AppendMatrixContour/W=ImageViewer/T ImRegMask				ModifyContour/W=ImageViewer ImRegMask rgbLines=(65535,32768,40777),autoLevels={*,*,1},labels=0				ModifyGraph/W=ImageViewer lsize=1			endif		endif		//// Create control panel	 ////		nButtons = 5		fade = 2		i = 0		gap = 6		size = Floor(Width/(nButtons+1))-gap		DoWindow /F ImageViewer			// Avoid Igor Bug		NewPanel/EXT=2/FLT=0/HOST=ImageViewer/K=2/N=ROI_Controls/W=(0,1,gap+(size+gap)*nButtons,2+ySp*4) as "Controls for "+ImageFileName		// /FLT=1 before, but I don't know why	 	Button KillItButton, pos={gap+(size+gap)*i,2}, size={size,20},proc=KillFrameViewProc, title="Close",fSize=10,font="Arial"	 	i += 1	 	Button ClearROIButton, pos={gap+(size+gap)*i,2}, size={size,20},proc=ClearROIProc, title="Clear",fSize=10,font="Arial"	 	i += 1	 	Button PickROIButton, pos={gap+(size+gap)*i,2}, size={size,20},proc=PickROIProc, title="ROI",fSize=10,font="Arial"	 	i += 1	 	Button PickBGButton, pos={gap+(size+gap)*i,2}, size={size,20},proc=PickBGProc, title="BG",fSize=10,font="Arial"	 	i += 1	 	Button PickMaskButton, pos={gap+(size+gap)*i,2}, size={size,20},proc=PickImRegMaskProc, title="Mask",fSize=10,font="Arial"	 	i += 1	 	SVAR	SuffixStr		PopupMenu StoreROIPopUp, title="Store ROI & BG", mode=0, pos={gap,2+ySp},size={110,17}, value=#"SuffixStr", proc=LS_StoreROIProc, help={"Store away ROI and BG for a given condition."}		PopupMenu StoreROIPopUp bodyWidth=110,fSize=10,font="Arial"		PopupMenu StoreImRegPopUp, title="Store ImReg data", mode=0, pos={gap+110+4,2+ySp},size={gap+(size+gap)*nButtons-110-gap-10,17}, value=#"SuffixStr", proc=LS_StoreImRegProc, help={"Store away image registration data for a given condition."}		PopupMenu StoreImRegPopUp bodyWidth=gap+(size+gap)*nButtons-110-gap-10,fSize=10,font="Arial"	 	Slider FrameSlider, pos={gap,2+ySp*2}, size={size*(nButtons-1)+gap*2,10},ticks=20,vert=0,variable=frameNumber,limits={0,nFrames-1,1},proc=FrameSliderProc,font="Arial",fSize=10		SetVariable showFrameSetVar title="#", size={size,20},value=frameNumber,noedit=1		SetVariable showFrameSetVar limits={-inf,inf,0},live=1,frame=0,font="Arial",fSize=10		SetVariable showFrameSetVar fstyle=1,pos={gap+(size+gap)*(nButtons-1),2+ySp*2}		DefaultGUIFont/W=ImageViewer popup={"Arial",10,1},all={"Arial",10,0}	 	SetActiveSubwindow _endfloat_		// Right window		DoWindow /K ImageViewer2		Display /W=(xPos*ScSc+Width*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as "Red"		DoWindow /C ImageViewer2		AppendImage /T TheImage2		AppendToGraph/T LS_yDraw vs LS_xDraw		ModifyGraph RGB(LS_yDraw)=(65535,65535,0),mode(LS_yDraw)=0,lstyle(LS_yDraw)=11		SetAxis/A/R left		ModifyGraph height={Aspect,AspectRatio}		ModifyGraph mirror=3		Set_ROI_Looks()		ControlBar 22+20		bx = 2		by = 4		NVAR	LS_autoRed		bSize = 40		CheckBox AutoLUTRedCheck,pos={bx,by},size={bSize,17},title="Auto",value=(LS_autoRed),proc=LS_toggleRedAutoProc,fSize=10,font="Arial"	 	bx += 42	 	bSize = 70		SetVariable lowEndRedSV,pos={bx,by},size={bSize,17},proc=LS_setRedToManualProc,title="lo",value=LS_lowRed,limits={-Inf,Inf,100},fsize=10,font="Arial"	 	bx += bSize+bSp		SetVariable highEndRedSV,pos={bx,by},size={bSize,17},proc=LS_setRedToManualProc,title="hi",value=LS_highRed,limits={-Inf,Inf,100},fsize=10,font="Arial"	 	bx += bSize+bSp	 	bSize = 50	 	Button SetToAutoRedButton,pos={bx,by},size={bSize,17},proc=LS_setRedToAutoProc,title="Auto set",fSize=10,font="Arial"	 	bx += bSize+bSp	 	bx = 2	 	by += 20	 	bSize = 40	 	Button GraphWaveDrawButton2,pos={bx,by},size={bSize,17},proc=LS_GraphWaveDrawProc,title="Draw",fSize=10,font="Arial"	 	bx += bSize+bSp	 	Button GraphWaveDoneButton2,pos={bx,by},size={bSize,17},proc=LS_GraphWaveDoneProc,title="Done",fSize=10,font="Arial"	 	bx += bSize+bSp	 	Button GraphWaveEditButton2,pos={bx,by},size={bSize,17},proc=LS_GraphWaveEditProc,title="Edit",fSize=10,font="Arial"	 	bx += bSize+bSp	 	Button ClearGraphWaveButton,pos={bx,by},size={bSize,17},proc=LS_ClearGraphWaveProc,title="Clear",fSize=10,font="Arial"	 	bx += bSize+bSp		LS_doToggleRedAuto(LS_autoRed)		// Create masks		if (Exists("theROI")==0)			Duplicate/O TheImage2,theROI,theBG			Redimension/B/U theROI			Redimension/B/U theBG			theROI = 0			theBG = 0		endif		// ROI		DoWindow /K ImageViewer3		Display /W=(xPos*ScSc+Width*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as "Region of Interest"		DoWindow /C ImageViewer3		AppendImage /T theROI		SetAxis/A/R left		ModifyGraph height={Aspect,AspectRatio}//		ModifyGraph height={Plan,1,left,top}		ModifyGraph mirror=3		ModifyImage theROI ctab= {0,2,Yellow,0}	 	DoUpdate	 	AutoPositionWindow/M=1/R=ImageViewer2 ImageViewer3		// BG		DoWindow /K ImageViewer4		Display /W=(xPos*ScSc+Width*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as "Background"		DoWindow /C ImageViewer4		AppendImage /T theBG		SetAxis/A/R left		ModifyGraph height={Aspect,AspectRatio}//		ModifyGraph height={Plan,1,left,top}		ModifyGraph mirror=3		ModifyImage theBG ctab= {0,1.2,Blue,0}	 	DoUpdate	 	AutoPositionWindow/M=1/R=ImageViewer3 ImageViewer4	 		 	if (ImRegCheckVar)			// Create ImReg mask			if (Exists("ImRegMask")==0)				Duplicate/O TheImage2,ImRegMask//				Redimension/B/U ImRegMask				Redimension/S ImRegMask		// Nasty! This should be single precision float!				ImRegMask = 0			endif			// Image registration mask			DoWindow /K ImageViewer5			Display /W=(xPos*ScSc+Width*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as "Image registration mask"			DoWindow /C ImageViewer5			AppendImage /T ImRegMask			SetAxis/A/R left			ModifyGraph height={Aspect,AspectRatio}			ModifyGraph mirror=3			ModifyImage ImRegMask ctab= {0,1.2,Red,0}		 	DoUpdate		 	AutoPositionWindow/M=1/R=ImageViewer4 ImageViewer5		else			DoWindow /K ImageViewer5	 	endif		DoWindow /F ImageViewer2	else		DoWindow /K ImageViewer		Display /W=(xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc) as ImageFileName		Dowindow /C ImageViewer		AppendImage /T TheImage		SetAxis/A/R left		Cursor/H=1/P/I A CurrentImage 0,0		Cursor/H=1/P/I B CurrentImage ImageWidth,ImageHeight		ModifyGraph width={Aspect,1},height={Aspect,1}		if (BlankCheckVar)			ImageStats /G={0, ImageWidth-1,blankend, ImageHeight-1} CurrentImage			ModifyImage CurrentImage ctab= {V_min,V_max,Rainbow,1}		else			ModifyImage CurrentImage ctab= {*,*,Rainbow,1}		endif		DrawLines2()		ModifyGraph mirror=3		ControlBar 22+20		nButtons = 13		fade = 2		i = 0		gap = 2		if (Width<=200)			gap = 1		endif		size = Floor(Width/nButtons)-gap	 	Button KillItButton, pos={gap+(size+gap)*i,2}, size={size,17},proc=KillItProc, title="X"	 	i += 1		Button LSLLeftButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title="<",fColor=(65535/fade,65535/fade,0),font="Arial",fstyle=1	 	i += 1		Button LSLRightButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title=">",fColor=(65535/fade,65535/fade,0),font="Arial",fstyle=1	 	i += 1		Button LSRLeftButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title="<",fColor=(65535/fade,65535/fade,0),font="Arial",fstyle=1	 	i += 1		Button LSRRightButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title=">",fColor=(65535/fade,65535/fade,0),font="Arial",fstyle=1	 	i += 1		Button BGLLeftButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title="<",fColor=(65535/fade,0,0),font="Arial",fstyle=1	 	i += 1		Button BGLRightButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title=">",fColor=(65535/fade,0,0),font="Arial",fstyle=1	 	i += 1		Button BGRLeftButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title="<",fColor=(65535/fade,0,0),font="Arial",fstyle=1	 	i += 1		Button BGRRightButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title=">",fColor=(65535/fade,0,0),font="Arial",fstyle=1	 	i += 1		Button F0UUpButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title="^",fColor=(0,65535/fade,0),font="Arial",fstyle=1	 	i += 1		Button F0UDownButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title="v",fColor=(0,65535/fade,0),font="Arial",fstyle=1	 	i += 1		Button F0DUpButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title="^",fColor=(0,65535/fade,0),font="Arial",fstyle=1	 	i += 1		Button F0DDownButton, pos={gap+(size+gap)*i,2}, size={size, 17}, proc=AdjustRegionsProc, title="v",fColor=(0,65535/fade,0),font="Arial",fstyle=1	 	i += 1	 	i = 0	 	Button ZoomButton, pos={gap+(size+gap)*i,2+20}, size={size,17},proc=ZoomItProc, title="Z"	// 	i += 1		Button LSGrabButton, pos={gap+(size+gap)*1+(size+gap)*4*i,2+20}, size={size*4+gap*3, 17}, proc=LS_GrabProc, title="Grab LS",fColor=(65535/fade,65535/fade,0)//,font="Arial",fstyle=1	 	i += 1		Button BGGrabButton, pos={gap+(size+gap)*1+(size+gap)*4*i,2+20}, size={size*4+gap*3, 17}, proc=BG_GrabProc, title="Grab BG",fColor=(65535/fade,0,0)//,font="Arial",fstyle=1	 	i += 1		Button F0GrabButton, pos={gap+(size+gap)*1+(size+gap)*4*i,2+20}, size={size*4+gap*3, 17}, proc=F0_GrabProc, title="Grab F0",fColor=(0,65535/fade,0)//,font="Arial",fstyle=1	 	i += 1	 		 	LS_FixFontInPanel()	 		ZoomItProc("")										// Automatically zoom-in	endif	Dowindow /F LineScanAnalysis				End/////////////////////////////////////////////////////////////////////////// Clear Graph Wave DrawFunction LS_ClearGraphWaveProc(ctrlName) : ButtonControl	String ctrlName		WAVE		theROI		theROI = 0		Make/O/N=(0) LS_xDraw,LS_yDraw	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Start Graph Wave DrawFunction LS_GraphWaveDrawProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			GraphWaveDraw/O/L/T LS_yDraw,LS_xDraw			break		case -1: // control being killed			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Done with Graph Wave DrawFunction LS_GraphWaveDoneProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			GraphNormal			break		case -1: // control being killed			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Edit Graph WaveFunction LS_GraphWaveEditProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			WAVE	LS_yDraw			try 				GraphWaveEdit LS_yDraw				AbortOnRTE			catch				Abort "You cannot edit before drawing something!  Draw something first!"			endtry			break		case -1: // control being killed			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Update green LUT manuallyFunction LS_setGreenToManualProc(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva		NVAR		LS_lowGreen	NVAR		LS_highGreen	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update		case 4: // Mouse scroll wheel up		case 5: // Mouse scroll wheel down		case 6: // Value changed by dependency update (this is the actual 'live' update)			Variable dval = sva.dval			String sval = sva.sval						if (LS_lowGreen>LS_highGreen)				variable temp = LS_lowGreen				LS_lowGreen = LS_highGreen				LS_highGreen = temp			endif						ControlInfo/W=ImageViewer AutoLUTCheck			LS_doToggleGreenAuto(V_value)			break		case -1: // control being killed			break	endswitch	return 0End/////////////////////////////////////////////////////////////////////////// Set green manual LUT to auto valuesFunction LS_setGreenToAutoProc(ctrlName) : ButtonControl	String ctrlName		NVAR		LS_lowGreen	NVAR		LS_highGreen		Variable perc = 2			// percentage outlier pixels to ignore in histogram normalization		ImageStats TheImage1	Variable midPoint = (V_min+V_max)/2	LS_lowGreen = Round(midPoint-abs(V_max-V_min)*(100-perc)/100/2)	LS_highGreen = Round(midPoint+abs(V_max-V_min)*(100-perc)/100/2)		ControlInfo/W=ImageViewer AutoLUTCheck	LS_doToggleGreenAuto(V_value)	End/////////////////////////////////////////////////////////////////////////// Toggle green LUT set to auto or notFunction LS_toggleGreenAutoProc(ctrlName,checked) : CheckBoxControl	String		ctrlName	Variable		checked		LS_doToggleGreenAuto(checked)	End	Function LS_doToggleGreenAuto(checked)	Variable	checked	NVAR		LS_lowGreen	NVAR		LS_highGreen	NVAR		LS_autoGreen	LS_autoGreen = checked		if (checked)		ModifyImage/W=ImageViewer TheImage1 ctab= {*,*,Green,0}	else		ModifyImage/W=ImageViewer TheImage1 ctab= {LS_lowGreen,LS_highGreen,Green,0}	endifEnd//////////////// RED BELOW///////////////////////////////////////////////////////////////////////////////////////////////////////////// Update red LUT manuallyFunction LS_setRedToManualProc(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	NVAR		LS_lowRed	NVAR		LS_highRed	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update		case 4: // Mouse scroll wheel up		case 5: // Mouse scroll wheel down		case 6: // Value changed by dependency update (this is the actual 'live' update)			Variable dval = sva.dval			String sval = sva.sval			if (LS_lowRed>LS_highRed)				variable temp = LS_lowRed				LS_lowRed = LS_highRed				LS_highRed = temp			endif			ControlInfo/W=ImageViewer2 AutoLUTRedCheck			LS_doToggleRedAuto(V_value)			break		case -1: // control being killed			break	endswitch	return 0End/////////////////////////////////////////////////////////////////////////// Set manual red LUT to auto valuesFunction LS_setRedToAutoProc(ctrlName) : ButtonControl	String ctrlName		NVAR		LS_lowRed	NVAR		LS_highRed		Variable perc = 2			// percentage outlier pixels to ignore in histogram normalization		ImageStats TheImage2	Variable midPoint = (V_min+V_max)/2	LS_lowRed = Round(midPoint-abs(V_max-V_min)*(100-perc)/100/2)	LS_highRed = Round(midPoint+abs(V_max-V_min)*(100-perc)/100/2)		ControlInfo/W=ImageViewer2 AutoLUTRedCheck	LS_doToggleRedAuto(V_value)	End/////////////////////////////////////////////////////////////////////////// Toggle red LUT set to auto or notFunction LS_toggleRedAutoProc(ctrlName,checked) : CheckBoxControl	String		ctrlName	Variable		checked		LS_doToggleRedAuto(checked)	End	Function LS_doToggleRedAuto(checked)	Variable	checked	NVAR		LS_lowRed	NVAR		LS_highRed	NVAR		LS_autoRed		LS_autoRed = checked		if (checked)		ModifyImage/W=ImageViewer2 TheImage2 ctab= {*,*,Red,0}	else		ModifyImage/W=ImageViewer2 TheImage2 ctab= {LS_lowRed,LS_highRed,Red,0}	endifEnd///////////////////////////////////////////////////////////////////////////////////// Zoom in on the relevant region in the image, starting at F0_upperFunction ZoomItProc(ctrlName) : ButtonControl	String ctrlName		NVAR		F0_Upper = F0_Upper//	NVAR		F0_Lower = F0_Lower	Variable	Range	Variable	upper,lower	Variable	expand = 5							// in percent	Variable 	Keys = GetKeyState(0)	Variable	Shift = 0	if (Keys & 2^2)		Shift = 1	endif	Dowindow/F ImageViewer	if (V_flag==1)		DoUpdate		if (Shift)			GetAxis/Q left			lower = V_min			range = F0_Upper-lower			upper = lower+range*(1+expand/100)			SetAxis left,lower,upper		else			SetAxis/A/R left		endif	endif	End	///////////////////////////////////////////////////////////////////////////////////// Adjust the regions in the line scan imageFunction AdjustRegionsProc(ctrlName) : ButtonControl	String ctrlName		NVAR	LS_Left = LS_Left	NVAR	LS_Right = LS_Right	NVAR	BG_Left = BG_Left	NVAR	BG_Right = BG_Right	NVAR	F0_Upper = F0_Upper	NVAR	F0_Lower = F0_Lower	strswitch(ctrlName[0,3])			case "LSLL":			LS_Left -= 1			break		case "LSLR":			LS_Left += 1			break		case "LSRL":			LS_Right -= 1			break		case "LSRR":			LS_Right += 1			break		case "BGLL":			BG_Left -= 1			break		case "BGLR":			BG_Left += 1			break		case "BGRL":			BG_Right -= 1			break		case "BGRR":			BG_Right += 1			break		case "F0UU":			F0_Upper -= 1			break		case "F0UD":			F0_Upper += 1			break		case "F0DU":			F0_Lower -= 1			break		case "F0DD":			F0_Lower += 1			break		default:			Print "Strange error in {AdjustRegionsProc}"	endswitch		DrawLines2()	End	///////////////////////////////////////////////////////////////////////////////////// Load the MultiPatch ParameterLog text fileFunction ShowMPNotesProc(ctrlName) : ButtonControl	String ctrlName		SVAR	ePhysPathName = ePhysPathName	NewPath/O/Q TargetFolder,ePhysPathName//	Open /R/Z/P=$PathName dumvar as ImageFileName//	NewPath/O/Q TargetFolder, PathName	OpenNotebook/N=Parameter_Log/P=TargetFolder/R "Parameter_Log"End	///////////////////////////////////////////////////////////////////////////////////// Dump the ScanImage comments in a notebook windowFunction ShowCommentsProc(ctrlName) : ButtonControl	String ctrlName		if (!(Str2Num(StringByKey("IGORVERS",IgorInfo(0))) > 5.02))		Abort("Only works with Igor PRO versions 5.03 and higher.")	endif	SVAR		RAT_Str = RAT_Str	SVAR		ImageFileName = ImageFileName	string		Old_RAT_Str = RAT_Str	Variable	Fix_RAT_Str = 0		String		HeaderLine = ""	Variable Keys = GetKeyState(0)	if (Keys & 4)		Print "Holding shift key --> Load new image header"		HeaderLine = LoadImageHeaderOnly()		if (StringMatch(HeaderLine,""))			Abort "No file was loaded."		else			HeaderLine = " for "+HeaderLine		endif		Fix_RAT_Str = 1	else		HeaderLine = " for "+ImageFileName	endif	DoWindow/K ScanImageComments	NewNotebook/N=ScanImageComments/F=1/V=1/W=(500,50,1022,512) as "ScanImage Comments"//+HeaderLine	Notebook ScanImageComments defaultTab=36, statusWidth=238, pageMargins={72,72,72,72}	Notebook ScanImageComments showRuler=0, rulerUnits=1, updating={1, 216000}	Notebook ScanImageComments newRuler=Title, justification=0, margins={0,0,538}, spacing={0,0,0}, tabs={}, rulerDefaults={"Arial",18,0,(0,0,0)}	Notebook ScanImageComments newRuler=Normal, justification=0, margins={0,0,468}, spacing={0,0,0}, tabs={16,32,400+3*8192,450+8192*2}, rulerDefaults={"Arial",12,0,(0,0,0)}	Notebook ScanImageComments ruler=Normal,text=(RAT_Str+"\r")	Notebook ScanImageComments selection={startOfFile, startOfFile}	// Show start of notebook	Notebook ScanImageComments ruler=Title,textRGB=(0,0,65535), text="\rScanImage Comments"+HeaderLine+"\r",textRGB=(0,0,0)	Notebook ScanImageComments ruler=Normal,text=("\r")		if (Fix_RAT_Str)		Old_RAT_Str = RAT_Str	EndifEnd/////////////////////////////////////////////////////////////////// Load image TIFF header onlyFunction/S LoadImageHeaderOnly()	SVAR	PathName	SVAR	RAT_Str = RAT_Str	SVAR	ImageFileName = ImageFileName	String	ImageFile	String	FileNameOnly		NVAR	LS_ModernLoadMode	Variable dumvar		Open/D/R/T=".tif"/M="Select TIFF file whose header you wish to load." dumvar	ImageFile = S_fileName	if (StringMatch(ImageFile,""))		Return ImageFile	endif	FileNameOnly = StringFromList(ItemsInList(ImageFile,":")-1,ImageFile,":")	if (Str2Num(StringByKey("IGORVERS",IgorInfo(0))) > 5.02)		// Only Igor 5.03 and above can use the /rat flag (Read All Tags)		// ScanImage uses the TIFF comments field to store its data field		Execute "ImageLoad/Q/Z/BIGT=1/LTMD/T=tiff/C=-1 /O/N='AllImageRAW' \""+ImageFile+"\""			// Must do Execute to allow this proc to run on Igor v5.02 and lower, or else /RAT flag won't permit compilation		WAVE/T	T_Tags = root:Tag0:T_Tags		if (LS_ModernLoadMode)												// Old TIFF header style pertains to ScIm v3.7 and lower; Modern is ScIm 2015 and up (I think!)			RAT_Str = T_Tags[12]		else			RAT_Str = T_Tags[FindIMAGEDESCRIPTION(T_Tags)][4]		endif		KillDataFolder/Z root:Tag0											// Avoid having these data folders build up as more images are loaded		KillDataFolder/Z root:Tag1	else		Abort "You need to upgrade to Igor v5.03 or higher."	endif		Return FileNameOnlyEnd///////////////////////////////////////////////////////////////////////////////////// This function takes the ScanImage TIFF header of the most recently loaded image file and//// extracts the file creation date, then converts it to Igor-style secs and returns this number.Function GetDateTimeFromRATStr()	Variable	ImageDateTime = 0		String		ScanImageDateTimeStr = ""		Variable	dumpDebugText = 0		if (Exists("RAT_Str"))		SVAR RAT_Str		ScanImageDateTimeStr = StringByKey("state.internal.triggerTimeString",RAT_Str,"=","\r")		Print "\tFound the file creation date in the ScanImage TIFF header:",ScanImageDateTimeStr	else		Print "\tThe ScanImage TIFF header does not seem to exist. Try reloading image?"		Abort "The ScanImage TIFF header does not seem to exist. Try reloading image?"	endif	ScanImageDateTimeStr = ScanImageDateTimeStr[1,strLen(ScanImageDateTimeStr)-2]	String	DateStr = StringFromList(0,ScanImageDateTimeStr," ")	String	TimeStr = StringFromList(1,ScanImageDateTimeStr," ")	if (dumpDebugText)		print "*"+DateStr+"*","*"+TimeStr+"*"	endif	// We assume that the ScanImage TIFF header always operates in MM/DD/YYYY format	Variable	theMonth = str2num(StringFromList(0,DateStr,"/"))	Variable	theDay = str2num(StringFromList(1,DateStr,"/"))	Variable	theYear = str2num(StringFromList(2,DateStr,"/"))	Variable	theHour = str2num(StringFromList(0,TimeStr,":"))	Variable	theMinute = str2num(StringFromList(1,TimeStr,":"))	Variable	theSecond = str2num(StringFromList(2,TimeStr,":"))	ImageDateTime = date2secs(theYear,theMonth,theDay)+theHour*60*60+theMinute*60+theSecond	if (dumpDebugText)		print theDay,theMonth,theYear		print theHour,theMinute,theSecond		print ImageDateTime,"=",secs2date(ImageDateTime,2),secs2time(ImageDateTime,1)	endif		Return		ImageDateTimeEnd///////////////////////////////////////////////////////////////////////////////////// This function extracts the 'secs' date & time info from the MultiPatch electrophysiology//// data note info.Function GetDateTimeFromMultiPatch(CurrentFileStr)	String	CurrentFileStr		String	currWave = CurrentFileStr[0,strLen(CurrentFileStr)-5]	String	currNote = note($currWave)	Variable	theSecs = str2num(StringFromList(2,currNote))	Return	theSecs	End///////////////////////////////////////////////////////////////////////////////////// When file creation date was destroyed by ZIP-ing, rely on MultiPatch's internal date stamp,//// so only keep those files that have this date stampFunction/S OnlyKeepPermittedFiles(ListOfFiles)	String	ListOfFiles		String	NewListOfFiles = ""	String	currFile	String	criterionStr = "Cell_"		// Filename has to start with this...		Variable	n = ItemsInList(ListOfFiles)	Variable	i	i = 0	do		currFile = StringFromList(i,ListOfFiles)		if (strsearch(currFile,criterionStr,0)==0)			NewListOfFiles += currFile+";"		endif		i += 1	while(i<n)	Return	NewListOfFilesEnd///////////////////////////////////////////////////////////////////////////////////// This function searches the current directory for Igor binary waves that were acquired at the//// same time as the current .tif file.Function FindWavesMatchingInTime(ctrlName) : ButtonControl	String ctrlName	SVAR	ePhysPathName = ePhysPathName	SVAR	PathName = PathName	SVAR		ImageFileName = ImageFileName		NVAR		TimeIsOffBy = TimeIsOffBy			// When matching electrophys to imaging, the computer clocks were off by this many seconds													// A negative number means electrophys waves were time stamped with an earlier time than the imaging daata		NVAR		TimeSlop	Variable	slop = TimeSlop						// Allowing for this much slop in the data acquisition time stamping [s] -- used to be hard-wired, but transfer from panel now...	Variable	maxFiles = 6						// Maximum number of ePhys files allowed		// Variables for the progress bar	NVAR		Progress_Val = Progress_Val	NVAR		Progress_Counter = Progress_Counter	NVAR		Progress_Max = Progress_Max	SVAR		Progress_MessageStr = Progress_MessageStr	LS_MakeProgressBar()	LS_UpdateProgressBar(0,"Starting search...")//	UpdateProgressBar(Progress_Counter/Progress_Max,"Setting up basic variables...")//	Progress_Counter += 1	Print "--- Searching for Igor binary waves that match the modification time & date of the current image file ---"	print "\tChecking the Creation Date & Time of the TIF file."	GetFileFolderInfo/Q/Z PathName+ImageFileName	if (V_flag)		Abort "Strange error! TIFF file could not be found."	endif	Variable	ImageDateTime = V_creationDate	Variable	UsingZippedData = 0	Print "\tAccording to file on HD, the current image file was created at "+secs2time(ImageDateTime,3)+" on "+secs2date(ImageDateTime,1)+"."	ControlInfo/W=LineScanAnalysis ZIPedDataCheck	UsingZippedData = V_Value	if (UsingZippedData)		Print "\tBut we are working with ZIP-ed data, so date & time of file creation was destroyed. We use the ScanImage TIFF header instead."		ImageDateTime = GetDateTimeFromRATStr()	endif	Print "\tCorrecting this by ",TimeIsOffBy," seconds."	Print "\tAllowing for a slop of ",slop," seconds."		ControlInfo/W=LineScanAnalysis UseCacheCheck	Variable	UseCache = V_Value	Variable	CacheIsGood = 0	Print "\tSearching in folder \""+ePhysPathName+"\""	NewPath/O/Q CurrentPath,ePhysPathName	String		ListOfFiles 	ListOfFiles = IndexedFile(CurrentPath,-1, ".ibw")			// NB! Only looking for .ibw files!!!	if (UsingZippedData)		ListOfFiles = OnlyKeepPermittedFiles(ListOfFiles)		// When file creation date was destroyed by ZIP-ing, rely on MultiPatch's internal date stamp, so only keep those files that have this date stamp	endif	Variable	nFiles = ItemsInList(ListOfFiles)	print "\tFound "+num2str(nFiles)+" files in this folder."	if ((UseCache) %& (exists("DateTimeCacheWave")==1) )		WAVE/D	DateTimeCacheWave = DateTimeCacheWave		if (numpnts(DateTimeCacheWave)==nFiles)			Print "\t\tFound a valid cache. Using this cache."			CacheIsGood = 1		endif	endif	Progress_Max = nFiles	if (!(CacheIsGood))		Make/D/O/N=(nFiles) DateTimeCacheWave		Make/T/O/N=(nFiles) TimeStrCacheWave		Make/T/O/N=(nFiles) FileNameStrCacheWave	endif	Variable	i,k	Variable	updateEvery = floor(nFiles/10)			// Update progress bar only this many times, as it takes time to update it!	Variable	WaveDateTime	Variable	FoundWave = 0	String		currentFileStr	String		ListOfFoundWaves = ""	Print "\tNow checking individual waves."	if (CacheIsGood)			//// USING THE CACHE		FoundWave = 0		FindLevel/Q/P DateTimeCacheWave,(ImageDateTime+TimeIsOffBy-slop)		if (V_flag==1)			Print "\t\tCould not find corresponding waves in the cache. Time is outside range found in cache. (This is a strange result.)"		else			Variable SearchStart = floor(V_LevelX)			i = SearchStart			do				Progress_Counter = i				LS_UpdateProgressBar(Progress_Counter/Progress_Max,"Searching...")				currentFileStr = FileNameStrCacheWave[i]				WaveDateTime = DateTimeCacheWave[i]				if (abs(WaveDateTime-(ImageDateTime+TimeIsOffBy))<=slop)					Print "\t\t*** Found wave at "+secs2time(WaveDateTime,3)+" -- this wave is: \""+currentFileStr+"\" ***"					ListOfFoundWaves += currentFileStr[0,StrLen(CurrentFileStr)-5]+";"					FoundWave = 1				endif				i += 1			while(i<SearchStart+maxFiles)		endif	else							//// NOT USING THE CACHE		i = 0		k = 0		do			currentFileStr = StringFromList(i,ListOfFiles)			if (UsingZippedData)				LoadWave/Q/O/H/P=CurrentPath CurrentFileStr				WaveDateTime = GetDateTimeFromMultiPatch(CurrentFileStr)			else				GetFileFolderInfo/Q/P=CurrentPath/Z currentFileStr				WaveDateTime = V_creationDate			endif			DateTimeCacheWave[i] = WaveDateTime			TimeStrCacheWave[i] = secs2time(WaveDateTime,3)			FileNameStrCacheWave[i] = currentFileStr			Progress_Counter = i			if (mod(k,updateEvery)==0)				LS_UpdateProgressBar(Progress_Counter/Progress_Max,"Searching...")			endif			k += 1			if (abs(WaveDateTime-(ImageDateTime+TimeIsOffBy))<=slop)				Print "\t\t*** Found wave at "+secs2time(WaveDateTime,3)+" -- this wave is: \""+currentFileStr+"\" ***"				ListOfFoundWaves += currentFileStr[0,StrLen(CurrentFileStr)-5]+";"				FoundWave = 1			endif			i += 1		while (i<nFiles)		Sort DateTimeCacheWave,DateTimeCacheWave,TimeStrCacheWave,FileNameStrCacheWave		// Sort the cache according to time to enable quick search next time around	endif	if (FoundWave)		LS_UpdateProgressBar(1,"Loading files...")		print "\tFound "+num2str(ItemsInList(ListOfFoundWaves))+" files."		i = 0		do			currentFileStr = StringFromList(i,ListOfFoundWaves)			Print "\tLoading \""+currentFileStr+"\""			LoadWave/Q/O/H/P=CurrentPath CurrentFileStr			if (V_flag==0)				Abort "Error loading the wave \""+currentFileStr+"\""			endif			i += 1		while (i<ItemsInList(ListOfFoundWaves))		DoWindow/K ElectrophysWaveGraph		Display/W=(274,364,759,623) as currentFileStr		DoWindow/C ElectrophysWaveGraph		i = 0		do			currentFileStr = StringFromList(i,ListOfFoundWaves)			Print "\tDisplaying \""+currentFileStr+"\""			AppendToGraph $(currentFileStr)			ModifyGraph rgb($(currentFileStr))=(65535*i/(ItemsInList(ListOfFoundWaves)-1),0,65535*(ItemsInList(ListOfFoundWaves)-1-i)/(ItemsInList(ListOfFoundWaves)-1))			print "\tUse\r\t\tAppend/R "+currentFileStr+";ModifyGraph RGB("+currentFileStr+")=(0,0,0)\r\tto append file to imaging analysis graph of choice"			i += 1		while (i<ItemsInList(ListOfFoundWaves))		ModifyGraph fSize=18		if (ItemsInList(ListOfFoundWaves)>1)			Legend		endif	 	Button KillItButton, pos={0,0}, size={20,17},proc=KillItProc, title="X",fSize=10,font="Arial"	else		Print "\tSorry! Found no matching wave!"	endif		LS_KillProgressBar()	Print "--- Done searching ---"	End/////////////////////////////////////////////////////////////////////////// Set x-axis range to nice valuesFunction Nice_xAxisRange()	NVAR		CompileGraphSmooth = CompileGraphSmooth	NVAR		CompileGraphSmVal = CompileGraphSmVal	Variable	tCorrection = 0.996759				// Small correction for apparently erroneous linescanrate in ScanImage	NVAR		F0_Upper = F0_Upper	NVAR		dt = dt	Variable	xStart = F0_Upper*dt*1e-3*tCorrection	if (CompileGraphSmooth)		xStart += CompileGraphSmVal/2*dt*1e-3*tCorrection	endif	Variable	xEnd = xStart+0.5		String		wList = TraceNameList("",";",1)	String		firstWaveName = StringFromList(0,wList)	WAVE		w = $firstWaveName	if (xEnd>pnt2x(w,numpnts(w)-1))		xEnd = pnt2x(w,numpnts(w)-1)	endif	SetAxis bottom,xStart,xEndEnd/////////////////////////////////////////////////////////////////////////// Analyze baseline calcium levels for the different conditions over timeFunction LS_BaseCaVsTime()	NVAR		nCategories	WAVE/T	RecallWaveListWave	WAVE/T	SuffixWave	WAVE/T	LegendWave	String		currStr	NVAR		LS_RunningScanArea	if (LS_RunningScanArea==0)		DoWindow/K	BaseCaOverTime		Display as "Basal Ca over time"		DoWindow/C	BaseCaOverTime	endif	Variable	pp,bLineSD,bLine,PearsonR	String/G	baseLineQualityStr = ""	Variable	i,j,n	String		LegStr = "\\Z12"	Make/O/N=(nCategories) basalCa_SEM,basalCa_mean	Make/O/T/N=(nCategories) basalCa_xLabel	i = 0	do		Make/O/N=(0) WorkWave,WorkWave2		n = ItemsInList(RecallWaveListWave[i],",")		j = 0		do			WAVE	w = $(StringFromList(j,RecallWaveListWave[i],","))			currStr = Note(w)			WorkWave[numpnts(WorkWave)] = {Str2Num(StringByKey("Rest",currStr))}			WorkWave2[numpnts(WorkWave)] = {Str2Num(StringByKey("bLineSD",currStr))}			j += 1		while(j<n)		Duplicate/O WorkWave,$("bCa"+SuffixWave[i]),xAxisTemp		xAxisTemp = p		if (LS_RunningScanArea==0)			AppendToGraph/W=BaseCaOverTime $("bCa"+SuffixWave[i])		endif		pp= JT_DoPearsons("bCa"+SuffixWave[i],"xAxisTemp")		WAVE		W_StatsLinearCorrelationTest		PearsonR = W_StatsLinearCorrelationTest[1]		WaveStats/Q $("bCa"+SuffixWave[i])		bLine = V_avg		WaveStats/Q WorkWave2		bLineSD = V_rms*sqrt(V_npnts)		baseLineQualityStr += SuffixWave[i]+"\r"		baseLineQualityStr += "\tPearson R:    "+num2str(PearsonR)+"\r"		baseLineQualityStr += "\tp trend:    "+num2str(pp)+"\r"		baseLineQualityStr += "\tBaseline val:    "+num2str(bLine)+"\r"		baseLineQualityStr += "\tBaseline SD:    "+num2str(bLineSD)+"\r"		baseLineQualityStr += "\tBaseline CV:    "+num2str(bLine/bLineSD)+"\r"		LegStr += "\\s("+"bCa"+SuffixWave[i]+") "+LegendWave[i]+", p="+num2str(Round(pp*1e3)/1e3)//+", CV="+num2str(bLine/bLineSD)+", SD="+num2str(bLineSD)		if (i<nCategories)			LegStr += "\r"		endif		WaveStats/Q $("bCa"+SuffixWave[i])		basalCa_SEM[i] = V_sdev/sqrt(V_npnts)		basalCa_mean[i] = V_avg		basalCa_xLabel[i] = LegendWave[i]		i += 1	while(i<nCategories)	Variable bx = 2	if (LS_RunningScanArea==0)		ModifyGraph fSize=12		ModifyGraph manTick(bottom)={0,1,0,0},manMinor(bottom)={0,0}		DoUpdate		ModifyGraph mode=4,marker=8,opaque=1		Legend/F=0/B=1 LegStr		CallColorizeTraces2()		Label left,"baseline signal"		Label bottom,"Iteration #"		ControlBar 22		bx = 2	 	Button KillItButton, pos={bx,2}, size={20,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	bx += 22	 	Button ShuffleButton, pos={bx,2}, size={60,17},proc=LS_ShuffleProc, title="Shuffle",fSize=10,font="Arial"	 	bx += 62	 	Button EditButton, pos={bx,2}, size={32,17},proc=LS_EditProc, title="Edit",fSize=10,font="Arial"	 	bx += 32 	endif		DoWindow/K basalCa_graph	JT_BarGraph("basalCa_mean","basalCa_xLabel","baseline signal","basalCa_SEM","basalCa_graph")	String		sigStr = ""	ControlBar 22	bx = 2 	Button KillItButton, pos={bx,2}, size={20,17},proc=KillItProc, title="X",fSize=10,font="Arial" 	bx += 22 	Button EditButton, pos={bx,2}, size={32,17},proc=LS_EditProc, title="Edit",fSize=10,font="Arial" 	bx += 34 	SetAxis/A/N=2 left	Variable	countStars = 0	Variable	ySp = 0.06	String		starStr	if (nCategories>1)		i = 0		do			j = i+1			do				starStr = JT_p2sigStr(DoTTest($("bCa"+SuffixWave[i]),$("bCa"+SuffixWave[j])))				JT_AddSigLines(0.5+i,(0.5+i+0.5+j)/2,0.5+j,countStars*ySp,starStr,"basalCa_graph")				countStars += StrLen(starStr)>0				j += 1			while(j<nCategories)			i += 1		while(i<nCategories-1)	endif	End	/////////////////////////////////////////////////////////////////////////// Make a nice graph for the different conditionsFunction MakeCompiledGraphProc(ctrlName) : ButtonControl	String ctrlName		NVAR	nCat = nCategories		NVAR	baseStart = baseStart	NVAR	baseWin = baseWin	WAVE/T Categories = SuffixWave				// "Transplant" the panel data into this procedure (which was stolen from other procedure window)	WAVE/T LegStrWave = LegendWave		Variable	theFontSize=12	String LegStr = "\\Z"+num2str(theFontSize)		Variable	xPos = 400	Variable	yPos = 400	Variable	Width = 400	Variable	Height = 220		NVAR		CompileGraphShowSEM = CompileGraphShowSEM	NVAR		CompileGraphSmooth = CompileGraphSmooth	NVAR		CompileGraphSmVal = CompileGraphSmVal		NVAR		ReviewSlotNumber = ReviewSlotNumber		NVAR		Calc_mode		String		lName = ""	String		uName = ""	String		mName = ""		String		lName_source = ""	String		uName_source = ""	String		mName_source = ""		Variable	offsVal	NVAR	LS_RunningScanArea	if (LS_RunningScanArea==0)		Variable	ReAlign = 0		ControlInfo/W=LineScanAnalysis RealignBaselineCheck		if (V_flag==2)			ReAlign = V_value		else			Print "{RealignBaselineCheck} does not exist Ñ restart LineScanAnalysis panel"			Abort "{RealignBaselineCheck} does not exist Ñ restart LineScanAnalysis panel"		endif				DoWindow/K AllTracesGr		Display /W=(xPos,yPos,xPos+Width,yPos+Height)  as "All traces"		DoWindow/C AllTracesGr		ControlBar 22			endif	Variable	MaxVal = -Inf		NVAR		CompileGrSmBlock	NVAR		CompileGrSmMedian	Variable	blockSmooth = CompileGrSmBlock	Variable	useMedian = CompileGrSmMedian	NVAR		BlankInAverage	NVAR		BlankStart	NVAR		BlankEnd		NVAR		ImageHeight	NVAR		FrameFlag		NVAR		dt	Variable	i,j,k	if (LS_RunningScanArea==0)		i = 0		do			if (CompileGraphSmooth)				lName_source = "SEMWaveL"+Categories[i]				uName_source = "SEMWaveU"+Categories[i]				mName_source = "meanWave"+Categories[i]				lName = "SEMWaveL"+Categories[i]+"_Sm"				uName = "SEMWaveU"+Categories[i]+"_Sm"				mName = "meanWave"+Categories[i]+"_Sm"				if (blockSmooth)					Make/O/N=(0) $(lName),$(uName),$(mName)					WAVE	sourceW = $(mName_source)					WAVE	destW = $(mName)					WAVE	destW_u = $(uName)					WAVE	destW_l = $(lName)					Make/O/N=(CompileGraphSmVal) workWave					k = 0					j = 0					do						workWave[k] = sourceW[j]						k += 1						if (k>=CompileGraphSmVal)							if (useMedian)								Sort workWave,workWave								destW[numpnts(destW)] = {workWave[Floor(k/2)]}							else								WaveStats/Q workWave								destW[numpnts(destW)] = {V_avg} // -Round(k/2)							endif							WaveStats/Q workWave							destW_u[numpnts(destW_u)] = {destW[numpnts(destW)-1]+V_sdev/sqrt(V_npnts)}							destW_l[numpnts(destW_l)] =  {destW[numpnts(destW)-1]-V_sdev/sqrt(V_npnts)}							k = 0						endif						j += 1					while (j<numpnts(sourceW))					if (FrameFlag)						SetScale/P x,dt*CompileGraphSmVal*1e-3*ImageHeight,dt*CompileGraphSmVal*1e-3*ImageHeight, destW,destW_u,destW_l					else						SetScale/P x,dt*CompileGraphSmVal/2*1e-3,dt*CompileGraphSmVal*1e-3, destW,destW_u,destW_l					endif//					SetScale/P x,0,dt*CompileGraphSmVal*1e-3, destW,destW_u,destW_l				else					Duplicate/O $(lName_source),$(lName)					Duplicate/O $(uName_source),$(uName)					Duplicate/O $(mName_source),$(mName)					Smooth/B CompileGraphSmVal,$(lName),$(uName),$(mName)				endif				if (BlankInAverage)					DoRemoveStimArtifact(BlankStart/1e3,(BlankEnd-BlankStart),mName,1)					DoRemoveStimArtifact(BlankStart/1e3,(BlankEnd-BlankStart),uName,1)					DoRemoveStimArtifact(BlankStart/1e3,(BlankEnd-BlankStart),lName,1)				endif			else				lName = "SEMWaveL"+Categories[i]				uName = "SEMWaveU"+Categories[i]				mName = "meanWave"+Categories[i]			endif			if (ReAlign)				WaveStats/Q/R=(baseStart/1e3,(baseStart+baseWin)/1e3) $(mName)				offsVal = 0-V_avg	//			offsVal = 0-Mean($(mName),baseStart/1e3,(baseStart+baseWin)/1e3)			else				offsVal = 0			endif			if (CompileGraphShowSEM)				AppendToGraph $(lName)				AppendToGraph $(uName)				ModifyGraph offset($(lName))={0,offsVal}				ModifyGraph offset($(uName))={0,offsVal}//				WAVE wl = $(lName)//				WAVE wu = $(uName)//				wl += offsVal//				wu += offsVal				ModifyGraph rgb($(lName))=(65535*i/(nCat-1),0,65535*(nCat-1-i)/(nCat-1))				ModifyGraph rgb($(uName))=(65535*i/(nCat-1),0,65535*(nCat-1-i)/(nCat-1))				ModifyGraph lstyle($(lName))=1				ModifyGraph lstyle($(uName))=1			endif			AppendToGraph $(mName)			WaveStats/Q $(mName)			if (V_max>MaxVal)				MaxVal = V_max			endif			ModifyGraph offset($(mName))={0,offsVal}//			WAVE wm = $(mName)//			wm += offsVal			ModifyGraph lSize($(mName))=3			ModifyGraph rgb($(mName))=(65535*i/(nCat-1),0,65535*(nCat-1-i)/(nCat-1))			LegStr += "\\s("+mName+") "+LegStrWave[i]			if (i!=nCat-1)				LegStr += "\r"			endif			ModifyGraph gaps=1			// Create individual measurements too			ReviewSlotNumber = i			ReviewLineScansProc("")			doUpdate			ReviewLSMeasureProc("quiet")			DoWindow/K ReviewLSGr			i += 1		while (i<nCat)				if ((CompileGraphSmooth) %& (nCat==3))			Duplicate/O $("meanWave"+Categories[0]+"_Sm"),arithmeticSumWave			WAVE	theOne = $("meanWave"+Categories[1]+"_Sm")			WAVE	theOther = $("meanWave"+Categories[2]+"_Sm")			arithmeticSumWave = theOne+theOther			AppendToGraph/W=AllTracesGr arithmeticSumWave			ModifyGraph lstyle(arithmeticSumWave)=11,rgb(arithmeticSumWave)=(0,0,0)			LegStr += "\r\\s(arithmeticSumWave) sum"		endif			ModifyGraph fSize=(theFontSize)		ModifyGraph zero(left)=2		//Nice_xAxisRange()		DoUpdate		ModifyGraph prescaleExp(left)=2		if (Calc_mode == 1)			if (MaxVal<0.25)				if (MaxVal>0.06)					ModifyGraph manTick(left)={0,5,0,0},manMinor(left)={4,0}				else					ModifyGraph manTick(left)={0,1,0,0},manMinor(left)={1,0}				endif			endif		endif		if (Calc_mode == 0)			Label left "dG/G (%)"		endif		if (Calc_mode == 1)			Label left "dG/R (%)"		endif		Label bottom "time (s)"		SetAxis/A/E=1 bottom		Legend/N=text0/J/X=0.00/Y=0.00/F=0/B=1 LegStr		Variable bWid = 20		Variable bPos = 2	 	Button KillItButton, pos={bPos,2}, size={bWid,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	bPos += bWid+4	 	bWid = 40	 	Button ZoomInButton, pos={bPos,2}, size={bWid,17},proc=ZoomInProc, title="Zm",fSize=10,font="Arial"	 	bPos += bWid+4	 	Button PickPosButton, pos={bPos,2}, size={bWid,17},proc=PickPosProc, title="Pnts",fSize=10,font="Arial"	 	bPos += bWid+4	 	Button PickBaselineButton, pos={bPos,2}, size={bWid,17},proc=PickBaselineProc, title="Bsl",fSize=10,font="Arial"	 	bPos += bWid+4		Button PickIntegralButton, pos={bPos,2}, size={bWid,17},proc=PickIntegralProc, title="Int",fSize=10,font="Arial"	 	bPos += bWid+4		Button PickBlankButton, pos={bPos,2}, size={bWid,17},proc=PickBlankProc, title="Blnk",fSize=10,font="Arial"	 	bPos += bWid+4		Button AutoYRangeButton, pos={bPos,2}, size={bWid,17},proc=AutoYRangeProc, title="Auto",fSize=10,font="Arial"	 	bPos += bWid+4	 	Button EditButton, pos={bPos,2}, size={bWid,17},proc=LS_EditProc, title="Edit",fSize=10,font="Arial"	 	bPos += bWid+4				LS_SmartYAxisRange()			else	//LS_RunningScanArea == 1			i = 0		do			// Create individual measurements too			ReviewSlotNumber = i			ReviewLineScansProc("")			doUpdate			ReviewLSMeasureProc("quiet")			DoWindow/K ReviewLSGr			i += 1		while (i<nCat)			endif		LS_BaseCaVsTime()		LS_CaSigVsTime()		if (LS_RunningScanArea==0)		JT_ArrangeGraphs2(";;;;AllTracesGr;basalCa_graph;BaseCaOverTime;;CaSigOverTime;PeakSignalBars;",4,4)	endif	End/////////////////////////////////////////////////////////////////////////// Analyze calcium signal levels for the different conditions over timeFunction LS_CaSigVsTime()	NVAR		nCategories	WAVE/T	RecallWaveListWave	WAVE/T	SuffixWave	WAVE/T	LegendWave	String		currStr	NVAR		LS_RunningScanArea	if (LS_RunningScanArea==0)		DoWindow/K	CaSigOverTime		Display as "Ca signal over time"		DoWindow/C	CaSigOverTime	endif	Variable	pp,theSD,theAve,PearsonR	String/G	QualityStr = ""	Variable	i,j,n	String		LegStr = "\\Z12"	String		currWave	i = 0	do		currWave = "IntegralVal_rev_"+LegendWave[i]		Duplicate/O $(currWave),xAxisTemp		xAxisTemp = p		if (LS_RunningScanArea==0)			AppendToGraph/W=CaSigOverTime $(currWave)		endif		pp= JT_DoPearsons(currWave,"xAxisTemp")		WAVE		W_StatsLinearCorrelationTest		PearsonR = W_StatsLinearCorrelationTest[1]		WaveStats/Q $(currWave)		theAve = V_avg		WaveStats/Q WorkWave2		theSD = V_rms*sqrt(V_npnts)		QualityStr += SuffixWave[i]+"\r"		QualityStr += "\tPearson R:    "+num2str(PearsonR)+"\r"		QualityStr += "\tp trend:    "+num2str(pp)+"\r"		QualityStr += "\tBaseline val:    "+num2str(theAve)+"\r"		QualityStr += "\tBaseline SD:    "+num2str(theSD)+"\r"		QualityStr += "\tBaseline CV:    "+num2str(theAve/theSD)+"\r"//		LegStr += "\\s("+currWave+") "+currWave+", p="+num2str(Round(pp*1e3)/1e3)		LegStr += "\\s("+currWave+") "+LegendWave[i]+", p="+num2str(Round(pp*1e3)/1e3)		if (i<nCategories-1)			LegStr += "\r"		endif		i += 1	while(i<nCategories)		if (LS_RunningScanArea==0)		ModifyGraph fSize=12		ModifyGraph manTick(bottom)={0,1,0,0},manMinor(bottom)={0,0}		DoUpdate		ModifyGraph mode=4,marker=8,opaque=1		Legend/F=0/B=1/A=RC/X=0.00/Y=0.00 LegStr		CallColorizeTraces2()		Label left,"signal integral"		Label bottom,"Iteration #"		ControlBar 22		Variable bx = 2	 	Button KillItButton, pos={bx,2}, size={20,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	bx += 22	 	Button ShuffleButton, pos={bx,2}, size={60,17},proc=LS_ShuffleProc, title="Shuffle",fSize=10,font="Arial"	 	bx += 62	 	Button EditButton, pos={bx,2}, size={32,17},proc=LS_EditProc, title="Edit",fSize=10,font="Arial"	 	bx += 32	 	Button ThirdWaveTestButton, pos={bx,2}, size={48,17},proc=LS_3rdVsZeroProc, title="3rd vs 0",fSize=10,font="Arial"	 	bx += 48	 endif		if (nCategories==3)		SetAxis/W=CaSigOverTime/A/E=1 left		currWave = "IntegralVal_rev_"+LegendWave[0]		Duplicate/O $(currWave),supraLinWave,xAxisTemp		WAVE wBoth = $("IntegralVal_rev_"+LegendWave[0])		WAVE wLight = $("IntegralVal_rev_"+LegendWave[1])		WAVE wAPs = $("IntegralVal_rev_"+LegendWave[2])		if ((numpnts(wBoth)==numpnts(wLight)) %& (numpnts(wAPS)==numpnts(wLight)))			supraLinWave = wBoth/(wLight+wAPs)*100-100			AppendToGraph/R/W=CaSigOverTime supraLinWave			ModifyGraph rgb(supraLinWave)=(30583,30583,30583)			ModifyGraph mode(supraLinWave)=4,marker(supraLinWave)=8,opaque(supraLinWave)=1			label right,"supralinearity (%)"			SetAxis/W=CaSigOverTime/A/E=0 right			pp= JT_DoPearsons("supraLinWave","xAxisTemp")			LegStr += "\r\\s(supraLinWave) supra, p="+num2str(Round(pp*1e3)/1e3)			if (LS_RunningScanArea==0)				Legend/K/N=text0				Legend/F=0/B=1/A=RC/X=0.00/Y=0.00 LegStr			endif		endif	endif	Variable	pAPCa = LS_3rdVsZeroProc("")	if (pAPCa!=-1)		LegStr += "\rp (Ca vs 0) = "+num2str(round(pAPCa*1e3)/1e3)		if (LS_RunningScanArea==0)			Legend/K/N=text0			Legend/F=0/B=1/A=RC/X=0.00/Y=0.00 LegStr		endif	endif	// Stats	String		sigStr = ""	Variable/G	LS_integralSupralin = 0	Variable/G	LS_pDiff = 1	if (nCategories>=3)		WAVE	w1 = $("IntegralVal_rev_"+LegendWave[0])		WAVE	w2 = $("IntegralVal_rev_"+LegendWave[1])		WAVE	w3 = $("IntegralVal_rev_"+LegendWave[2])		Duplicate/O w1,sumW,bothW		sumW = w2+w3		doWindow/K PeakSignalBars		LS_pDiff = JT_BarGraphFromDataWithName("bothW","sumW","Integral")		doWindow/C PeakSignalBars		WAVE		Integral_mean		WAVE/T	Integral_xLabel		Integral_xLabel[0] = "both"		Integral_xLabel[1] = "sum"		LS_integralSupralin = Integral_mean[0]/Integral_mean[1]*100		Legend/C/N=text0/J/F=0/B=1/X=0.00/Y=0.00 "p="+num2str(Round(LS_pDiff*1e4)/1e4)+"\r"+num2str(LS_integralSupralin)+"%"		JT_3BarsSigStars("PeakSignalBars",JT_p2sigStr(LS_pDiff),"","")		Label left,"signal integral"	 	Button KillItButton, pos={0,0}, size={20,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	SetAxis/A/N=2 left	endif	if (nCategories==2)		doWindow/K PeakSignalBars		LS_pDiff = JT_BarGraphFromDataWithName("IntegralVal_rev_"+LegendWave[0],"IntegralVal_rev_"+LegendWave[1],"Integral")		doWindow/C PeakSignalBars		WAVE		Integral_mean		WAVE/T	Integral_xLabel		Integral_xLabel[0] = LegendWave[0]		Integral_xLabel[1] = LegendWave[1]		LS_integralSupralin = Integral_mean[0]/Integral_mean[1]*100		Legend/C/N=text0/J/F=0/B=1/X=0.00/Y=0.00 "p="+num2str(Round(LS_pDiff*1e4)/1e4)+"\r"+num2str(LS_integralSupralin)+"%"		JT_3BarsSigStars("PeakSignalBars",JT_p2sigStr(LS_pDiff),"","")		Label left,"signal integral"	 	Button KillItButton, pos={0,0}, size={20,17},proc=KillItProc, title="X",fSize=10,font="Arial"	 	SetAxis/A/N=2 left	endif	if (nCategories==1)		doWindow/K PeakSignalBars		Display as "empty graph"		doWindow/C PeakSignalBars		LS_integralSupralin = 0		LS_pDiff = 1	endifEnd//////////////////////////////////////////////////////////////////////////////////// Auto-adjust Y-axis rangeFunction ReviewLSMeasureProc(ctrlName) : ButtonControl	String ctrlName		Variable notQuiet = 1	if (stringmatch(ctrlName,"quiet"))		notQuiet = 0	endif	String		windowName = WinName(0,1)		String		TraceList = TraceNameList("",";",1)	Variable		n = ItemsInList(TraceList)	String		currWave		print "-- Measuring values in all traces --"	//	Make/O/N=(0) MaxLoc_rev	Make/O/N=(0) baseVal_rev	Make/O/N=(0) MaxVal_rev	Make/O/N=(0) Pos1Val_rev	Make/O/N=(0) Pos2Val_rev	Make/O/N=(0) IntegralVal_rev	Make/O/T/N=(0) waveName_rev	Variable	i	i = 0	do//		currWave = StringFromList(i,TraceList)				// NOTE TO SELF: Avoid bugs with liberal literal wave names		currWave = NameOfWave(WaveRefIndexed(windowName,i,1))		DoMeasureWave(currWave)		WAVE		wParams					// DoMeasureWave returns results here//		MaxLoc = wParams[0]					// Position of peak//		baseVal = wParams[1]					// Baseline value//		MaxVal = wParams[2]						// Value at peak//		Pos1Val = wParams[3]					// Position 1 value//		Pos2Val = wParams[4]					// Position 2 value//		IntegralVal = wParams[5]					// Value of integral//		MaxLoc_rev[numpnts(MaxLoc_rev)] = {wParams[0]}		baseVal_rev[numpnts(baseVal_rev)] = {wParams[1]}		MaxVal_rev[numpnts(MaxVal_rev)] = {wParams[2]}		Pos1Val_rev[numpnts(Pos1Val_rev)] = {wParams[3]}		Pos2Val_rev[numpnts(Pos2Val_rev)] = {wParams[4]}		IntegralVal_rev[numpnts(IntegralVal_rev)] = {wParams[5]}		waveName_rev[numpnts(waveName_rev)] = {currWave}		i += 1	while(i<n)		DoWindow/K ReviewLSTable	if (notQuiet)		Edit/W=(5,44,750,290) waveName_rev,baseVal_rev,MaxVal_rev,Pos1Val_rev,Pos2Val_rev,IntegralVal_rev		ModifyTable format(Point)=1,width(waveName_rev)=200		DoWindow/C ReviewLSTable	endif		NVAR		ReviewSlotNumber = ReviewSlotNumber	WAVE/T		LegendWave = LegendWave	//	Duplicate/T/O	waveName_rev,$("waveName_rev_"+LegendWave[ReviewSlotNumber])	Duplicate/O		baseVal_rev,$("baseVal_rev_"+LegendWave[ReviewSlotNumber])	Duplicate/O		MaxVal_rev,$("MaxVal_rev_"+LegendWave[ReviewSlotNumber])	Duplicate/O		Pos1Val_rev,$("Pos1Val_rev_"+LegendWave[ReviewSlotNumber])	Duplicate/O		Pos2Val_rev,$("Pos2Val_rev_"+LegendWave[ReviewSlotNumber])	Duplicate/O		IntegralVal_rev,$("IntegralVal_rev_"+LegendWave[ReviewSlotNumber])	//	Print "Copied baseVal_rev,MaxVal_rev,Pos1Val_rev,Pos2Val_rev,IntegralVal_rev into waves ending with \""+LegendWave[ReviewSlotNumber]+"\""	End//////////////////////////////////////////////////////////////////////////////////// Auto-adjust Y-axis rangeFunction AutoYRangeProc(ctrlName) : ButtonControl	String ctrlName		Print "{AutoYRangeProc} uses the IntegralStart and IntegralEnd to define regions of interest in the traces that"	Print "are used for auto-scaling the y axis."	NVAR	IntegralStart		NVAR	IntegralEnd	String	wList = WaveList("*",";","WIN:")	Variable	n = ItemsInList(wList)	Variable	MaxMax = -Inf	Variable	MinMin = Inf	Variable	currMax,currMin	String	currItem	Variable	i	i = 0	do		currItem = StringFromList(i,wList)		WaveStats/Q/R=(IntegralStart/1e3,IntegralEnd/1e3) $currItem		currMax = V_max		currMin = V_min		if (currMax>MaxMax)			MaxMax = currMax		endif		if (currMin<MinMin)			MinMin = currMin		endif		i += 1	while(i<n)	if (MinMin>0)		MinMin = 0	endif	SetAxis left,MinMin,MaxMaxEnd//////////////////////////////////////////////////////////////////////////////////// Pick positions one and twoFunction PickPosProc(ctrlName) : ButtonControl	String ctrlName	NVAR	fixPos1		NVAR	fixPos2		if ( (strlen(CsrInfo(A))==0) %| ((strlen(CsrInfo(B))==0)))		LS_PutCursorsOnGraph()	else		fixPos1 = xcsr(A)*1e3		fixPos2 = xcsr(B)*1e3	endif	End//////////////////////////////////////////////////////////////////////////////////// Pick blank-out posFunction PickBlankProc(ctrlName) : ButtonControl	String ctrlName	NVAR		BlankStart	NVAR		BlankEnd		if ( (strlen(CsrInfo(A))==0) %| ((strlen(CsrInfo(B))==0)))		LS_PutCursorsOnGraph()	else		BlankStart = xcsr(A)*1e3		BlankEnd = xcsr(B)*1e3	endif	End//////////////////////////////////////////////////////////////////////////////////// Pick integral posFunction PickIntegralProc(ctrlName) : ButtonControl	String ctrlName	NVAR		IntegralStart	NVAR		IntegralEnd		if ( (strlen(CsrInfo(A))==0) %| ((strlen(CsrInfo(B))==0)))		LS_PutCursorsOnGraph()	else		IntegralStart = xcsr(A)*1e3		IntegralEnd = xcsr(B)*1e3	endif	End//////////////////////////////////////////////////////////////////////////////////// Pick baseline posFunction PickBaselineProc(ctrlName) : ButtonControl	String ctrlName	NVAR		baseStart = baseStart	NVAR		baseWin = baseWin		if ( (strlen(CsrInfo(A))==0) %| ((strlen(CsrInfo(B))==0)))		LS_PutCursorsOnGraph()	else		baseStart = xcsr(A)*1e3		baseWin = xcsr(B)*1e3-baseStart	endif	End//////////////////////////////////////////////////////////////////////////////////// Put cursors on graphFunction LS_PutCursorsOnGraph()	String	wList = WaveList("*",";","WIN:")	String	topWave = StringFromList(0,wList)	GetAxis/Q	bottom	cursor A,$topWave,V_min	cursor B,$topWave,V_maxEnd//////////////////////////////////////////////////////////////////////////////////// Align traces in top graph//// CAREFUL! Do not use this routine if you are adding wave with SEM to graph too!Function LS_AlignBaseline(x1,x2)	Variable	x1	Variable	x2	String		ListOfWaves = WaveList("*",";","WIN:")	Variable	nItems = ItemsInList(ListOfWaves)//	Print		"Found ",nItems," waves in top graph."	String		CurrWave		Variable	i		Variable	theMean		if (x1>x2)		Variable	temp = x1		x1 = x2		x2 = temp	endif		i = 0	do		CurrWave = StringFromList(i,ListOfWaves)		WAVE	w = $CurrWave		theMean = Mean(w,x1,x2)		ModifyGraph offset($CurrWave)={0,-theMean}//		print "Doing:\t"+CurrWave," -- mean was: ",theMean		i += 1	while (i<nItems)End////////////////////////////////////////////////////////////////////////////////////// Simulate a simple progress bar windowFunction LS_MakeProgressBar()	Variable	xPos = 300+200	Variable	yPos = 273+100	Variable	Width = 320	Variable	rowHeight = 20+4	Variable	Height = 4+rowHeight*2	//	NVAR	ScSc = root:MP:ScSc//	NVAR	Progress_Max = root:MP:Progress_Max		xPos *= ScreenResolution/PanelResolution("")	yPos *= ScreenResolution/PanelResolution("")	DoWindow/K LS_ProgressWin	NewPanel /W=(xPos,yPos,xPos+Width,yPos+Height)/k=1	DoWindow/C LS_ProgressWin	ModifyPanel cbRGB=(65534,65534,65534)	ValDisplay theBar,pos={4,4+rowHeight*0},size={Width-4-4,rowHeight-4},title="Progress: "	ValDisplay theBar,labelBack=(65535,65535,65535),fSize=12,frame=2	ValDisplay theBar,limits={0,1,0},barmisc={0,0},mode= 3,value=#"root:Progress_val"	SetVariable theText,pos={4,4+rowHeight*1},size={Width-4-4,rowHeight-4},title=" "	SetVariable theText,labelBack=(65535,65535,65535),fSize=12,frame=0	SetVariable theText,noedit= 1,bodyWidth=(Width-4-4),value=root:Progress_MessageStrEndFunction LS_KillProgressBar()	Variable		TickSave = Ticks	do		doXOPIdle	while (TickSave+60.15*0.5>Ticks)	DoWindow/K LS_ProgressWinEndFunction LS_UpdateProgressBar(TheValue,TheText)	Variable		TheValue	String		TheText	NVAR		Progress_Val =			root:Progress_Val//	NVAR		Progress_TickSave =		root:Progress_TickSave	SVAR		Progress_MessageStr =	root:Progress_MessageStr	Progress_Val = TheValue	Progress_MessageStr = TheText	DoWindow/F ProgressWin	DoUpdate	//	// Make sure progress bar is visible //	do//		doXOPIdle//	while (Progress_TickSave+2>Ticks)//	Progress_TickSave = TicksEnd